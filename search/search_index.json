{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Welcome to AIRS Protocols","text":"<p>Common AI Communication Protocols and LLM API Implementations in Rust</p> <p>A comprehensive Rust workspace providing production-ready implementations of agent communication protocols and LLM provider APIs. Built with performance, type safety, and interoperability in mind.</p>"},{"location":"#quick-links","title":"\ud83d\ude80 Quick Links","text":""},{"location":"#getting-started","title":"\ud83d\ude80 Getting Started","text":"<p>Get up and running with AIRS Protocols in minutes.</p>"},{"location":"#protocols","title":"\ud83d\udd27 Protocols","text":"<p>Explore communication protocols for AI agents.</p>"},{"location":"#servers","title":"\ud83d\udda5\ufe0f Servers","text":"<p>Production-ready MCP server implementations.</p>"},{"location":"#apis","title":"\ud83c\udf10 APIs","text":"<p>LLM provider client implementations (Coming Soon).</p>"},{"location":"#examples","title":"\ud83d\udcda Examples","text":"<p>Learn from practical examples and tutorials.</p>"},{"location":"#whats-inside","title":"\ud83d\udce6 What's Inside","text":""},{"location":"#protocols-protocols","title":"Protocols (<code>protocols/</code>)","text":"<p>Communication protocols for AI agents and intelligent systems:</p> <ul> <li>MCP - Model Context Protocol v1.0.0-rc.1</li> <li>Connect AI models to tools, resources, and context</li> <li>JSON-RPC 2.0 foundation with transport abstraction</li> <li>Built-in authentication (API Key, OAuth2) and authorization</li> <li> <p>Stdio and HTTP transport implementations</p> </li> <li> <p>A2A - Agent-to-Agent Protocol Planned</p> </li> <li>Enable communication between independent AI agents</li> <li>Multiple protocol bindings (JSON-RPC, gRPC, REST)</li> <li>Task lifecycle management and streaming support</li> </ul>"},{"location":"#servers-mcpservers","title":"Servers (<code>mcp/servers/</code>)","text":"<p>Production-ready MCP server implementations:</p> <ul> <li>Filesystem Server v1.0.0-rc.1</li> <li>Security-first filesystem operations for Claude Desktop and AI tools</li> <li>Human-in-the-loop approval workflows with configurable policies</li> <li>Comprehensive path validation and binary file restriction</li> <li>Complete file operations: read, write, list, create, delete, move, copy</li> <li>Sub-100ms response times with audit logging</li> </ul>"},{"location":"#apis-apis","title":"APIs (<code>apis/</code>)","text":"<p>LLM provider client implementations with unified interfaces (Coming Soon):</p> <ul> <li>Anthropic Claude API client</li> <li>OpenAI GPT API client</li> <li>Google Gemini API client</li> <li>Ollama local models client</li> </ul>"},{"location":"#key-features","title":"\u2728 Key Features","text":""},{"location":"#type-safety-first","title":"Type Safety First","text":"<p>Leverage Rust's type system for protocol compliance with compile-time verification and zero-cost abstractions.</p>"},{"location":"#protocol-agnostic","title":"Protocol Agnostic","text":"<p>Clean separation between protocol specification and transport with multiple implementations (stdio, HTTP, WebSocket).</p>"},{"location":"#production-ready","title":"Production Ready","text":"<p>Comprehensive error handling, built-in authentication and authorization, extensive testing, and performance benchmarks.</p>"},{"location":"#async-native","title":"Async Native","text":"<p>Built on <code>tokio</code> async runtime with non-blocking I/O throughout and efficient concurrent operations.</p>"},{"location":"#interoperability","title":"Interoperability","text":"<p>Standards-compliant implementations compatible with official SDKs (Python, TypeScript, etc.) and bridge adapters for protocol interop.</p>"},{"location":"#project-structure","title":"\ud83c\udfd7\ufe0f Project Structure","text":"<pre><code>airsprotocols/\n\u251c\u2500\u2500 protocols/          # Communication protocols\n\u2502   \u251c\u2500\u2500 mcp/           # Model Context Protocol\n\u2502   \u2514\u2500\u2500 a2a/           # Agent-to-Agent Protocol (Planned)\n\u2502\n\u251c\u2500\u2500 mcp/\n\u2502   \u2514\u2500\u2500 servers/       # MCP server implementations\n\u2502       \u2514\u2500\u2500 filesystem/ # Filesystem server\n\u2502\n\u2514\u2500\u2500 apis/              # LLM provider clients (Planned)\n    \u251c\u2500\u2500 anthropic/     # Claude API\n    \u251c\u2500\u2500 openai/        # GPT API\n    \u251c\u2500\u2500 google/        # Gemini API\n    \u2514\u2500\u2500 ollama/        # Local models\n</code></pre>"},{"location":"#use-cases","title":"\ud83c\udfaf Use Cases","text":"<ul> <li>AI Agent Development: Build intelligent agents that communicate using standard protocols</li> <li>LLM Integration: Connect language models to external tools and data sources</li> <li>Multi-Agent Systems: Enable collaboration between independent AI agents</li> <li>Tool Providers: Expose capabilities to AI models through standardized interfaces</li> <li>Resource Management: Provide structured access to data and content for AI systems</li> </ul>"},{"location":"#quick-example","title":"\ud83d\ude80 Quick Example","text":"<p>Add to your <code>Cargo.toml</code>:</p> <pre><code>[dependencies]\nairsprotocols-mcp = { git = \"https://github.com/airsstack/airsprotocols\" }\n</code></pre> <p>Create an MCP client:</p> <pre><code>use airsprotocols_mcp::McpClientBuilder;\nuse std::time::Duration;\n\n#[tokio::main]\nasync fn main() -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {\n    let client = McpClientBuilder::new()\n        .client_info(\"my-app\", \"0.1.0\")\n        .timeout(Duration::from_secs(30))\n        .build(transport)\n        .await?;\n\n    let tools = client.list_tools().await?;\n    println!(\"Available tools: {:?}\", tools);\n\n    Ok(())\n}\n</code></pre> <p>For detailed guides, see Getting Started.</p>"},{"location":"#documentation","title":"\ud83d\udcda Documentation","text":"<ul> <li>Overview - Detailed project overview and philosophy</li> <li>Getting Started - Quick start guide</li> <li>Architecture - High-level architecture</li> <li>Protocols - Protocol implementations</li> <li>Examples - Practical examples</li> <li>Contributing - Contribution guidelines</li> </ul>"},{"location":"#related-projects","title":"\ud83d\udd17 Related Projects","text":"<ul> <li>airsstack - Application-level agent implementations and example applications</li> </ul>"},{"location":"#license","title":"\ud83d\udcc4 License","text":"<p>Dual licensed under: - Apache License, Version 2.0 (LICENSE-APACHE) - MIT License (LICENSE-MIT)</p> <p>You may choose either license for your use.</p>"},{"location":"#contributing","title":"\ud83e\udd1d Contributing","text":"<p>Contributions are welcome! See our Contributing Guide for details on:</p> <ul> <li>Development setup</li> <li>Code standards</li> <li>Testing requirements</li> <li>Pull request process</li> </ul> <p>Built with \ud83e\udd80 Rust | Powered by the AI Agent Ecosystem</p>"},{"location":"architecture/","title":"Architecture","text":"<p>This document provides a high-level overview of the AIRS Protocols workspace architecture, design patterns, and organizational principles.</p>"},{"location":"architecture/#workspace-architecture","title":"Workspace Architecture","text":"<p>AIRS Protocols is organized as a Cargo workspace with a clean separation between different concerns:</p> <pre><code>airsprotocols/\n\u251c\u2500\u2500 protocols/          # Communication protocol implementations\n\u2502   \u251c\u2500\u2500 mcp/           # Model Context Protocol\n\u2502   \u2514\u2500\u2500 a2a/           # Agent-to-Agent Protocol (Planned)\n\u2502\n\u251c\u2500\u2500 apis/              # LLM provider API clients (Planned)\n\u2502   \u251c\u2500\u2500 anthropic/     # Claude API client\n\u2502   \u251c\u2500\u2500 openai/        # GPT API client\n\u2502   \u251c\u2500\u2500 google/        # Gemini API client\n\u2502   \u2514\u2500\u2500 ollama/        # Ollama client\n\u2502\n\u2514\u2500\u2500 Cargo.toml         # Workspace configuration\n</code></pre>"},{"location":"architecture/#workspace-benefits","title":"Workspace Benefits","text":"<ul> <li>Shared Dependencies: Common dependencies managed at workspace level</li> <li>Consistent Standards: Unified linting, formatting, and testing</li> <li>Cross-Package Integration: Easy integration between protocols and APIs</li> <li>Independent Versioning: Each package maintains its own version</li> <li>Optimized Builds: Cargo optimizes builds across the workspace</li> </ul>"},{"location":"architecture/#dependency-layers","title":"Dependency Layers","text":"<p>The workspace organizes dependencies in conceptual layers to maintain clean architecture:</p>"},{"location":"architecture/#layer-1-airs-protocols-crates","title":"Layer 1: AIRS Protocols Crates","text":"<ul> <li>Internal workspace crates</li> <li><code>airsprotocols-mcp</code>, <code>airsprotocols-a2a</code>, etc.</li> </ul>"},{"location":"architecture/#layer-2-core-runtime","title":"Layer 2: Core Runtime","text":"<ul> <li><code>tokio</code> - Async runtime</li> <li><code>tokio-stream</code> - Async stream utilities</li> <li><code>futures</code> - Future and async traits</li> </ul>"},{"location":"architecture/#layer-3-serialization-data","title":"Layer 3: Serialization &amp; Data","text":"<ul> <li><code>serde</code> - Serialization framework</li> <li><code>serde_json</code> - JSON support</li> <li><code>serde_urlencoded</code> - URL encoding</li> </ul>"},{"location":"architecture/#layer-4-async-concurrency","title":"Layer 4: Async &amp; Concurrency","text":"<ul> <li><code>dashmap</code> - Concurrent hash map</li> <li><code>async-trait</code> - Async trait support</li> </ul>"},{"location":"architecture/#layer-5-error-handling","title":"Layer 5: Error Handling","text":"<ul> <li><code>thiserror</code> - Error derive macros</li> </ul>"},{"location":"architecture/#layer-6-utilities","title":"Layer 6: Utilities","text":"<ul> <li><code>uuid</code> - Unique identifiers</li> <li><code>bytes</code> - Byte manipulation</li> <li><code>chrono</code> - Date and time</li> <li><code>tracing</code> - Logging framework</li> </ul>"},{"location":"architecture/#layer-7-http-networking","title":"Layer 7: HTTP &amp; Networking","text":"<ul> <li><code>axum</code> - Web framework</li> <li><code>hyper</code> - HTTP library</li> <li><code>tower</code> - Service middleware</li> <li><code>reqwest</code> - HTTP client</li> </ul>"},{"location":"architecture/#layer-8-authentication-security","title":"Layer 8: Authentication &amp; Security","text":"<ul> <li><code>jsonwebtoken</code> - JWT handling</li> <li><code>oauth2</code> - OAuth2 client</li> <li><code>base64</code> - Base64 encoding</li> </ul>"},{"location":"architecture/#design-patterns","title":"Design Patterns","text":""},{"location":"architecture/#protocol-implementation-pattern","title":"Protocol Implementation Pattern","text":"<p>All protocol implementations follow a consistent architecture:</p> <pre><code>\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502     Integration Layer               \u2502\n\u2502  (High-level Client/Server APIs)    \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                 \u2193\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502     Provider Layer                  \u2502\n\u2502  (Capability Implementations)       \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                 \u2193\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502     Protocol Layer                  \u2502\n\u2502  (Message Types &amp; Validation)       \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                 \u2193\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502     Transport Layer                 \u2502\n\u2502  (Communication Abstractions)       \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"architecture/#integration-layer","title":"Integration Layer","text":"<ul> <li>High-level APIs (e.g., <code>McpClient</code>, <code>McpServer</code>)</li> <li>Builder patterns for configuration</li> <li>Lifecycle management</li> <li>User-facing interfaces</li> </ul>"},{"location":"architecture/#provider-layer","title":"Provider Layer","text":"<ul> <li>Trait-based capability interfaces</li> <li>Tool, Resource, and Prompt providers</li> <li>Extensible implementation model</li> <li>Business logic integration points</li> </ul>"},{"location":"architecture/#protocol-layer","title":"Protocol Layer","text":"<ul> <li>Message type definitions</li> <li>Protocol validation</li> <li>Spec compliance</li> <li>Error types</li> </ul>"},{"location":"architecture/#transport-layer","title":"Transport Layer","text":"<ul> <li>Transport abstraction trait</li> <li>Concrete implementations (stdio, HTTP, WebSocket)</li> <li>Connection management</li> <li>Low-level communication</li> </ul>"},{"location":"architecture/#builder-pattern","title":"Builder Pattern","text":"<p>All major components use the builder pattern for construction:</p> <pre><code>let client = McpClientBuilder::new()\n    .client_info(\"my-app\", \"1.0.0\")\n    .timeout(Duration::from_secs(30))\n    .capabilities(capabilities)\n    .build(transport)\n    .await?;\n</code></pre> <p>Benefits: - Clear, self-documenting API - Optional parameters with defaults - Compile-time validation - Ergonomic configuration</p>"},{"location":"architecture/#trait-based-extensibility","title":"Trait-Based Extensibility","text":"<p>Protocols define core traits that users implement:</p> <pre><code>#[async_trait]\npub trait ToolProvider: Send + Sync {\n    async fn list_tools(&amp;self) -&gt; Result&lt;Vec&lt;Tool&gt;, Error&gt;;\n    async fn call_tool(&amp;self, call: ToolCall) -&gt; Result&lt;ToolResult, Error&gt;;\n}\n</code></pre> <p>Benefits: - Clean separation of concerns - Easy testing with mocks - Flexible implementation strategies - Protocol evolution without breaking changes</p>"},{"location":"architecture/#type-safe-error-handling","title":"Type-Safe Error Handling","text":"<p>All operations return <code>Result&lt;T, E&gt;</code> with specific error types:</p> <pre><code>pub enum IntegrationError {\n    ConnectionFailed(String),\n    ProtocolError(String),\n    MethodNotFound(String),\n    // ...\n}\n</code></pre> <p>Benefits: - Explicit error handling - Rich error context - Type-safe error propagation - Clear error recovery paths</p>"},{"location":"architecture/#mcp-architecture","title":"MCP Architecture","text":"<p>The Model Context Protocol implementation demonstrates the architectural patterns:</p> <pre><code>flowchart TD\n    subgraph \"Client Application\"\n        App[\"Application Code\"]\n    end\n\n    subgraph \"AIRS MCP Crate\"\n        McpClient[\"McpClient&lt;br/&gt;(Integration Layer)\"]\n\n        subgraph \"Protocol Layer\"\n            Messages[\"Message Types\"]\n            Validation[\"Validation\"]\n        end\n\n        subgraph \"Transport Layer\"\n            StdioTransport[\"Stdio Transport\"]\n            HttpTransport[\"HTTP Transport\"]\n            TransportTrait[\"Transport Trait\"]\n        end\n    end\n\n    subgraph \"Server\"\n        McpServer[\"MCP Server\"]\n        Providers[\"Providers&lt;br/&gt;(Tools, Resources, Prompts)\"]\n    end\n\n    App --&gt; McpClient\n    McpClient --&gt; Messages\n    Messages --&gt; TransportTrait\n    TransportTrait -.-&gt; StdioTransport\n    TransportTrait -.-&gt; HttpTransport\n    StdioTransport --&gt; McpServer\n    HttpTransport --&gt; McpServer\n    McpServer --&gt; Providers</code></pre> <p>For detailed MCP architecture, see MCP Architecture.</p>"},{"location":"architecture/#async-architecture","title":"Async Architecture","text":"<p>All AIRS Protocols are built on async/await with tokio:</p>"},{"location":"architecture/#async-principles","title":"Async Principles","text":"<ol> <li>Non-Blocking I/O: All I/O operations are async</li> <li>Concurrent Execution: Multiple operations can run concurrently</li> <li>Efficient Resources: Minimal memory and CPU overhead</li> <li>Scalability: Handle thousands of concurrent connections</li> </ol>"},{"location":"architecture/#async-patterns","title":"Async Patterns","text":"<pre><code>// Async trait methods\n#[async_trait]\npub trait Transport: Send + Sync {\n    async fn send(&amp;self, message: JsonRpcMessage) -&gt; Result&lt;JsonRpcMessage, Error&gt;;\n}\n\n// Async client operations\nlet tools = client.list_tools().await?;\nlet result = client.call_tool(tool_call).await?;\n</code></pre>"},{"location":"architecture/#testing-architecture","title":"Testing Architecture","text":""},{"location":"architecture/#testing-layers","title":"Testing Layers","text":"<ol> <li>Unit Tests: Test individual components in isolation</li> <li>Integration Tests: Test component interactions</li> <li>Property-Based Tests: Test invariants with random inputs</li> <li>Benchmark Tests: Measure performance characteristics</li> </ol>"},{"location":"architecture/#testing-tools","title":"Testing Tools","text":"<ul> <li>proptest: Property-based testing for edge cases</li> <li>criterion: Performance benchmarking</li> <li>tokio-test: Async testing utilities</li> <li>wiremock: HTTP mocking for integration tests</li> </ul>"},{"location":"architecture/#security-architecture","title":"Security Architecture","text":""},{"location":"architecture/#authentication-layer","title":"Authentication Layer","text":"<ul> <li>Pluggable authentication strategies</li> <li>API Key authentication</li> <li>OAuth2 with PKCE support</li> <li>Bearer token authentication</li> </ul>"},{"location":"architecture/#authorization-layer","title":"Authorization Layer","text":"<ul> <li>Policy-based authorization</li> <li>Scope validation</li> <li>Resource-level access control</li> <li>Audit logging</li> </ul>"},{"location":"architecture/#transport-security","title":"Transport Security","text":"<ul> <li>HTTPS for HTTP transport</li> <li>Token validation</li> <li>Request signing</li> <li>Rate limiting support</li> </ul>"},{"location":"architecture/#performance-considerations","title":"Performance Considerations","text":""},{"location":"architecture/#zero-cost-abstractions","title":"Zero-Cost Abstractions","text":"<ul> <li>Trait objects only where necessary</li> <li>Generic types for compile-time optimization</li> <li>Inline critical paths</li> <li>Minimal allocations</li> </ul>"},{"location":"architecture/#connection-pooling","title":"Connection Pooling","text":"<ul> <li>Reusable connection pools</li> <li>Connection lifecycle management</li> <li>Backpressure handling</li> <li>Graceful degradation</li> </ul>"},{"location":"architecture/#async-efficiency","title":"Async Efficiency","text":"<ul> <li>Tokio task spawning for concurrency</li> <li>Stream-based processing</li> <li>Buffered I/O</li> <li>Selective polling</li> </ul>"},{"location":"architecture/#future-architecture","title":"Future Architecture","text":""},{"location":"architecture/#planned-extensions","title":"Planned Extensions","text":"<ol> <li>Bridge Adapters: Protocol translation between MCP and A2A</li> <li>Unified LLM Interface: Common API across providers</li> <li>Plugin System: Dynamic capability loading</li> <li>Distributed Tracing: OpenTelemetry integration</li> </ol>"},{"location":"architecture/#extensibility-points","title":"Extensibility Points","text":"<ul> <li>Custom transport implementations</li> <li>Additional authentication strategies</li> <li>Protocol extensions</li> <li>Custom provider types</li> </ul>"},{"location":"architecture/#development-guidelines","title":"Development Guidelines","text":""},{"location":"architecture/#code-organization","title":"Code Organization","text":"<ul> <li>One concept per module: Clear module boundaries</li> <li>Public API minimization: Expose only what's necessary</li> <li>Documentation first: Document before implementing</li> <li>Test-driven development: Write tests alongside code</li> </ul>"},{"location":"architecture/#api-design","title":"API Design","text":"<ul> <li>Builder pattern: For complex construction</li> <li>Trait-based: For extensibility</li> <li>Result types: For error handling</li> <li>Async-first: All I/O is async</li> </ul>"},{"location":"architecture/#performance","title":"Performance","text":"<ul> <li>Measure first: Profile before optimizing</li> <li>Avoid allocations: Reuse buffers where possible</li> <li>Benchmark regressions: Automated performance testing</li> <li>Document complexity: Big-O analysis for algorithms</li> </ul>"},{"location":"architecture/#references","title":"References","text":""},{"location":"architecture/#internal-documentation","title":"Internal Documentation","text":"<ul> <li>MCP Architecture</li> <li>MCP Data Flow</li> <li>Getting Started</li> </ul>"},{"location":"architecture/#external-resources","title":"External Resources","text":"<ul> <li>Model Context Protocol Specification</li> <li>Tokio Documentation</li> <li>Rust Async Book</li> </ul> <p>Continue to MCP Documentation for protocol-specific architecture details.</p>"},{"location":"contributing/","title":"Contributing to AIRS Protocols","text":"<p>Thank you for your interest in contributing to AIRS Protocols! This guide will help you get started.</p>"},{"location":"contributing/#ways-to-contribute","title":"Ways to Contribute","text":"<p>There are many ways to contribute to AIRS Protocols:</p> <ul> <li>\ud83d\udc1b Report Bugs: Find and report issues</li> <li>\ud83d\udca1 Suggest Features: Propose new capabilities</li> <li>\ud83d\udcdd Improve Documentation: Fix typos, clarify instructions, add examples</li> <li>\ud83d\udd27 Write Code: Fix bugs, implement features, optimize performance</li> <li>\ud83e\uddea Write Tests: Add test coverage, create integration tests</li> <li>\ud83d\udcac Help Others: Answer questions in discussions</li> </ul>"},{"location":"contributing/#getting-started","title":"Getting Started","text":""},{"location":"contributing/#prerequisites","title":"Prerequisites","text":"<ul> <li>Rust 1.88 or later</li> <li>Git for version control</li> <li>Cargo (comes with Rust)</li> <li>A GitHub account</li> </ul>"},{"location":"contributing/#development-setup","title":"Development Setup","text":"<ol> <li>Fork the Repository</li> </ol> <p>Visit github.com/airsstack/airsprotocols and click \"Fork\"</p> <ol> <li>Clone Your Fork</li> </ol> <pre><code>git clone https://github.com/YOUR_USERNAME/airsprotocols.git\ncd airsprotocols\n</code></pre> <ol> <li>Add Upstream Remote</li> </ol> <pre><code>git remote add upstream https://github.com/airsstack/airsprotocols.git\n</code></pre> <ol> <li>Install Development Tools</li> </ol> <pre><code># Install rustfmt for code formatting\nrustup component add rustfmt\n\n# Install clippy for linting\nrustup component add clippy\n\n# Install mdBook for documentation (optional)\ncargo install mdbook\n</code></pre> <ol> <li>Build the Project</li> </ol> <pre><code>cargo build\n</code></pre> <ol> <li>Run Tests</li> </ol> <pre><code>cargo test --workspace\n</code></pre>"},{"location":"contributing/#development-workflow","title":"Development Workflow","text":""},{"location":"contributing/#1-create-a-branch","title":"1. Create a Branch","text":"<p>Create a branch for your changes:</p> <pre><code>git checkout -b feature/your-feature-name\n</code></pre> <p>Branch naming conventions:</p> <ul> <li><code>feature/</code> - New features</li> <li><code>fix/</code> - Bug fixes</li> <li><code>docs/</code> - Documentation changes</li> <li><code>refactor/</code> - Code refactoring</li> <li><code>test/</code> - Test additions or modifications</li> </ul>"},{"location":"contributing/#2-make-changes","title":"2. Make Changes","text":"<p>Follow our coding standards (see below) and make your changes.</p>"},{"location":"contributing/#3-test-your-changes","title":"3. Test Your Changes","text":"<pre><code># Run all tests\ncargo test --workspace\n\n# Run specific package tests\ncargo test -p airsprotocols-mcp\n\n# Run with output\ncargo test -- --nocapture\n\n# Run integration tests\ncargo test --test '*' -- --test-threads=1\n</code></pre>"},{"location":"contributing/#4-format-and-lint","title":"4. Format and Lint","text":"<pre><code># Format code\ncargo fmt --all\n\n# Run clippy\ncargo clippy --workspace --all-targets -- -D warnings\n</code></pre>"},{"location":"contributing/#5-commit-your-changes","title":"5. Commit Your Changes","text":"<p>Follow conventional commit message format:</p> <pre><code>type(scope): short description\n\nLonger description if needed.\n\nFixes #issue_number\n</code></pre> <p>Types: - <code>feat</code>: New feature - <code>fix</code>: Bug fix - <code>docs</code>: Documentation changes - <code>refactor</code>: Code refactoring - <code>test</code>: Test additions/modifications - <code>chore</code>: Maintenance tasks</p> <p>Example:</p> <pre><code>git add .\ngit commit -m \"feat(mcp): add OAuth2 token refresh support\n\nImplements automatic token refresh for OAuth2 authentication\nto improve user experience and reduce authentication failures.\n\nFixes #123\"\n</code></pre>"},{"location":"contributing/#6-push-and-create-pull-request","title":"6. Push and Create Pull Request","text":"<pre><code>git push origin feature/your-feature-name\n</code></pre> <p>Then create a pull request on GitHub.</p>"},{"location":"contributing/#coding-standards","title":"Coding Standards","text":""},{"location":"contributing/#rust-code-style","title":"Rust Code Style","text":"<p>Follow these guidelines:</p> <ol> <li> <p>Use <code>rustfmt</code>: All code must be formatted with <code>cargo fmt</code></p> </li> <li> <p>Follow Clippy: Address all clippy warnings with <code>cargo clippy</code></p> </li> <li> <p>Document Public APIs: All public items must have documentation comments</p> </li> </ol> <pre><code>/// Describes what this function does.\n///\n/// # Arguments\n///\n/// * `param` - Description of parameter\n///\n/// # Returns\n///\n/// Description of return value\n///\n/// # Errors\n///\n/// Description of error conditions\npub fn my_function(param: Type) -&gt; Result&lt;ReturnType, Error&gt; {\n    // implementation\n}\n</code></pre> <ol> <li>Use Explicit Error Handling: Avoid <code>unwrap()</code> and <code>expect()</code> in library code</li> </ol> <pre><code>// Bad\nlet value = some_result.unwrap();\n\n// Good\nlet value = some_result?;\n// or\nlet value = some_result.map_err(|e| MyError::from(e))?;\n</code></pre> <ol> <li>Follow Workspace Lint Rules: The workspace defines mandatory lints</li> </ol> <pre><code>// These are denied in production code:\n// - unwrap_used\n// - expect_used\n// - panic\n</code></pre>"},{"location":"contributing/#testing-standards","title":"Testing Standards","text":"<ol> <li> <p>Write Tests for New Code: All new features should include tests</p> </li> <li> <p>Test Public APIs: Focus on testing the public interface</p> </li> <li> <p>Use Descriptive Test Names:</p> </li> </ol> <pre><code>#[test]\nfn test_tool_provider_returns_correct_result() {\n    // test implementation\n}\n</code></pre> <ol> <li> <p>Include Integration Tests: For cross-component functionality</p> </li> <li> <p>Use Property-Based Testing: For complex algorithms (using proptest)</p> </li> </ol>"},{"location":"contributing/#documentation-standards","title":"Documentation Standards","text":"<ol> <li> <p>Clear and Concise: Write for your audience</p> </li> <li> <p>Include Examples: Show how to use the API</p> </li> </ol> <pre><code>/// # Example\n///\n/// ```rust\n/// let client = McpClientBuilder::new()\n///     .build(transport)\n///     .await?;\n/// ```\n</code></pre> <ol> <li> <p>Update Related Docs: Keep documentation synchronized with code</p> </li> <li> <p>Follow Diataxis Framework: Use the documentation guidelines in <code>.aiassisted/guidelines/documentation/</code></p> </li> </ol>"},{"location":"contributing/#pull-request-process","title":"Pull Request Process","text":""},{"location":"contributing/#before-submitting","title":"Before Submitting","text":"<ul> <li> Code is formatted (<code>cargo fmt</code>)</li> <li> All tests pass (<code>cargo test</code>)</li> <li> No clippy warnings (<code>cargo clippy</code>)</li> <li> Documentation is updated</li> <li> Commit messages follow conventions</li> <li> Branch is up to date with main</li> </ul>"},{"location":"contributing/#pr-description","title":"PR Description","text":"<p>Include in your PR description:</p> <ol> <li>What: What does this PR do?</li> <li>Why: Why is this change needed?</li> <li>How: How does it work?</li> <li>Testing: How was it tested?</li> <li>Issues: References to related issues</li> </ol> <p>Example:</p> <pre><code>## What\n\nAdds OAuth2 token refresh support to the MCP HTTP client.\n\n## Why\n\nUsers were experiencing authentication failures when tokens expired,\nrequiring manual re-authentication.\n\n## How\n\nImplements automatic token refresh using the refresh token. The client\nnow monitors token expiration and proactively refreshes before expiry.\n\n## Testing\n\n- Added unit tests for token refresh logic\n- Added integration test with mock OAuth2 server\n- Tested with Claude Desktop integration\n\n## Issues\n\nFixes #123\nRelated to #456\n</code></pre>"},{"location":"contributing/#review-process","title":"Review Process","text":"<ol> <li>Automated Checks: CI runs tests and linting</li> <li>Code Review: Maintainers review your code</li> <li>Address Feedback: Make requested changes</li> <li>Approval: PR is approved</li> <li>Merge: Maintainers merge your PR</li> </ol>"},{"location":"contributing/#code-review-guidelines","title":"Code Review Guidelines","text":""},{"location":"contributing/#for-contributors","title":"For Contributors","text":"<ul> <li>Be Receptive: Accept feedback gracefully</li> <li>Ask Questions: If feedback is unclear, ask for clarification</li> <li>Make Changes: Address review comments promptly</li> <li>Learn: Use reviews as learning opportunities</li> </ul>"},{"location":"contributing/#for-reviewers","title":"For Reviewers","text":"<ul> <li>Be Respectful: Provide constructive feedback</li> <li>Be Specific: Explain why changes are needed</li> <li>Praise Good Work: Acknowledge good solutions</li> <li>Focus on Code: Review the code, not the person</li> </ul>"},{"location":"contributing/#development-guidelines","title":"Development Guidelines","text":""},{"location":"contributing/#architecture","title":"Architecture","text":"<p>Follow the established architecture patterns:</p> <ul> <li>Integration Layer: High-level APIs</li> <li>Provider Layer: Capability implementations</li> <li>Protocol Layer: Message types and validation</li> <li>Transport Layer: Communication abstractions</li> </ul> <p>See Architecture Guide for details.</p>"},{"location":"contributing/#error-handling","title":"Error Handling","text":"<p>Use Result types and custom error types:</p> <pre><code>#[derive(Debug, thiserror::Error)]\npub enum MyError {\n    #[error(\"connection failed: {0}\")]\n    ConnectionFailed(String),\n\n    #[error(\"protocol error: {0}\")]\n    ProtocolError(String),\n}\n</code></pre>"},{"location":"contributing/#async-code","title":"Async Code","text":"<p>All I/O should be async:</p> <pre><code>#[async_trait]\npub trait MyTrait: Send + Sync {\n    async fn my_method(&amp;self) -&gt; Result&lt;T, Error&gt;;\n}\n</code></pre>"},{"location":"contributing/#community-guidelines","title":"Community Guidelines","text":""},{"location":"contributing/#code-of-conduct","title":"Code of Conduct","text":"<p>Be respectful, inclusive, and professional:</p> <ul> <li>Be Welcoming: Welcome newcomers</li> <li>Be Respectful: Respect differing viewpoints</li> <li>Be Constructive: Provide constructive criticism</li> <li>Be Patient: Help others learn</li> </ul>"},{"location":"contributing/#getting-help","title":"Getting Help","text":"<ul> <li>Documentation: Check the docs first</li> <li>Discussions: Ask in GitHub Discussions</li> <li>Issues: Report bugs in GitHub Issues</li> </ul>"},{"location":"contributing/#project-structure","title":"Project Structure","text":"<pre><code>airsprotocols/\n\u251c\u2500\u2500 protocols/          # Protocol implementations\n\u2502   \u251c\u2500\u2500 mcp/           # Model Context Protocol\n\u2502   \u2514\u2500\u2500 a2a/           # Agent-to-Agent (planned)\n\u251c\u2500\u2500 apis/              # LLM APIs (planned)\n\u251c\u2500\u2500 docs/              # Documentation source\n\u251c\u2500\u2500 site-mkdocs/       # MkDocs configuration\n\u2514\u2500\u2500 .aiassisted/       # Development guidelines\n</code></pre>"},{"location":"contributing/#release-process","title":"Release Process","text":"<p>Maintainers handle releases, but here's the process:</p> <ol> <li>Version Bump: Update version in <code>Cargo.toml</code></li> <li>Changelog: Update <code>CHANGELOG.md</code></li> <li>Tag: Create git tag</li> <li>Publish: Publish to crates.io</li> <li>Announce: Announce release</li> </ol>"},{"location":"contributing/#recognition","title":"Recognition","text":"<p>Contributors are recognized in:</p> <ul> <li>Repository contributor list</li> <li>Release notes</li> <li>Documentation acknowledgments</li> </ul>"},{"location":"contributing/#questions","title":"Questions?","text":"<p>If you have questions about contributing:</p> <ul> <li>Check this guide</li> <li>Ask in GitHub Discussions</li> <li>Review existing PRs for examples</li> <li>Contact maintainers</li> </ul> <p>Thank you for contributing to AIRS Protocols! \ud83e\udd80</p>"},{"location":"getting-started/","title":"Getting Started","text":"<p>This guide will help you get up and running with AIRS Protocols quickly.</p>"},{"location":"getting-started/#prerequisites","title":"Prerequisites","text":"<p>Before you begin, ensure you have the following installed:</p> <ul> <li>Rust 1.88 or later (install instructions)</li> <li>Cargo (comes with Rust)</li> <li>A code editor with Rust support (e.g., VS Code with rust-analyzer)</li> </ul>"},{"location":"getting-started/#verify-installation","title":"Verify Installation","text":"<pre><code>rustc --version\ncargo --version\n</code></pre>"},{"location":"getting-started/#installation","title":"Installation","text":""},{"location":"getting-started/#using-mcp-model-context-protocol","title":"Using MCP (Model Context Protocol)","text":"<p>Add AIRS Protocols MCP to your <code>Cargo.toml</code>:</p> <pre><code>[dependencies]\n# From git repository (current):\nairsprotocols-mcp = { git = \"https://github.com/airsstack/airsprotocols\" }\n\n# Or when published to crates.io:\n# airsprotocols-mcp = \"1.0.0-rc.1\"\n\n# Required async runtime:\ntokio = { version = \"1.47\", features = [\"full\"] }\n</code></pre>"},{"location":"getting-started/#future-packages","title":"Future Packages","text":"<p>Other packages will be available as they're released:</p> <pre><code>[dependencies]\n# Coming soon:\n# airsprotocols-a2a = \"0.1.0\"\n# airsprotocols-anthropic = \"0.1.0\"\n# airsprotocols-openai = \"0.1.0\"\n</code></pre>"},{"location":"getting-started/#quick-start-mcp-client","title":"Quick Start: MCP Client","text":"<p>Here's a minimal example of creating an MCP client:</p> <pre><code>use airsprotocols_mcp::McpClientBuilder;\nuse std::time::Duration;\n\n#[tokio::main]\nasync fn main() -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {\n    // Create an MCP client\n    let client = McpClientBuilder::new()\n        .client_info(\"my-app\", \"0.1.0\")\n        .timeout(Duration::from_secs(30))\n        .build(transport)  // transport implementation needed\n        .await?;\n\n    // List available tools from the server\n    let tools = client.list_tools().await?;\n    println!(\"Available tools: {}\", tools.len());\n\n    Ok(())\n}\n</code></pre> <p>Transport Required</p> <p>The example above requires a transport implementation. See MCP Quick Start for complete examples with stdio and HTTP transports.</p>"},{"location":"getting-started/#quick-start-mcp-server","title":"Quick Start: MCP Server","text":"<p>Create a simple MCP server that provides tools:</p> <pre><code>use std::sync::Arc;\nuse async_trait::async_trait;\nuse serde_json::json;\nuse airsprotocols_mcp::protocol::{JsonRpcMessage, MessageContext, MessageHandler};\nuse airsprotocols_mcp::providers::{ToolProvider, ToolCall, ToolResult};\nuse airsprotocols_mcp::transport::adapters::stdio::StdioTransport;\nuse airsprotocols_mcp::IntegrationError;\n\n// Implement a simple tool provider\nstruct MyToolProvider;\n\n#[async_trait]\nimpl ToolProvider for MyToolProvider {\n    async fn call_tool(&amp;self, tool_call: ToolCall) -&gt; Result&lt;ToolResult, IntegrationError&gt; {\n        match tool_call.name.as_str() {\n            \"add\" =&gt; {\n                let params = tool_call.params.unwrap_or_default();\n                let a = params[\"a\"].as_i64().unwrap_or(0);\n                let b = params[\"b\"].as_i64().unwrap_or(0);\n                let result = a + b;\n                Ok(ToolResult::success(json!({ \"result\": result })))\n            }\n            _ =&gt; Err(IntegrationError::MethodNotFound(tool_call.name))\n        }\n    }\n\n    // Other required methods...\n}\n\n#[tokio::main]\nasync fn main() -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {\n    let tool_provider = Arc::new(MyToolProvider);\n    // Set up handler and transport...\n\n    Ok(())\n}\n</code></pre> <p>For complete server examples, see MCP Server Implementation.</p>"},{"location":"getting-started/#project-structure","title":"Project Structure","text":"<p>When working with AIRS Protocols in your project:</p> <pre><code>my-project/\n\u251c\u2500\u2500 Cargo.toml              # Dependencies\n\u251c\u2500\u2500 src/\n\u2502   \u251c\u2500\u2500 main.rs            # Application entry point\n\u2502   \u2514\u2500\u2500 ...\n\u2514\u2500\u2500 examples/              # Optional examples\n    \u2514\u2500\u2500 ...\n</code></pre>"},{"location":"getting-started/#recommended-project-setup","title":"Recommended Project Setup","text":"<pre><code>[package]\nname = \"my-ai-app\"\nversion = \"0.1.0\"\nedition = \"2021\"\n\n[dependencies]\n# AIRS Protocols\nairsprotocols-mcp = { git = \"https://github.com/airsstack/airsprotocols\" }\n\n# Async runtime\ntokio = { version = \"1.47\", features = [\"full\"] }\n\n# Serialization\nserde = { version = \"1.0\", features = [\"derive\"] }\nserde_json = \"1.0\"\n\n# Error handling\nthiserror = \"1.0\"\n\n# Logging\ntracing = \"0.1\"\ntracing-subscriber = \"0.3\"\n</code></pre>"},{"location":"getting-started/#common-patterns","title":"Common Patterns","text":""},{"location":"getting-started/#error-handling","title":"Error Handling","text":"<p>Use Rust's Result type for error handling:</p> <pre><code>use airsprotocols_mcp::IntegrationError;\n\nasync fn my_function() -&gt; Result&lt;(), IntegrationError&gt; {\n    // Your code here\n    Ok(())\n}\n</code></pre>"},{"location":"getting-started/#asyncawait","title":"Async/Await","text":"<p>All AIRS Protocols APIs are async:</p> <pre><code>#[tokio::main]\nasync fn main() -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {\n    let client = create_client().await?;\n    let result = client.list_tools().await?;\n    Ok(())\n}\n</code></pre>"},{"location":"getting-started/#logging","title":"Logging","text":"<p>Add logging to your application:</p> <pre><code>use tracing::{info, error};\n\n#[tokio::main]\nasync fn main() -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {\n    // Initialize logging\n    tracing_subscriber::fmt::init();\n\n    info!(\"Starting application\");\n\n    // Your code here\n\n    Ok(())\n}\n</code></pre>"},{"location":"getting-started/#next-steps","title":"Next Steps","text":""},{"location":"getting-started/#learn-more-about-mcp","title":"Learn More About MCP","text":"<ul> <li>MCP Quick Start - Detailed MCP tutorial</li> <li>Basic Examples - Common usage patterns</li> <li>Advanced Patterns - Advanced techniques</li> </ul>"},{"location":"getting-started/#explore-the-architecture","title":"Explore the Architecture","text":"<ul> <li>Architecture Overview - System design</li> <li>MCP Architecture - MCP internals</li> </ul>"},{"location":"getting-started/#see-examples","title":"See Examples","text":"<ul> <li>Examples Overview - Runnable examples</li> <li>Claude Integration - Integrate with Claude Desktop</li> </ul>"},{"location":"getting-started/#api-reference","title":"API Reference","text":"<ul> <li>MCP API Reference - Complete API documentation</li> <li>docs.rs - Generated Rust documentation</li> </ul>"},{"location":"getting-started/#development-workflow","title":"Development Workflow","text":""},{"location":"getting-started/#building-your-project","title":"Building Your Project","text":"<pre><code># Build in debug mode\ncargo build\n\n# Build optimized release\ncargo build --release\n\n# Run your application\ncargo run\n\n# Run with logging\nRUST_LOG=info cargo run\n</code></pre>"},{"location":"getting-started/#testing","title":"Testing","text":"<pre><code># Run all tests\ncargo test\n\n# Run specific test\ncargo test test_name\n\n# Run with output\ncargo test -- --nocapture\n</code></pre>"},{"location":"getting-started/#code-quality","title":"Code Quality","text":"<pre><code># Format code\ncargo fmt\n\n# Check for issues\ncargo clippy\n\n# Check without building\ncargo check\n</code></pre>"},{"location":"getting-started/#troubleshooting","title":"Troubleshooting","text":""},{"location":"getting-started/#common-issues","title":"Common Issues","text":""},{"location":"getting-started/#compilation-errors","title":"Compilation Errors","text":"<p>Make sure you're using Rust 1.88 or later:</p> <pre><code>rustup update\n</code></pre>"},{"location":"getting-started/#async-runtime-not-found","title":"Async Runtime Not Found","text":"<p>Ensure tokio is in your dependencies:</p> <pre><code>[dependencies]\ntokio = { version = \"1.47\", features = [\"full\"] }\n</code></pre>"},{"location":"getting-started/#transport-connection-issues","title":"Transport Connection Issues","text":"<p>Check that your transport is properly configured and the server is running.</p>"},{"location":"getting-started/#getting-help","title":"Getting Help","text":"<p>If you encounter issues:</p> <ol> <li>Check the documentation</li> <li>Review examples</li> <li>Search existing issues</li> <li>Ask in GitHub Discussions</li> <li>Open a new issue</li> </ol>"},{"location":"getting-started/#resources","title":"Resources","text":""},{"location":"getting-started/#documentation","title":"Documentation","text":"<ul> <li>MCP Protocol Documentation</li> <li>Architecture Guide</li> <li>API Reference</li> </ul>"},{"location":"getting-started/#external-resources","title":"External Resources","text":"<ul> <li>Model Context Protocol Specification</li> <li>Rust Book</li> <li>Tokio Tutorial</li> </ul>"},{"location":"getting-started/#community","title":"Community","text":"<ul> <li>GitHub Repository</li> <li>Issue Tracker</li> <li>Discussions</li> </ul> <p>Ready to dive deeper? Continue to the MCP Quick Start for a complete tutorial!</p>"},{"location":"overview/","title":"Overview","text":""},{"location":"overview/#introduction","title":"Introduction","text":"<p>AIRS Protocols is a comprehensive Rust workspace that provides production-ready implementations of common AI communication protocols and LLM (Large Language Model) provider APIs. The project is designed to enable seamless integration between AI systems, tools, and external services while maintaining type safety, performance, and interoperability.</p>"},{"location":"overview/#vision","title":"Vision","text":"<p>As AI agents become more sophisticated, the need for standardized communication protocols and unified API interfaces becomes critical. AIRS Protocols aims to be the go-to Rust library for:</p> <ol> <li>Protocol Implementation - Providing robust, spec-compliant implementations of agent communication protocols</li> <li>LLM Integration - Offering unified interfaces for interacting with various LLM providers</li> <li>Interoperability - Ensuring compatibility with official SDKs and other language implementations</li> <li>Production Readiness - Delivering battle-tested code with comprehensive error handling and testing</li> </ol>"},{"location":"overview/#project-goals","title":"Project Goals","text":""},{"location":"overview/#core-objectives","title":"\ud83c\udfaf Core Objectives","text":"<ul> <li>Standards Compliance: Faithfully implement protocol specifications without deviation</li> <li>Type Safety: Leverage Rust's type system to prevent runtime errors at compile time</li> <li>Performance: Optimize for low latency and high throughput in production environments</li> <li>Extensibility: Provide clear extension points for custom implementations</li> <li>Documentation: Maintain comprehensive, up-to-date documentation with examples</li> </ul>"},{"location":"overview/#design-principles","title":"\ud83c\udf1f Design Principles","text":""},{"location":"overview/#1-type-safety-first","title":"1. Type Safety First","text":"<ul> <li>Compile-time verification of protocol messages</li> <li>Strong typing for all API interactions</li> <li>Zero-cost abstractions where possible</li> <li>Explicit error handling with Result types</li> </ul>"},{"location":"overview/#2-protocol-agnostic-architecture","title":"2. Protocol Agnostic Architecture","text":"<ul> <li>Clear separation between protocol logic and transport layer</li> <li>Pluggable transport implementations (stdio, HTTP, WebSocket)</li> <li>Support for multiple protocol bindings</li> <li>Easy to add custom transports</li> </ul>"},{"location":"overview/#3-production-ready","title":"3. Production Ready","text":"<ul> <li>Comprehensive error handling with context</li> <li>Built-in authentication and authorization</li> <li>Extensive test coverage (unit, integration, property-based)</li> <li>Performance benchmarks and profiling</li> <li>Proper logging and observability</li> </ul>"},{"location":"overview/#4-async-native","title":"4. Async Native","text":"<ul> <li>Built on the tokio async runtime</li> <li>Non-blocking I/O throughout</li> <li>Efficient concurrent request handling</li> <li>Streaming support for long-running operations</li> </ul>"},{"location":"overview/#5-interoperability","title":"5. Interoperability","text":"<ul> <li>Compatible with official protocol specifications</li> <li>Works with existing SDKs (Python, TypeScript, etc.)</li> <li>Bridge adapters for protocol translation</li> <li>JSON-RPC compatibility layer</li> </ul>"},{"location":"overview/#workspace-organization","title":"Workspace Organization","text":"<p>AIRS Protocols is organized as a Cargo workspace with two main categories:</p>"},{"location":"overview/#protocols-protocols","title":"Protocols (<code>protocols/</code>)","text":"<p>Communication protocols that enable AI agents to interact with tools, resources, and other agents.</p>"},{"location":"overview/#model-context-protocol-mcp","title":"Model Context Protocol (MCP)","text":"<ul> <li>Status: \u2705 Available (v1.0.0-rc.1)</li> <li>Purpose: Connect AI models to external capabilities</li> <li>Features:</li> <li>JSON-RPC 2.0 foundation</li> <li>Tool, Resource, and Prompt providers</li> <li>Multiple transport implementations</li> <li>Authentication and authorization</li> <li>Comprehensive documentation</li> </ul>"},{"location":"overview/#agent-to-agent-protocol-a2a","title":"Agent-to-Agent Protocol (A2A)","text":"<ul> <li>Status: \ud83d\udea7 Planned</li> <li>Purpose: Enable communication between independent AI agents</li> <li>Features (Planned):</li> <li>Multiple protocol bindings (JSON-RPC, gRPC, REST)</li> <li>Task lifecycle management</li> <li>Streaming support</li> <li>Agent discovery and routing</li> </ul>"},{"location":"overview/#apis-apis","title":"APIs (<code>apis/</code>)","text":"<p>Client implementations for LLM provider APIs with unified interfaces.</p> <p>Coming Soon</p> <p>API client implementations are planned for future releases. The initial focus is on protocol implementations.</p> <p>Planned providers: - Anthropic Claude API - OpenAI GPT API - Google Gemini API - Ollama (local models)</p>"},{"location":"overview/#technology-stack","title":"Technology Stack","text":""},{"location":"overview/#core-dependencies","title":"Core Dependencies","text":"<ul> <li>Runtime: tokio - Async runtime for Rust</li> <li>Serialization: serde - Serialization/deserialization framework</li> <li>HTTP: axum - Ergonomic web framework</li> <li>Error Handling: thiserror - Derive macros for error types</li> </ul>"},{"location":"overview/#development-tools","title":"Development Tools","text":"<ul> <li>Testing: Built-in Rust test framework, proptest for property-based testing</li> <li>Benchmarking: criterion for performance benchmarks</li> <li>Documentation: mdBook and MkDocs Material</li> </ul>"},{"location":"overview/#version-policy","title":"Version Policy","text":"<p>AIRS Protocols follows Semantic Versioning 2.0.0:</p> <ul> <li>Major versions for breaking API changes</li> <li>Minor versions for new features (backward compatible)</li> <li>Patch versions for bug fixes and improvements</li> </ul> <p>Each package in the workspace maintains its own version number, allowing independent evolution while maintaining compatibility.</p>"},{"location":"overview/#current-versions","title":"Current Versions","text":"Package Version Status <code>airsprotocols-mcp</code> 1.0.0-rc.1 Release Candidate <code>airsprotocols-a2a</code> - Planned <code>airsprotocols-anthropic</code> - Planned <code>airsprotocols-openai</code> - Planned"},{"location":"overview/#development-status","title":"Development Status","text":""},{"location":"overview/#phase-1-foundation-complete","title":"\u2705 Phase 1: Foundation (Complete)","text":"<ul> <li> Project structure setup</li> <li> Workspace configuration</li> <li> MCP protocol implementation</li> <li> Documentation infrastructure</li> </ul>"},{"location":"overview/#phase-2-core-protocols-in-progress","title":"\ud83d\udea7 Phase 2: Core Protocols (In Progress)","text":"<ul> <li> Complete MCP documentation</li> <li> CI/CD pipeline</li> <li> A2A protocol implementation</li> <li> MCP \u2194 A2A bridge adapters</li> </ul>"},{"location":"overview/#phase-3-llm-apis-planned","title":"\ud83d\udd2e Phase 3: LLM APIs (Planned)","text":"<ul> <li> Anthropic API client</li> <li> OpenAI API client</li> <li> Unified LLM interface</li> </ul>"},{"location":"overview/#phase-4-ecosystem-future","title":"\ud83d\udd2e Phase 4: Ecosystem (Future)","text":"<ul> <li> Additional LLM providers</li> <li> Performance optimizations</li> <li> Advanced features and extensions</li> </ul>"},{"location":"overview/#use-cases","title":"Use Cases","text":""},{"location":"overview/#1-building-ai-agent-applications","title":"1. Building AI Agent Applications","text":"<p>Use AIRS Protocols to build sophisticated AI agents that can: - Access external tools and APIs - Retrieve and process data from various sources - Collaborate with other agents - Maintain context across conversations</p>"},{"location":"overview/#2-exposing-capabilities-to-llms","title":"2. Exposing Capabilities to LLMs","text":"<p>Create MCP servers that expose your application's capabilities: - File system access (with appropriate security) - Database queries - API integrations - Custom business logic</p>"},{"location":"overview/#3-multi-agent-systems","title":"3. Multi-Agent Systems","text":"<p>Build systems where multiple AI agents collaborate: - Agent-to-agent communication - Task delegation and coordination - Shared resource management - Distributed problem solving</p>"},{"location":"overview/#4-llm-provider-abstraction","title":"4. LLM Provider Abstraction","text":"<p>Write code once and work with multiple LLM providers: - Unified interface across providers - Easy provider switching - Fallback and retry logic - Cost optimization</p>"},{"location":"overview/#community-and-governance","title":"Community and Governance","text":""},{"location":"overview/#open-source-philosophy","title":"Open Source Philosophy","text":"<p>AIRS Protocols is committed to open-source principles: - Transparency: Open development process - Collaboration: Community-driven development - Standards: Following established protocol specifications - Quality: High standards for code and documentation</p>"},{"location":"overview/#protocol-governance","title":"Protocol Governance","text":"<ul> <li>MCP: Anthropic's Model Context Protocol specification</li> <li>A2A/ACP: Linux Foundation governance (merged protocols)</li> <li>Community-driven: Open to contributions and feedback</li> </ul>"},{"location":"overview/#support-and-resources","title":"Support and Resources","text":""},{"location":"overview/#getting-help","title":"Getting Help","text":"<ul> <li>Documentation: Comprehensive guides and API references</li> <li>Issues: GitHub Issues for bugs and feature requests</li> <li>Discussions: GitHub Discussions for questions and ideas</li> </ul>"},{"location":"overview/#external-resources","title":"External Resources","text":"<ul> <li>Model Context Protocol Specification</li> <li>Agent-to-Agent Protocol</li> <li>Rust Documentation</li> </ul>"},{"location":"overview/#next-steps","title":"Next Steps","text":"<p>Ready to get started? Check out these resources:</p> <ul> <li>Getting Started Guide - Quick start tutorial</li> <li>MCP Documentation - Detailed MCP guide</li> <li>Architecture - System design overview</li> <li>Examples - Practical examples</li> <li>Contributing - Join the project</li> </ul> <p>Questions or feedback? Open an issue on GitHub or start a discussion.</p>"},{"location":"apis/","title":"LLM Provider APIs","text":"<p>Planned</p> <p>Status: Future Release</p> <p>LLM provider API implementations are planned for future releases. This page outlines the vision and roadmap for unified LLM client libraries.</p>"},{"location":"apis/#overview","title":"Overview","text":"<p>AIRS Protocols will include production-ready client implementations for major LLM (Large Language Model) providers, offering a unified Rust interface for interacting with different AI services.</p>"},{"location":"apis/#vision","title":"Vision","text":"<p>As developers build AI applications, they often need to:</p> <ul> <li>Switch between different LLM providers based on cost, performance, or features</li> <li>Implement fallback logic when one provider is unavailable</li> <li>Compare outputs across multiple providers</li> <li>Abstract provider-specific details from application logic</li> </ul> <p>AIRS APIs aims to solve these challenges by providing:</p> <ul> <li>Unified Interface: Common API across all providers</li> <li>Type Safety: Rust's type system for compile-time guarantees</li> <li>Async Native: Efficient async/await implementation</li> <li>Error Handling: Comprehensive error types and recovery</li> <li>Production Ready: Battle-tested with extensive testing</li> </ul>"},{"location":"apis/#planned-providers","title":"Planned Providers","text":""},{"location":"apis/#anthropic-claude-api","title":"Anthropic Claude API","text":"<p>Planned</p> <p>Client for Anthropic's Claude language models.</p> <p>Planned Features:</p> <ul> <li>Chat completions API</li> <li>Streaming responses</li> <li>Function calling</li> <li>System prompts and examples</li> <li>Token counting utilities</li> <li>Error handling and retries</li> </ul>"},{"location":"apis/#openai-gpt-api","title":"OpenAI GPT API","text":"<p>Planned</p> <p>Client for OpenAI's GPT models (GPT-4, GPT-3.5, etc.).</p> <p>Planned Features:</p> <ul> <li>Chat completions API</li> <li>Streaming responses</li> <li>Function calling and tools</li> <li>Vision capabilities</li> <li>Audio transcription/generation</li> <li>Fine-tuning support</li> </ul>"},{"location":"apis/#google-gemini-api","title":"Google Gemini API","text":"<p>Planned</p> <p>Client for Google's Gemini models.</p> <p>Planned Features:</p> <ul> <li>Multi-modal input support</li> <li>Streaming responses</li> <li>Function declarations</li> <li>Safety settings</li> <li>Content caching</li> <li>System instructions</li> </ul>"},{"location":"apis/#ollama","title":"Ollama","text":"<p>Planned</p> <p>Client for locally-run models via Ollama.</p> <p>Planned Features:</p> <ul> <li>Local model management</li> <li>Streaming generation</li> <li>Model library integration</li> <li>Performance optimization</li> <li>Custom model support</li> </ul>"},{"location":"apis/#unified-interface-draft","title":"Unified Interface (Draft)","text":"<p>All provider clients will implement a common trait:</p> <pre><code>#[async_trait]\npub trait LlmProvider: Send + Sync {\n    /// Generate a chat completion\n    async fn chat_completion(\n        &amp;self,\n        request: ChatCompletionRequest,\n    ) -&gt; Result&lt;ChatCompletion, LlmError&gt;;\n\n    /// Stream a chat completion\n    async fn chat_completion_stream(\n        &amp;self,\n        request: ChatCompletionRequest,\n    ) -&gt; Result&lt;ChatCompletionStream, LlmError&gt;;\n\n    /// List available models\n    async fn list_models(&amp;self) -&gt; Result&lt;Vec&lt;Model&gt;, LlmError&gt;;\n\n    /// Count tokens for a message\n    async fn count_tokens(&amp;self, messages: &amp;[Message]) -&gt; Result&lt;usize, LlmError&gt;;\n}\n</code></pre>"},{"location":"apis/#common-types","title":"Common Types","text":"<pre><code>pub struct ChatCompletionRequest {\n    pub model: String,\n    pub messages: Vec&lt;Message&gt;,\n    pub temperature: Option&lt;f32&gt;,\n    pub max_tokens: Option&lt;usize&gt;,\n    pub stream: bool,\n    pub tools: Option&lt;Vec&lt;Tool&gt;&gt;,\n}\n\npub struct Message {\n    pub role: Role,\n    pub content: Content,\n    pub name: Option&lt;String&gt;,\n    pub tool_calls: Option&lt;Vec&lt;ToolCall&gt;&gt;,\n}\n\npub enum Role {\n    System,\n    User,\n    Assistant,\n    Tool,\n}\n\npub enum Content {\n    Text(String),\n    MultiModal(Vec&lt;ContentPart&gt;),\n}\n</code></pre>"},{"location":"apis/#example-usage-conceptual","title":"Example Usage (Conceptual)","text":""},{"location":"apis/#basic-chat-completion","title":"Basic Chat Completion","text":"<pre><code>use airsprotocols_anthropic::AnthropicClient;\nuse airsprotocols_common::{LlmProvider, ChatCompletionRequest, Message, Role, Content};\n\n#[tokio::main]\nasync fn main() -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {\n    // Create client\n    let client = AnthropicClient::new(\"api-key\")?;\n\n    // Create request\n    let request = ChatCompletionRequest {\n        model: \"claude-3-opus-20240229\".to_string(),\n        messages: vec![\n            Message {\n                role: Role::User,\n                content: Content::Text(\"Hello, Claude!\".to_string()),\n                name: None,\n                tool_calls: None,\n            }\n        ],\n        temperature: Some(0.7),\n        max_tokens: Some(1000),\n        stream: false,\n        tools: None,\n    };\n\n    // Get completion\n    let completion = client.chat_completion(request).await?;\n    println!(\"Response: {}\", completion.content);\n\n    Ok(())\n}\n</code></pre>"},{"location":"apis/#provider-switching","title":"Provider Switching","text":"<pre><code>// Abstract over providers\nfn create_client(provider: &amp;str) -&gt; Box&lt;dyn LlmProvider&gt; {\n    match provider {\n        \"anthropic\" =&gt; Box::new(AnthropicClient::new(api_key)?),\n        \"openai\" =&gt; Box::new(OpenAiClient::new(api_key)?),\n        \"gemini\" =&gt; Box::new(GeminiClient::new(api_key)?),\n        _ =&gt; panic!(\"Unknown provider\"),\n    }\n}\n\n// Use any provider\nlet client = create_client(\"anthropic\");\nlet completion = client.chat_completion(request).await?;\n</code></pre>"},{"location":"apis/#streaming-responses","title":"Streaming Responses","text":"<pre><code>use tokio_stream::StreamExt;\n\nlet mut stream = client.chat_completion_stream(request).await?;\n\nwhile let Some(chunk) = stream.next().await {\n    match chunk {\n        Ok(delta) =&gt; print!(\"{}\", delta.content),\n        Err(e) =&gt; eprintln!(\"Stream error: {}\", e),\n    }\n}\n</code></pre>"},{"location":"apis/#function-calling","title":"Function Calling","text":"<pre><code>use serde_json::json;\n\nlet request = ChatCompletionRequest {\n    model: \"claude-3-opus\".to_string(),\n    messages: vec![\n        Message::user(\"What's the weather in San Francisco?\")\n    ],\n    tools: Some(vec![\n        Tool {\n            name: \"get_weather\".to_string(),\n            description: \"Get current weather for a location\".to_string(),\n            parameters: json!({\n                \"type\": \"object\",\n                \"properties\": {\n                    \"location\": {\"type\": \"string\"},\n                    \"units\": {\"type\": \"string\", \"enum\": [\"celsius\", \"fahrenheit\"]}\n                },\n                \"required\": [\"location\"]\n            }),\n        }\n    ]),\n    ..Default::default()\n};\n\nlet completion = client.chat_completion(request).await?;\nif let Some(tool_calls) = completion.tool_calls {\n    for call in tool_calls {\n        println!(\"Tool: {}, Args: {}\", call.name, call.arguments);\n    }\n}\n</code></pre>"},{"location":"apis/#architecture-planned","title":"Architecture (Planned)","text":"<pre><code>airsprotocols-common/          # Common types and traits\n\u251c\u2500\u2500 traits.rs                  # LlmProvider trait\n\u251c\u2500\u2500 types.rs                   # Message, Request, Response\n\u2514\u2500\u2500 errors.rs                  # Common error types\n\nairsprotocols-anthropic/       # Anthropic implementation\n\u251c\u2500\u2500 client.rs                  # AnthropicClient\n\u251c\u2500\u2500 types.rs                   # Provider-specific types\n\u2514\u2500\u2500 error.rs                   # Error conversions\n\nairsprotocols-openai/          # OpenAI implementation\nairsprotocols-google/          # Google implementation\nairsprotocols-ollama/          # Ollama implementation\n</code></pre>"},{"location":"apis/#roadmap","title":"Roadmap","text":""},{"location":"apis/#phase-1-foundation-q2-2025","title":"Phase 1: Foundation (Q2 2025)","text":"<ul> <li> Design common trait interface</li> <li> Define common types (Message, Request, Response)</li> <li> Error handling strategy</li> <li> Testing framework</li> </ul>"},{"location":"apis/#phase-2-initial-providers-q3-2025","title":"Phase 2: Initial Providers (Q3 2025)","text":"<ul> <li> Anthropic Claude client</li> <li> OpenAI GPT client</li> <li> Streaming support</li> <li> Basic function calling</li> <li> Documentation</li> </ul>"},{"location":"apis/#phase-3-additional-providers-q4-2025","title":"Phase 3: Additional Providers (Q4 2025)","text":"<ul> <li> Google Gemini client</li> <li> Ollama client</li> <li> Multi-modal support</li> <li> Advanced features</li> <li> Performance optimization</li> </ul>"},{"location":"apis/#phase-4-ecosystem-2026","title":"Phase 4: Ecosystem (2026)","text":"<ul> <li> Provider comparison tools</li> <li> Fallback and retry logic</li> <li> Cost optimization utilities</li> <li> Rate limiting and quotas</li> <li> Caching layer</li> </ul>"},{"location":"apis/#design-principles","title":"Design Principles","text":""},{"location":"apis/#1-provider-agnostic","title":"1. Provider Agnostic","text":"<p>The common interface abstracts provider differences while allowing access to provider-specific features when needed.</p>"},{"location":"apis/#2-type-safe","title":"2. Type Safe","text":"<p>Leverage Rust's type system to prevent common errors:</p> <ul> <li>Compile-time model name validation (where possible)</li> <li>Strong typing for messages and responses</li> <li>Explicit error handling</li> </ul>"},{"location":"apis/#3-async-first","title":"3. Async First","text":"<p>All operations are async for optimal performance:</p> <ul> <li>Non-blocking API calls</li> <li>Efficient streaming</li> <li>Concurrent request handling</li> </ul>"},{"location":"apis/#4-production-ready","title":"4. Production Ready","text":"<p>Built for real-world usage:</p> <ul> <li>Comprehensive error handling</li> <li>Retry logic and backoff</li> <li>Rate limiting</li> <li>Timeout handling</li> <li>Logging and observability</li> </ul>"},{"location":"apis/#5-extensible","title":"5. Extensible","text":"<p>Easy to add new providers and features:</p> <ul> <li>Clear trait boundaries</li> <li>Provider-specific extensions</li> <li>Feature flags for optional capabilities</li> </ul>"},{"location":"apis/#integration-with-protocols","title":"Integration with Protocols","text":""},{"location":"apis/#mcp-integration","title":"MCP Integration","text":"<p>LLM API clients can work seamlessly with MCP:</p> <pre><code>// Use MCP tools with LLM\nlet tools = mcp_client.list_tools().await?;\nlet llm_tools = convert_mcp_to_llm_tools(tools);\n\nlet request = ChatCompletionRequest {\n    tools: Some(llm_tools),\n    ..request\n};\n\nlet completion = llm_client.chat_completion(request).await?;\n</code></pre>"},{"location":"apis/#a2a-integration","title":"A2A Integration","text":"<p>Agents using A2A can leverage LLM APIs:</p> <pre><code>// Agent powered by LLM\nstruct LlmAgent {\n    llm_client: Box&lt;dyn LlmProvider&gt;,\n    a2a_client: A2AClient,\n}\n\nimpl Agent for LlmAgent {\n    async fn handle_task(&amp;self, task: Task) -&gt; Result&lt;TaskResult, Error&gt; {\n        let request = create_llm_request(task);\n        let completion = self.llm_client.chat_completion(request).await?;\n        Ok(TaskResult::from_completion(completion))\n    }\n}\n</code></pre>"},{"location":"apis/#contributing","title":"Contributing","text":"<p>We welcome input on the API design!</p>"},{"location":"apis/#how-to-contribute","title":"How to Contribute","text":"<ol> <li>Design Feedback: Share thoughts in GitHub Discussions</li> <li>Provider Requests: Suggest additional providers to support</li> <li>Feature Ideas: Propose features and improvements</li> <li>Early Testing: Join when beta releases are available</li> </ol>"},{"location":"apis/#areas-of-interest","title":"Areas of Interest","text":"<ul> <li>Common trait interface design</li> <li>Provider-specific feature exposure</li> <li>Error handling strategies</li> <li>Streaming API design</li> <li>Function calling patterns</li> </ul>"},{"location":"apis/#resources","title":"Resources","text":""},{"location":"apis/#external-resources","title":"External Resources","text":"<ul> <li>Anthropic API Documentation</li> <li>OpenAI API Documentation</li> <li>Google Gemini Documentation</li> <li>Ollama Documentation</li> </ul>"},{"location":"apis/#related-documentation","title":"Related Documentation","text":"<ul> <li>AIRS Protocols Overview</li> <li>MCP Documentation</li> <li>Architecture Guide</li> </ul>"},{"location":"apis/#stay-updated","title":"Stay Updated","text":"<p>Follow development progress:</p> <ul> <li>GitHub: Watch the repository for updates</li> <li>Discussions: Join GitHub Discussions</li> <li>Issues: Track API-related issues</li> </ul> <p>Interested in LLM APIs? Star the repository and watch for announcements!</p>"},{"location":"examples/","title":"Examples","text":"<p>Practical examples and tutorials for working with AIRS Protocols.</p>"},{"location":"examples/#mcp-examples","title":"MCP Examples","text":""},{"location":"examples/#getting-started","title":"Getting Started","text":"<ul> <li>Quick Start - Your first MCP client and server</li> <li>Installation - Setup and configuration</li> <li>Basic Examples - Common usage patterns</li> </ul>"},{"location":"examples/#usage-guides","title":"Usage Guides","text":"<ul> <li>Advanced Patterns - Complex scenarios and best practices</li> <li>Claude Integration - Integrate with Claude Desktop</li> <li>Custom Transports - Implement custom transport layers</li> </ul>"},{"location":"examples/#running-examples","title":"Running Examples","text":"<p>The airsprotocols repository includes several runnable examples in the <code>protocols/mcp/examples/</code> directory.</p>"},{"location":"examples/#http-api-key-client-integration","title":"HTTP API Key Client Integration","text":"<p>A complete example showing HTTP transport with API key authentication:</p> <pre><code>cd protocols/mcp/examples/http-apikey-client-integration\ncargo run\n</code></pre> <p>Features demonstrated:</p> <ul> <li>HTTP transport client setup</li> <li>API key authentication</li> <li>Mock server for testing</li> <li>Request/response handling</li> <li>Error handling patterns</li> </ul>"},{"location":"examples/#example-code-snippets","title":"Example Code Snippets","text":""},{"location":"examples/#creating-an-mcp-client","title":"Creating an MCP Client","text":"<pre><code>use airsprotocols_mcp::McpClientBuilder;\nuse std::time::Duration;\n\n#[tokio::main]\nasync fn main() -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {\n    let client = McpClientBuilder::new()\n        .client_info(\"my-app\", \"1.0.0\")\n        .timeout(Duration::from_secs(30))\n        .build(transport)\n        .await?;\n\n    let tools = client.list_tools().await?;\n    println!(\"Found {} tools\", tools.len());\n\n    Ok(())\n}\n</code></pre>"},{"location":"examples/#implementing-a-tool-provider","title":"Implementing a Tool Provider","text":"<pre><code>use async_trait::async_trait;\nuse airsprotocols_mcp::providers::{ToolProvider, ToolCall, ToolResult};\nuse airsprotocols_mcp::IntegrationError;\nuse serde_json::json;\n\nstruct CalculatorProvider;\n\n#[async_trait]\nimpl ToolProvider for CalculatorProvider {\n    async fn call_tool(&amp;self, call: ToolCall) -&gt; Result&lt;ToolResult, IntegrationError&gt; {\n        match call.name.as_str() {\n            \"add\" =&gt; {\n                let params = call.params.unwrap_or_default();\n                let a = params[\"a\"].as_i64().unwrap_or(0);\n                let b = params[\"b\"].as_i64().unwrap_or(0);\n                Ok(ToolResult::success(json!({ \"result\": a + b })))\n            }\n            _ =&gt; Err(IntegrationError::MethodNotFound(call.name))\n        }\n    }\n\n    // Other required methods...\n}\n</code></pre>"},{"location":"examples/#http-server-with-authentication","title":"HTTP Server with Authentication","text":"<pre><code>use airsprotocols_mcp::transport::adapters::http::AxumHttpServer;\nuse std::sync::Arc;\n\n#[tokio::main]\nasync fn main() -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {\n    let server = AxumHttpServer::new_with_empty_handlers(\n        connection_manager,\n        session_manager,\n        jsonrpc_processor,\n        config,\n    ).await?;\n\n    // Add authentication if needed\n    let auth_server = server.with_authentication(auth_adapter, auth_config);\n\n    // Start server\n    auth_server.serve(\"0.0.0.0:3000\").await?;\n\n    Ok(())\n}\n</code></pre>"},{"location":"examples/#community-examples","title":"Community Examples","text":"<p>We encourage the community to share their examples! Here's how:</p>"},{"location":"examples/#sharing-your-example","title":"Sharing Your Example","text":"<ol> <li>Create Your Example: Build something useful with AIRS Protocols</li> <li>Open an Issue: Share your example in a GitHub issue</li> <li>Submit a PR: Add your example to the repository</li> <li>Write a Blog Post: Share your experience on your blog</li> </ol>"},{"location":"examples/#example-ideas","title":"Example Ideas","text":"<ul> <li>Integration with popular AI services</li> <li>Custom transport implementations</li> <li>Authentication strategies</li> <li>Real-world tool providers</li> <li>Performance optimization techniques</li> <li>Testing patterns</li> </ul>"},{"location":"examples/#learning-resources","title":"Learning Resources","text":""},{"location":"examples/#documentation","title":"Documentation","text":"<ul> <li>Getting Started Guide - Quick start tutorial</li> <li>MCP Documentation - Comprehensive MCP guide</li> <li>Architecture - System design overview</li> </ul>"},{"location":"examples/#external-resources","title":"External Resources","text":"<ul> <li>Model Context Protocol Specification</li> <li>Rust Async Book</li> <li>Tokio Tutorial</li> </ul>"},{"location":"examples/#video-tutorials","title":"Video Tutorials","text":"<p>Coming soon! We plan to create video tutorials covering:</p> <ul> <li>Getting started with MCP</li> <li>Building your first tool provider</li> <li>Integrating with Claude Desktop</li> <li>Advanced authentication patterns</li> </ul>"},{"location":"examples/#example-projects","title":"Example Projects","text":""},{"location":"examples/#built-with-airs-protocols","title":"Built with AIRS Protocols","text":"<p>Projects using AIRS Protocols in production or development:</p> <p>Share Your Project</p> <p>Using AIRS Protocols in your project? Let us know in GitHub Discussions!</p>"},{"location":"examples/#troubleshooting-examples","title":"Troubleshooting Examples","text":"<p>Common issues and solutions:</p>"},{"location":"examples/#connection-errors","title":"Connection Errors","text":"<pre><code>// Problem: Connection timeout\n// Solution: Increase timeout duration\n\nlet client = McpClientBuilder::new()\n    .timeout(Duration::from_secs(60))  // Increased from 30\n    .build(transport)\n    .await?;\n</code></pre>"},{"location":"examples/#authentication-failures","title":"Authentication Failures","text":"<pre><code>// Problem: Invalid API key\n// Solution: Verify key and source configuration\n\nlet auth = ApiKeyAuth {\n    key: \"your-valid-key\".to_string(),\n    source: ApiKeySource::AuthorizationBearer,\n};\n</code></pre>"},{"location":"examples/#serialization-errors","title":"Serialization Errors","text":"<pre><code>// Problem: JSON parsing error\n// Solution: Validate JSON structure before sending\n\nlet params = serde_json::from_str(&amp;json_string)?;\nlet result = client.call_tool(ToolCall {\n    name: \"tool_name\".to_string(),\n    params: Some(params),\n}).await?;\n</code></pre>"},{"location":"examples/#testing-examples","title":"Testing Examples","text":""},{"location":"examples/#unit-testing","title":"Unit Testing","text":"<pre><code>#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[tokio::test]\n    async fn test_tool_provider() {\n        let provider = CalculatorProvider;\n        let call = ToolCall {\n            name: \"add\".to_string(),\n            params: Some(json!({\"a\": 2, \"b\": 3})),\n        };\n\n        let result = provider.call_tool(call).await.unwrap();\n        assert_eq!(result.content[\"result\"], 5);\n    }\n}\n</code></pre>"},{"location":"examples/#integration-testing","title":"Integration Testing","text":"<pre><code>#[tokio::test]\nasync fn test_mcp_client() {\n    let transport = create_test_transport().await;\n    let client = McpClientBuilder::new()\n        .build(transport)\n        .await\n        .unwrap();\n\n    let tools = client.list_tools().await.unwrap();\n    assert!(!tools.is_empty());\n}\n</code></pre>"},{"location":"examples/#next-steps","title":"Next Steps","text":"<ul> <li>Try the examples in the repository</li> <li>Build your own MCP server or client</li> <li>Share your work with the community</li> <li>Contribute improvements and new examples</li> </ul> <p>Need help? Ask in GitHub Discussions or check the documentation.</p>"},{"location":"protocols/","title":"Protocols Overview","text":"<p>Communication protocols that enable AI agents to interact with tools, resources, and other agents.</p>"},{"location":"protocols/#available-protocols","title":"Available Protocols","text":""},{"location":"protocols/#model-context-protocol-mcp","title":"Model Context Protocol (MCP)","text":"<p>v1.0.0-rc.1 Status: Available</p> <p>The Model Context Protocol enables AI models to securely access external tools, data sources, and context through a standardized interface.</p> <p>Key Features:</p> <ul> <li>\ud83d\udd27 Tool Calling - Expose functions for AI models to execute</li> <li>\ud83d\udce6 Resource Access - Provide structured access to data and content</li> <li>\ud83d\udcdd Prompt Templates - Supply templates for generating structured prompts</li> <li>\ud83d\udd10 Authentication - API Key and OAuth2 support</li> <li>\ud83d\ude80 Multiple Transports - Stdio and HTTP implementations</li> </ul> <p>\u2192 Go to MCP Documentation</p>"},{"location":"protocols/#agent-to-agent-protocol-a2a","title":"Agent-to-Agent Protocol (A2A)","text":"<p>Planned Status: In Development</p> <p>The Agent-to-Agent Protocol (formerly ACP) enables communication and collaboration between independent AI agents.</p> <p>Planned Features:</p> <ul> <li>\ud83e\udd1d Agent Communication - Standardized messaging between agents</li> <li>\ud83d\udccb Task Management - Task delegation and lifecycle tracking</li> <li>\ud83d\udd04 Multiple Bindings - JSON-RPC, gRPC, and REST support</li> <li>\ud83d\udd0d Discovery - Agent discovery and capability negotiation</li> <li>\ud83d\udcca Streaming - Real-time data streaming between agents</li> </ul> <p>\u2192 View A2A Roadmap</p>"},{"location":"protocols/#protocol-comparison","title":"Protocol Comparison","text":"Feature MCP A2A Purpose Connect AI to tools/resources Agent-to-agent communication Status \u2705 Available \ud83d\udea7 Planned Transport Stdio, HTTP JSON-RPC, gRPC, REST Use Case Tool integration Multi-agent systems Authentication API Key, OAuth2 TBD"},{"location":"protocols/#when-to-use-which-protocol","title":"When to Use Which Protocol","text":""},{"location":"protocols/#use-mcp-when","title":"Use MCP When:","text":"<ul> <li>Connecting AI models to external tools and APIs</li> <li>Providing structured data access to language models</li> <li>Building tool providers for AI applications</li> <li>Integrating with Claude Desktop or similar clients</li> <li>Need stdio or HTTP communication</li> </ul>"},{"location":"protocols/#use-a2a-when","title":"Use A2A When:","text":"<ul> <li>Building multi-agent systems</li> <li>Enabling agent collaboration and coordination</li> <li>Implementing task delegation between agents</li> <li>Creating agent networks and workflows</li> <li>Need distributed agent architectures</li> </ul>"},{"location":"protocols/#getting-started","title":"Getting Started","text":""},{"location":"protocols/#with-mcp","title":"With MCP","text":"<pre><code>[dependencies]\nairsprotocols-mcp = { git = \"https://github.com/airsstack/airsprotocols\" }\n</code></pre> <p>See the MCP Quick Start Guide for detailed instructions.</p>"},{"location":"protocols/#with-a2a","title":"With A2A","text":"<p>Coming soon! A2A is currently in the planning phase.</p>"},{"location":"protocols/#protocol-standards","title":"Protocol Standards","text":"<p>All AIRS protocol implementations follow these principles:</p> <ol> <li>Spec Compliance - Faithful implementation of official specifications</li> <li>Type Safety - Strong typing and compile-time validation</li> <li>Async-First - Built on tokio for efficient async operations</li> <li>Extensibility - Clear extension points for custom implementations</li> <li>Testing - Comprehensive test coverage</li> </ol>"},{"location":"protocols/#resources","title":"Resources","text":""},{"location":"protocols/#mcp-resources","title":"MCP Resources","text":"<ul> <li>Model Context Protocol Specification</li> <li>MCP Documentation</li> <li>MCP Examples</li> </ul>"},{"location":"protocols/#a2a-resources","title":"A2A Resources","text":"<ul> <li>Agent-to-Agent Protocol Specification</li> <li>Linux Foundation Project Page</li> </ul>"},{"location":"protocols/#contributing","title":"Contributing","text":"<p>We welcome contributions to both protocol implementations! See our Contributing Guide for details.</p>"},{"location":"protocols/#current-focus","title":"Current Focus","text":"<ul> <li>\u2705 MCP: Feature complete, accepting enhancements and bug fixes</li> <li>\ud83d\udea7 A2A: Design and planning phase, architecture discussions welcome</li> </ul> <p>Have questions? Open a discussion or check the documentation for each protocol.</p>"},{"location":"protocols/a2a/","title":"Agent-to-Agent Protocol (A2A)","text":"<p>Planned</p> <p>Status: In Development</p> <p>The Agent-to-Agent Protocol implementation is currently in the planning and design phase. This page outlines the planned features and roadmap.</p>"},{"location":"protocols/a2a/#overview","title":"Overview","text":"<p>The Agent-to-Agent Protocol (A2A), formerly known as the Agent Communication Protocol (ACP), is a standardized communication protocol that enables independent AI agents to interact, collaborate, and coordinate with each other.</p> <p>A2A provides a foundation for building multi-agent systems where agents can:</p> <ul> <li>Discover and connect with other agents</li> <li>Exchange messages and data</li> <li>Delegate tasks and coordinate workflows</li> <li>Stream real-time updates</li> <li>Maintain conversation context</li> </ul>"},{"location":"protocols/a2a/#vision","title":"Vision","text":"<p>As AI systems evolve, the need for multiple specialized agents to work together becomes critical. A2A aims to be the standard protocol for agent collaboration, enabling:</p> <ul> <li>Horizontal Scaling: Multiple agents handling different aspects of complex tasks</li> <li>Specialization: Each agent focused on specific domains or capabilities</li> <li>Resilience: Fault-tolerant systems with agent redundancy</li> <li>Interoperability: Agents from different vendors working together</li> </ul>"},{"location":"protocols/a2a/#planned-features","title":"Planned Features","text":""},{"location":"protocols/a2a/#core-protocol","title":"Core Protocol","text":"<ul> <li>Message Passing: Standardized message formats for agent communication</li> <li>Task Management: Task creation, delegation, and lifecycle tracking</li> <li>Capability Discovery: Agents can query and advertise their capabilities</li> <li>Context Management: Maintain conversation and task context across agents</li> <li>Error Handling: Comprehensive error types and recovery mechanisms</li> </ul>"},{"location":"protocols/a2a/#transport-bindings","title":"Transport Bindings","text":"<p>Multiple protocol bindings for different use cases:</p> <ul> <li>JSON-RPC 2.0: Lightweight RPC for simple scenarios</li> <li>gRPC: High-performance binary protocol</li> <li>REST: HTTP-based for web integrations</li> <li>WebSocket: Real-time bidirectional communication</li> </ul>"},{"location":"protocols/a2a/#authentication-authorization","title":"Authentication &amp; Authorization","text":"<ul> <li>Agent Identity: Cryptographic agent identification</li> <li>Trust Models: Configurable trust levels between agents</li> <li>Permission System: Fine-grained authorization for operations</li> <li>Audit Logging: Comprehensive tracking of agent interactions</li> </ul>"},{"location":"protocols/a2a/#advanced-features","title":"Advanced Features","text":"<ul> <li>Streaming: Real-time data streaming between agents</li> <li>Pub/Sub: Event-driven agent coordination</li> <li>Routing: Intelligent message routing in agent networks</li> <li>Load Balancing: Distribute work across agent pools</li> </ul>"},{"location":"protocols/a2a/#architecture-planned","title":"Architecture (Planned)","text":"<pre><code>flowchart TD\n    subgraph \"Agent A\"\n        A_App[\"Application Logic\"]\n        A_A2A[\"A2A Client\"]\n    end\n\n    subgraph \"Agent B\"\n        B_App[\"Application Logic\"]\n        B_A2A[\"A2A Server\"]\n    end\n\n    subgraph \"Agent C\"\n        C_App[\"Application Logic\"]\n        C_A2A[\"A2A Client/Server\"]\n    end\n\n    A_A2A &lt;--&gt;|Task Delegation| B_A2A\n    B_A2A &lt;--&gt;|Collaboration| C_A2A\n    C_A2A &lt;--&gt;|Data Request| A_A2A</code></pre>"},{"location":"protocols/a2a/#use-cases","title":"Use Cases","text":""},{"location":"protocols/a2a/#1-multi-agent-task-decomposition","title":"1. Multi-Agent Task Decomposition","text":"<p>Break complex tasks into subtasks handled by specialized agents:</p> <ul> <li>Research agent gathers information</li> <li>Analysis agent processes data</li> <li>Writing agent generates content</li> <li>Review agent validates output</li> </ul>"},{"location":"protocols/a2a/#2-agent-collaboration","title":"2. Agent Collaboration","text":"<p>Multiple agents working together on shared goals:</p> <ul> <li>Code generation agent creates implementation</li> <li>Testing agent validates functionality</li> <li>Documentation agent writes guides</li> <li>Deployment agent handles release</li> </ul>"},{"location":"protocols/a2a/#3-agent-orchestration","title":"3. Agent Orchestration","text":"<p>Coordinator agent managing a team of worker agents:</p> <ul> <li>Load balancing across agents</li> <li>Task prioritization and scheduling</li> <li>Resource allocation</li> <li>Result aggregation</li> </ul>"},{"location":"protocols/a2a/#4-agent-networks","title":"4. Agent Networks","text":"<p>Distributed networks of agents:</p> <ul> <li>Service mesh of specialized agents</li> <li>Dynamic agent discovery</li> <li>Fault-tolerant communication</li> <li>Scalable architecture</li> </ul>"},{"location":"protocols/a2a/#roadmap","title":"Roadmap","text":""},{"location":"protocols/a2a/#phase-1-specification-design-q1-2025","title":"Phase 1: Specification &amp; Design (Q1 2025)","text":"<ul> <li> Protocol specification review</li> <li> Architecture design</li> <li> API design</li> <li> Security model definition</li> <li> Transport binding selection</li> </ul>"},{"location":"protocols/a2a/#phase-2-core-implementation-q2-2025","title":"Phase 2: Core Implementation (Q2 2025)","text":"<ul> <li> Message types and validation</li> <li> JSON-RPC transport binding</li> <li> Basic client/server implementation</li> <li> Task management system</li> <li> Capability discovery</li> </ul>"},{"location":"protocols/a2a/#phase-3-advanced-features-q3-2025","title":"Phase 3: Advanced Features (Q3 2025)","text":"<ul> <li> gRPC transport binding</li> <li> Authentication system</li> <li> Streaming support</li> <li> Routing and discovery</li> <li> Comprehensive testing</li> </ul>"},{"location":"protocols/a2a/#phase-4-ecosystem-q4-2025","title":"Phase 4: Ecosystem (Q4 2025)","text":"<ul> <li> Documentation and examples</li> <li> Integration with MCP</li> <li> Bridge adapters</li> <li> Performance optimization</li> <li> Production hardening</li> </ul>"},{"location":"protocols/a2a/#technical-specifications-draft","title":"Technical Specifications (Draft)","text":""},{"location":"protocols/a2a/#message-format","title":"Message Format","text":"<pre><code>pub struct A2AMessage {\n    pub id: MessageId,\n    pub from: AgentId,\n    pub to: AgentId,\n    pub message_type: MessageType,\n    pub payload: serde_json::Value,\n    pub timestamp: DateTime&lt;Utc&gt;,\n}\n\npub enum MessageType {\n    TaskRequest,\n    TaskResponse,\n    TaskStatus,\n    DataQuery,\n    DataResponse,\n    CapabilityQuery,\n    CapabilityResponse,\n}\n</code></pre>"},{"location":"protocols/a2a/#agent-interface","title":"Agent Interface","text":"<pre><code>#[async_trait]\npub trait Agent: Send + Sync {\n    async fn handle_task(&amp;self, task: Task) -&gt; Result&lt;TaskResult, Error&gt;;\n    async fn query_data(&amp;self, query: DataQuery) -&gt; Result&lt;DataResponse, Error&gt;;\n    async fn capabilities(&amp;self) -&gt; Vec&lt;Capability&gt;;\n    async fn status(&amp;self) -&gt; AgentStatus;\n}\n</code></pre>"},{"location":"protocols/a2a/#task-lifecycle","title":"Task Lifecycle","text":"<pre><code>pub enum TaskStatus {\n    Pending,\n    Accepted,\n    InProgress,\n    Completed,\n    Failed,\n    Cancelled,\n}\n\npub struct Task {\n    pub id: TaskId,\n    pub description: String,\n    pub parameters: serde_json::Value,\n    pub status: TaskStatus,\n    pub created_at: DateTime&lt;Utc&gt;,\n}\n</code></pre>"},{"location":"protocols/a2a/#integration-with-mcp","title":"Integration with MCP","text":"<p>A2A and MCP are complementary protocols:</p> <ul> <li>MCP: Connect AI models to tools and resources</li> <li>A2A: Enable communication between AI agents</li> </ul> <p>Planned integration:</p> <ul> <li>MCP-to-A2A Bridge: Expose A2A agents as MCP tools</li> <li>A2A-to-MCP Adapter: Allow A2A agents to use MCP servers</li> <li>Unified Client: Single client supporting both protocols</li> </ul>"},{"location":"protocols/a2a/#contributing","title":"Contributing","text":"<p>We're actively seeking community input on the A2A design!</p>"},{"location":"protocols/a2a/#how-to-contribute","title":"How to Contribute","text":"<ol> <li>Design Discussions: Share ideas in GitHub Discussions</li> <li>Specification Review: Comment on the protocol specification</li> <li>Use Case Input: Share your multi-agent use cases</li> <li>Early Testing: Join the early adopter program (coming soon)</li> </ol>"},{"location":"protocols/a2a/#areas-of-interest","title":"Areas of Interest","text":"<ul> <li>Protocol design and message formats</li> <li>Transport binding selection</li> <li>Authentication and security models</li> <li>Agent discovery mechanisms</li> <li>Task management patterns</li> </ul>"},{"location":"protocols/a2a/#resources","title":"Resources","text":""},{"location":"protocols/a2a/#external-resources","title":"External Resources","text":"<ul> <li>Agent-to-Agent Protocol Specification</li> <li>Linux Foundation Project</li> <li>Multi-Agent Systems Research</li> </ul>"},{"location":"protocols/a2a/#related-documentation","title":"Related Documentation","text":"<ul> <li>AIRS Protocols Overview</li> <li>MCP Documentation</li> <li>Architecture Guide</li> </ul>"},{"location":"protocols/a2a/#stay-updated","title":"Stay Updated","text":"<p>Follow development progress:</p> <ul> <li>GitHub: Watch the repository for updates</li> <li>Discussions: Join GitHub Discussions</li> <li>Issues: Track A2A-related issues</li> </ul> <p>Interested in A2A? Star the repository and watch for updates! We'll announce when the implementation begins.</p>"},{"location":"protocols/mcp/","title":"AIRS MCP: Model Context Protocol Implementation","text":""},{"location":"protocols/mcp/#project-description","title":"Project Description","text":"<p>AIRS MCP is a Rust implementation of the Model Context Protocol (MCP) that provides both server and client libraries for integrating AI applications with external systems. The implementation includes type-safe APIs, multiple transport options, and comprehensive protocol compliance.</p>"},{"location":"protocols/mcp/#current-status","title":"Current Status","text":"<p>The implementation is complete and operational with:</p> <ul> <li>Protocol Compliance: Full JSON-RPC 2.0 foundation with MCP extensions</li> <li>Transport Support: STDIO and HTTP transport implementations</li> <li>Authentication: OAuth2 integration with PKCE support  </li> <li>Testing: Comprehensive test suite with integration examples</li> <li>Documentation: Complete API documentation and usage guides</li> </ul>"},{"location":"protocols/mcp/#core-features","title":"Core Features","text":""},{"location":"protocols/mcp/#protocol-implementation","title":"Protocol Implementation","text":"<ul> <li>JSON-RPC 2.0 message types with MCP extensions</li> <li>Bidirectional communication support (client \u2194 server requests)</li> <li>Three-phase connection lifecycle management</li> <li>Capability negotiation between clients and servers</li> <li>Transport abstraction layer</li> </ul>"},{"location":"protocols/mcp/#server-features","title":"Server Features","text":"<ul> <li>Resources: URI-based resource access with subscription support</li> <li>Tools: Function calling with JSON Schema validation</li> <li>Prompts: Template-based prompt management</li> <li>Logging: Comprehensive logging and audit capabilities</li> </ul>"},{"location":"protocols/mcp/#client-features","title":"Client Features","text":"<ul> <li>Connection Management: Automatic server connection handling</li> <li>Request Handling: Type-safe API for all MCP operations</li> <li>Session State: Proper lifecycle and capability tracking</li> <li>Error Handling: Comprehensive error types and recovery</li> </ul>"},{"location":"protocols/mcp/#transport-layer","title":"Transport Layer","text":"<ul> <li>STDIO Transport: Process-based communication for local servers</li> <li>HTTP Transport: RESTful communication with authentication support</li> <li>Custom Transports: Extensible transport interface</li> </ul>"},{"location":"protocols/mcp/#authentication-security","title":"Authentication &amp; Security","text":"<ul> <li>OAuth2 authentication with PKCE support</li> <li>Bearer token authentication for HTTP transport</li> <li>Request validation and error handling</li> <li>Audit logging capabilities</li> </ul>"},{"location":"protocols/mcp/#architecture-overview","title":"Architecture Overview","text":"<p>The implementation is organized in layers:</p> <pre><code>Integration Layer (High-level APIs)\n    \u2193\nProtocol Layer (MCP message types and validation)\n    \u2193  \nTransport Layer (Communication abstractions)\n    \u2193\nJSON-RPC 2.0 Foundation\n</code></pre>"},{"location":"protocols/mcp/#key-components","title":"Key Components","text":"<ul> <li>McpClient: High-level client API for connecting to MCP servers</li> <li>McpServer: Server implementation with provider interfaces</li> <li>TransportClient: Clean request-response interface for communication</li> <li>Message Types: Complete MCP protocol message definitions</li> <li>Provider Traits: Extensible interfaces for server capabilities</li> </ul>"},{"location":"protocols/mcp/#getting-started","title":"Getting Started","text":"<p>Basic client usage:</p> <pre><code>use airsprotocols_mcp::integration::McpClientBuilder;\nuse airsprotocols_mcp::transport::adapters::stdio::StdioTransportClientBuilder;\n\n// Create transport\nlet transport = StdioTransportClientBuilder::new()\n    .command(\"your-mcp-server\")\n    .build()\n    .await?;\n\n// Create client\nlet mut client = McpClientBuilder::new().build(transport);\n\n// Initialize connection\nlet capabilities = client.initialize().await?;\n\n// Use MCP operations\nlet tools = client.list_tools().await?;\n</code></pre> <p>Basic server setup:</p> <pre><code>use airsprotocols_mcp::integration::server::McpServer;\nuse airsprotocols_mcp::transport::adapters::stdio::StdioTransport;\n\n// Create server with providers\nlet server = McpServer::new()\n    .with_resource_provider(resource_provider)\n    .with_tool_provider(tool_provider);\n\n// Start with transport\nlet transport = StdioTransportClientBuilder::new();\nserver.serve(transport).await?;\n</code></pre>"},{"location":"protocols/mcp/#documentation-sections","title":"Documentation Sections","text":"<ul> <li>Installation - Get started with AIRS MCP</li> <li>Quick Start - Your first MCP client and server</li> <li>Usage Guide - Common usage patterns</li> <li>Protocol Reference - Protocol specification details</li> <li>Architecture - Internal design and components</li> <li>API Reference - Rust API documentation</li> <li>Changelog - Version history and updates</li> </ul>"},{"location":"protocols/mcp/api-reference/","title":"API Reference","text":"<p>The complete API reference for AIRS MCP is available on docs.rs.</p>"},{"location":"protocols/mcp/api-reference/#rust-api-documentation","title":"Rust API Documentation","text":"<p>Once published to crates.io, the full API documentation will be available at:</p> <p>https://docs.rs/airsprotocols-mcp</p>"},{"location":"protocols/mcp/api-reference/#building-documentation-locally","title":"Building Documentation Locally","text":"<p>You can also build and view the API documentation locally using cargo:</p> <pre><code># Build and open the API documentation\ncargo doc --package airsprotocols-mcp --open\n\n# Build documentation with all features\ncargo doc --package airsprotocols-mcp --all-features --open\n</code></pre>"},{"location":"protocols/mcp/api-reference/#key-modules","title":"Key Modules","text":""},{"location":"protocols/mcp/api-reference/#integration-layer","title":"Integration Layer","text":"<ul> <li><code>integration::client</code> - High-level MCP client implementation</li> <li><code>integration::server</code> - MCP server framework</li> <li><code>integration::builder</code> - Builder patterns for client and server configuration</li> </ul>"},{"location":"protocols/mcp/api-reference/#protocol-layer","title":"Protocol Layer","text":"<ul> <li><code>protocol::types</code> - MCP message types and protocol definitions</li> <li><code>protocol::jsonrpc</code> - JSON-RPC 2.0 implementation</li> <li><code>protocol::messages</code> - Request and response message types</li> </ul>"},{"location":"protocols/mcp/api-reference/#transport-layer","title":"Transport Layer","text":"<ul> <li><code>transport</code> - Transport abstraction and implementations</li> <li><code>transport::adapters::stdio</code> - STDIO transport for local communication</li> <li><code>transport::adapters::http</code> - HTTP transport for network communication</li> </ul>"},{"location":"protocols/mcp/api-reference/#provider-system","title":"Provider System","text":"<ul> <li><code>providers::tool</code> - Tool provider trait and implementations</li> <li><code>providers::resource</code> - Resource provider trait and implementations</li> <li><code>providers::prompt</code> - Prompt provider trait and implementations</li> </ul>"},{"location":"protocols/mcp/api-reference/#authentication-authorization","title":"Authentication &amp; Authorization","text":"<ul> <li><code>authentication</code> - Authentication strategies and middleware</li> <li><code>authorization</code> - Authorization policies and access control</li> </ul>"},{"location":"protocols/mcp/api-reference/#examples","title":"Examples","text":"<p>The examples directory contains complete working examples demonstrating various use cases:</p> <ul> <li>stdio-server-integration - Local server with STDIO transport</li> <li>http-oauth2-server-integration - HTTP server with OAuth2 authentication</li> <li>basic-client - Simple MCP client example</li> <li>advanced-patterns - Complex usage patterns and integrations</li> </ul>"},{"location":"protocols/mcp/api-reference/#related-documentation","title":"Related Documentation","text":"<ul> <li>Quick Start Guide - Get started quickly</li> <li>Usage Examples - Common usage patterns</li> <li>Architecture Guide - Internal design details</li> </ul>"},{"location":"protocols/mcp/changelog/","title":"Changelog","text":"<p>All notable changes to this project will be documented in this file.</p> <p>The format is based on Keep a Changelog, and this project adheres to Semantic Versioning.</p>"},{"location":"protocols/mcp/changelog/#100-rc1-2025-12-08","title":"[1.0.0-rc.1] - 2025-12-08","text":""},{"location":"protocols/mcp/changelog/#initial-release","title":"\ud83d\ude80 Initial Release","text":"<ul> <li>New Library: Initial release of <code>airsprotocols-mcp</code>, resetting versioning to <code>1.0.0-rc.1</code>.</li> <li>Source: Migrated from the original <code>airsstack/airsstack</code> repository (previously <code>airs-mcp</code> v0.2.3).</li> <li>Goal: To serve as a standalone, stable library for the Model Context Protocol implementation.</li> </ul>"},{"location":"protocols/mcp/changelog/#migration-guide","title":"\ud83d\udd04 Migration Guide","text":"<p>BREAKING CHANGE: Crate renamed and repository moved.</p> <ul> <li>Crate Renamed: <code>airs-mcp</code> \u2192 <code>airsprotocols-mcp</code></li> <li>Repository: https://github.com/airsstack/airsprotocols</li> </ul> <p>Dependency Update: <pre><code># Old\nairs-mcp = \"0.2.3\"\n\n# New\nairsprotocols-mcp = { git = \"https://github.com/airsstack/airsprotocols\" }\n</code></pre></p> <p>Import Update: <pre><code>// Old\nuse airs_mcp::McpClient;\n\n// New\nuse airsprotocols_mcp::McpClient;\n</code></pre> All imports must be updated from <code>airs_mcp</code> to <code>airsprotocols_mcp</code>.</p>"},{"location":"protocols/mcp/installation/","title":"Installation","text":""},{"location":"protocols/mcp/installation/#adding-to-your-project","title":"Adding to Your Project","text":"<p>Add <code>airsprotocols-mcp</code> to your project's <code>Cargo.toml</code>:</p> <pre><code>[dependencies]\n# From git repository:\nairsprotocols-mcp = { git = \"https://github.com/airsstack/airsprotocols\" }\n\n# Or when published to crates.io:\n# airsprotocols-mcp = \"1.0.0-rc.1\"\n</code></pre>"},{"location":"protocols/mcp/installation/#required-dependencies","title":"Required Dependencies","text":"<p>For most use cases, you'll also want to include:</p> <pre><code>[dependencies]\nairsprotocols-mcp = { git = \"https://github.com/airsstack/airsprotocols\" }\ntokio = { version = \"1.35\", features = [\"full\"] }\nserde_json = \"1.0\"\n</code></pre>"},{"location":"protocols/mcp/installation/#building-from-source","title":"Building from Source","text":"<p>To build the library from source:</p> <pre><code># Clone the repository\ngit clone https://github.com/airsstack/airsprotocols\ncd airsprotocols\n\n# Build the MCP protocol implementation\ncargo build --package airsprotocols-mcp\n\n# Run tests\ncargo test --package airsprotocols-mcp\n</code></pre>"},{"location":"protocols/mcp/installation/#documentation-setup","title":"Documentation Setup","text":"<p>This crate includes comprehensive documentation. The source files for the documentation are located in the <code>docs/src</code> directory within this crate.</p>"},{"location":"protocols/mcp/installation/#building-documentation-locally","title":"Building Documentation Locally","text":"<p>To build and view the documentation locally:</p> <pre><code># Navigate to the documentation directory\ncd docs\n\n# Serve the documentation (auto-reloads on changes)\nmkdocs serve\n</code></pre> <p>This will make the documentation available at <code>http://localhost:8000</code>. The server will automatically rebuild the documentation and reload your browser whenever you make changes to the source files.</p>"},{"location":"protocols/mcp/installation/#next-steps","title":"Next Steps","text":"<ul> <li>Quick Start Guide - Get started with your first MCP client</li> <li>Basic Examples - Learn common usage patterns</li> <li>API Reference - Explore the full API documentation</li> </ul>"},{"location":"protocols/mcp/quick-start/","title":"Quick Start Guide","text":"<p>This guide shows how to get started with AIRS MCP using the actual implemented APIs.</p>"},{"location":"protocols/mcp/quick-start/#installation","title":"Installation","text":"<p>Add AIRS MCP to your <code>Cargo.toml</code>:</p> <pre><code>[dependencies]\nairsprotocols-mcp = \"0.1.0\"\ntokio = { version = \"1.35\", features = [\"full\"] }\nserde_json = \"1.0\"\n</code></pre>"},{"location":"protocols/mcp/quick-start/#your-first-mcp-client","title":"Your First MCP Client","text":"<pre><code>use airsprotocols_mcp::integration::{McpClientBuilder, McpResult};\nuse airsprotocols_mcp::transport::adapters::stdio::StdioTransportClientBuilder;\nuse std::time::Duration;\n\n#[tokio::main]\nasync fn main() -&gt; McpResult&lt;()&gt; {\n    // Create STDIO transport client\n    let transport = StdioTransportClientBuilder::new()\n        .command(\"your-mcp-server-command\")\n        .timeout(Duration::from_secs(30))\n        .build()\n        .await?;\n\n    // Create MCP client\n    let mut client = McpClientBuilder::new()\n        .client_info(\"my-client\", \"1.0.0\")\n        .build(transport);\n\n    // Initialize connection with server\n    let capabilities = client.initialize().await?;\n    println!(\"Server capabilities: {:?}\", capabilities);\n\n    // List available tools\n    let tools = client.list_tools().await?;\n    println!(\"Available tools: {:?}\", tools);\n\n    // List available resources\n    let resources = client.list_resources().await?;\n    println!(\"Available resources: {:?}\", resources);\n\n    // List available prompts\n    let prompts = client.list_prompts().await?;\n    println!(\"Available prompts: {:?}\", prompts);\n\n    Ok(())\n}\n</code></pre>"},{"location":"protocols/mcp/quick-start/#your-first-http-mcp-client","title":"Your First HTTP MCP Client","text":"<pre><code>use airsprotocols_mcp::integration::{McpClientBuilder, McpResult};\nuse airsprotocols_mcp::transport::adapters::http::{HttpTransportClientBuilder, AuthMethod};\nuse std::time::Duration;\n\n#[tokio::main]\nasync fn main() -&gt; McpResult&lt;()&gt; {\n    // Create HTTP transport client with authentication\n    let transport = HttpTransportClientBuilder::new()\n        .endpoint(\"http://localhost:3000/mcp\")?\n        .auth(AuthMethod::Bearer {\n            token: \"your-access-token\".to_string(),\n        })\n        .timeout(Duration::from_secs(30))\n        .build()\n        .await?;\n\n    // Create MCP client\n    let mut client = McpClientBuilder::new()\n        .client_info(\"my-http-client\", \"1.0.0\")\n        .build(transport);\n\n    // Initialize and use\n    let capabilities = client.initialize().await?;\n    let tools = client.list_tools().await?;\n\n    println!(\"Connected via HTTP, found {} tools\", tools.len());\n\n    Ok(())\n}\n</code></pre>"},{"location":"protocols/mcp/quick-start/#working-with-tools","title":"Working with Tools","text":"<pre><code>use airsprotocols_mcp::protocol::types::{CallToolRequest, RequestId};\nuse serde_json::json;\n\n// Call a tool (after client initialization)\nlet tool_result = client.call_tool(\"echo\", Some(json!({\"message\": \"Hello, World!\"}))).await?;\n\nprintln!(\"Tool result: {:?}\", tool_result);\n</code></pre>"},{"location":"protocols/mcp/quick-start/#working-with-resources","title":"Working with Resources","text":"<pre><code>// Read a resource (after client initialization)  \nlet resource_content = client.read_resource(\"file:///path/to/file.txt\").await?;\n\nprintln!(\"Resource content: {:?}\", resource_content);\n</code></pre>"},{"location":"protocols/mcp/quick-start/#error-handling","title":"Error Handling","text":"<pre><code>use airsprotocols_mcp::integration::{McpError, McpResult};\n\nasync fn handle_mcp_operations() -&gt; McpResult&lt;()&gt; {\n    // ... create client ...\n\n    match client.initialize().await {\n        Ok(capabilities) =&gt; {\n            println!(\"Successfully connected: {:?}\", capabilities);\n        }\n        Err(McpError::NotConnected) =&gt; {\n            eprintln!(\"Not connected to server\");\n            return Err(McpError::NotConnected);\n        }\n        Err(McpError::Protocol(protocol_err)) =&gt; {\n            eprintln!(\"Protocol error: {}\", protocol_err);\n            return Err(McpError::Protocol(protocol_err));\n        }\n        Err(McpError::Integration(integration_err)) =&gt; {\n            eprintln!(\"Integration error: {}\", integration_err);\n            return Err(McpError::Integration(integration_err));\n        }\n        Err(e) =&gt; {\n            eprintln!(\"Other error: {:?}\", e);\n            return Err(e);\n        }\n    }\n\n    Ok(())\n}\n</code></pre>"},{"location":"protocols/mcp/quick-start/#configuration-options","title":"Configuration Options","text":""},{"location":"protocols/mcp/quick-start/#client-configuration","title":"Client Configuration","text":"<pre><code>use airsprotocols_mcp::protocol::types::{ClientCapabilities, ClientInfo, ProtocolVersion};\nuse std::time::Duration;\n\nlet client = McpClientBuilder::new()\n    .client_info(\"my-app\", \"2.1.0\")\n    .capabilities(ClientCapabilities {\n        experimental: None,\n        sampling: None,\n    })\n    .protocol_version(ProtocolVersion::V2024_11_05)\n    .timeout(Duration::from_secs(60))\n    .build(transport);\n</code></pre>"},{"location":"protocols/mcp/quick-start/#transport-configuration","title":"Transport Configuration","text":"<pre><code>// STDIO Transport\nlet stdio_transport = StdioTransportClientBuilder::new()\n    .command(\"mcp-server\")\n    .arg(\"--config\")\n    .arg(\"config.json\")\n    .timeout(Duration::from_secs(30))\n    .build()\n    .await?;\n\n// HTTP Transport with Bearer token\nlet http_transport = HttpTransportClientBuilder::new()\n    .endpoint(\"https://api.example.com/mcp\")?\n    .auth(AuthMethod::Bearer {\n        token: \"your-access-token\".to_string(),\n    })\n    .timeout(Duration::from_secs(45))\n    .build()\n    .await?;\n</code></pre>"},{"location":"protocols/mcp/quick-start/#next-steps","title":"Next Steps","text":"<ul> <li>See Basic Examples for more detailed usage patterns</li> <li>Check Advanced Patterns for complex scenarios  </li> <li>Read Claude Desktop Integration for desktop integration</li> <li>Explore Custom Transports for implementing new transport layers     server.run_stdio().await?;     Ok(()) } <pre><code>## HTTP Server with Authentication\n\nThe AIRS MCP library supports generic authentication middleware:\n\n```rust\nuse airsprotocols_mcp::transport::adapters::http::axum::AxumHttpServer;\nuse airsprotocols_mcp::transport::adapters::http::auth::middleware::HttpAuthConfig;\nuse airsprotocols_mcp::transport::adapters::http::auth::apikey::ApiKeyStrategyAdapter;\nuse airsprotocols_mcp::authentication::strategies::apikey::{ApiKeyStrategy, InMemoryApiKeyValidator, ApiKeyAuthData};\nuse airsprotocols_mcp::authentication::{AuthMethod, AuthContext};\nuse airsprotocols_mcp::authentication::strategies::apikey::types::ApiKeySource;\nuse airsprotocols_mcp::protocol::jsonrpc::concurrent::{ConcurrentProcessor, ProcessorConfig};\nuse airsprotocols_mcp::transport::adapters::http::config::HttpTransportConfig;\nuse airsprotocols_mcp::transport::adapters::http::connection_manager::HttpConnectionManager;\nuse airsprotocols_mcp::transport::adapters::http::session::SessionManager;\nuse std::collections::HashMap;\nuse std::sync::Arc;\n\n#[tokio::main]\nasync fn main() -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {\n    // Create infrastructure components (simplified - see examples for full setup)\n    let connection_manager = Arc::new(HttpConnectionManager::new(10, Default::default()));\n    let session_manager = Arc::new(SessionManager::new(\n        // ... correlation manager setup\n    ));\n    let jsonrpc_processor = Arc::new(ConcurrentProcessor::new(\n        ProcessorConfig::default()\n    ));\n    let config = HttpTransportConfig::new();\n\n    // Option 1: Server without authentication (default)\n    let server = AxumHttpServer::new_with_empty_handlers(\n        connection_manager.clone(),\n        session_manager.clone(),\n        jsonrpc_processor.clone(),\n        config.clone(),\n    ).await?;\n\n    // Option 2: Server with API key authentication\n    let mut api_keys = HashMap::new();\n    api_keys.insert(\n        \"your-api-key\".to_string(),\n        AuthContext::new(\n            AuthMethod::new(\"apikey\"),\n            ApiKeyAuthData {\n                key_id: \"user_123\".to_string(),\n                source: ApiKeySource::AuthorizationBearer,\n            },\n        ),\n    );\n\n    let validator = InMemoryApiKeyValidator::new(api_keys);\n    let strategy = ApiKeyStrategy::new(validator);\n    let adapter = ApiKeyStrategyAdapter::new(strategy, Default::default());\n    let auth_config = HttpAuthConfig {\n        include_error_details: false,\n        auth_realm: \"MCP API\".to_string(),\n        request_timeout_secs: 30,\n        skip_paths: vec![\"/health\".to_string(), \"/metrics\".to_string()],\n    };\n\n    let auth_server = server.with_authentication(adapter, auth_config);\n\n    // Note: This example shows setup - actual binding/serving requires more infrastructure\n    // See examples/axum_server_with_handlers.rs for complete working example\n\n    Ok(())\n}\n</code></pre></li> </ul> <p>Key Benefits: - Zero Runtime Overhead: No <code>Box&lt;dyn&gt;</code> trait objects or vtable lookups - Compile-Time Optimization: Authentication methods inlined by compiler - Type Safety: Different authentication strategies create different server types - Builder Pattern: Ergonomic <code>.with_authentication()</code> for type conversion - Backward Compatibility: Existing code continues to work unchanged</p>"},{"location":"protocols/mcp/quick-start/#oauth2-mcp-server","title":"OAuth2 MCP Server","text":"<p>OAuth2 authentication with MCP Inspector validation.</p> <pre><code># Quick start with OAuth2 example\ncd examples/mcp-remote-server-oauth2\ncargo run\n\n# Server starts on three ports:\n# - Proxy Server: http://127.0.0.1:3002 (public endpoint)\n# - OAuth2 Endpoints: http://127.0.0.1:3003 (authentication)\n# - MCP Server: http://127.0.0.1:3004 (protocol implementation)\n</code></pre> <p>Test with MCP Inspector: <pre><code>npm install -g @modelcontextprotocol/inspector\nnpx @modelcontextprotocol/inspector\n\n# Configure OAuth2 server:\n# Endpoint: http://127.0.0.1:3002/mcp\n# Authentication: OAuth2\n# Discovery: http://127.0.0.1:3002/.well-known/oauth-authorization-server\n# Client ID: mcp-inspector-client\n</code></pre></p> <p>Features Demonstrated: - Complete OAuth2 flow (authorization code + PKCE + JWT) - MCP Inspector compatibility validation - Three-server architecture with smart proxy routing - Scope-based authorization for MCP operations - Error handling and audit logging</p>"},{"location":"protocols/mcp/quick-start/#next-steps_1","title":"Next Steps","text":"<ul> <li>Basic Examples - Learn common patterns</li> <li>Claude Integration - Connect to Claude Desktop</li> <li>Advanced Patterns - Complex usage patterns</li> </ul>"},{"location":"protocols/mcp/architecture/component-interaction/","title":"Component Interaction Patterns","text":""},{"location":"protocols/mcp/architecture/component-interaction/#capability-negotiation-sequence","title":"Capability Negotiation Sequence","text":"<pre><code>// Capability negotiation orchestration\npub struct CapabilityNegotiator {\n    server_capabilities: ServerCapabilities,\n    client_requirements: ClientRequirements,\n}\n\nimpl CapabilityNegotiator {\n    pub async fn negotiate(\n        &amp;self,\n        transport: &amp;dyn BidirectionalTransport,\n    ) -&gt; Result&lt;NegotiatedCapabilities, NegotiationError&gt; {\n        // 1. Client sends initialize request\n        let init_request = JsonRpcRequest {\n            method: \"initialize\".to_string(),\n            params: InitializeParams {\n                protocol_version: PROTOCOL_VERSION,\n                capabilities: self.client_requirements.to_capabilities(),\n                client_info: self.get_client_info(),\n            },\n            id: RequestId::generate(),\n        };\n\n        // 2. Server responds with capabilities\n        let response = self.send_request(init_request, transport).await?;\n        let server_caps: InitializeResult = response.extract_result()?;\n\n        // 3. Compute intersection of capabilities\n        let negotiated = self.compute_capability_intersection(\n            &amp;self.client_requirements,\n            &amp;server_caps.capabilities,\n        )?;\n\n        // 4. Send initialized notification\n        let initialized = JsonRpcNotification {\n            method: \"notifications/initialized\".to_string(),\n            params: serde_json::Value::Null,\n        };\n        transport.send_message(JsonRpcMessage::from(initialized)).await?;\n\n        Ok(negotiated)\n    }\n}\n</code></pre>"},{"location":"protocols/mcp/architecture/component-interaction/#security-integration-pattern","title":"Security Integration Pattern","text":"<pre><code>// Security concerns integrated at message processing level\npub struct SecureMessageProcessor {\n    base_processor: JsonRpcProcessor,\n    authenticator: Box&lt;dyn Authenticator&gt;,\n    authorizer: Box&lt;dyn Authorizer&gt;,\n    audit_logger: Box&lt;dyn AuditLogger&gt;,\n}\n\nimpl SecureMessageProcessor {\n    pub async fn process_message(\n        &amp;self,\n        message: JsonRpcMessage,\n        security_context: &amp;SecurityContext,\n    ) -&gt; Result&lt;Option&lt;JsonRpcMessage&gt;, ProcessingError&gt; {\n        // 1. Authentication check\n        self.authenticator.verify_message(&amp;message, security_context).await?;\n\n        // 2. Authorization check\n        self.authorizer.check_permission(&amp;message, security_context).await?;\n\n        // 3. Audit logging (pre-execution)\n        self.audit_logger.log_message_received(&amp;message, security_context).await?;\n\n        // 4. Process message\n        let result = self.base_processor.process_message(message, &amp;security_context.into()).await;\n\n        // 5. Audit logging (post-execution)\n        self.audit_logger.log_message_processed(&amp;result, security_context).await?;\n\n        result\n    }\n}\n</code></pre>"},{"location":"protocols/mcp/architecture/component-interaction/#resource-subscription-management","title":"Resource Subscription Management","text":"<pre><code>// Real-time subscription management with cleanup\npub struct SubscriptionManager {\n    subscriptions: DashMap&lt;SubscriptionId, Subscription&gt;,\n    resource_providers: Vec&lt;Box&lt;dyn ResourceProvider&gt;&gt;,\n    notification_sender: mpsc::UnboundedSender&lt;ResourceNotification&gt;,\n}\n\nimpl SubscriptionManager {\n    pub async fn subscribe_to_resource(\n        &amp;self,\n        uri: &amp;str,\n        connection_id: &amp;str,\n    ) -&gt; Result&lt;SubscriptionId, SubscriptionError&gt; {\n        let subscription_id = SubscriptionId::generate();\n        let subscription = Subscription {\n            id: subscription_id.clone(),\n            uri: uri.to_string(),\n            connection_id: connection_id.to_string(),\n            created_at: Utc::now(),\n        };\n\n        // Register subscription\n        self.subscriptions.insert(subscription_id.clone(), subscription);\n\n        // Setup resource watching\n        for provider in &amp;self.resource_providers {\n            if provider.supports_uri(uri) {\n                provider.watch_resource(uri, subscription_id.clone()).await?;\n                break;\n            }\n        }\n\n        Ok(subscription_id)\n    }\n\n    pub async fn handle_resource_change(\n        &amp;self,\n        uri: &amp;str,\n        change: ResourceChange,\n    ) -&gt; Result&lt;(), SubscriptionError&gt; {\n        // Find all subscriptions for this resource\n        let affected_subscriptions: Vec&lt;_&gt; = self.subscriptions\n            .iter()\n            .filter(|entry| entry.value().uri == uri)\n            .map(|entry| entry.key().clone())\n            .collect();\n\n        // Send notifications\n        for subscription_id in affected_subscriptions {\n            let notification = ResourceNotification {\n                subscription_id,\n                uri: uri.to_string(),\n                change: change.clone(),\n            };\n\n            self.notification_sender.send(notification)?;\n        }\n\n        Ok(())\n    }\n}\n</code></pre>"},{"location":"protocols/mcp/architecture/core/","title":"Core Component Design","text":"<p>This document describes the core components of the current AIRS MCP implementation.</p>"},{"location":"protocols/mcp/architecture/core/#architecture-overview","title":"Architecture Overview","text":"<p>The AIRS MCP implementation uses a layered architecture focused on type safety, performance, and clean abstractions:</p> <pre><code>Integration Layer (McpClient/McpServer)\n    \u2193\nProtocol Layer (JSON-RPC 2.0 + MCP messages)\n    \u2193\nTransport Layer (HTTP/STDIO TransportClient)\n    \u2193\nNetwork/Process Communication\n</code></pre>"},{"location":"protocols/mcp/architecture/core/#json-rpc-20-foundation","title":"JSON-RPC 2.0 Foundation","text":"<p>The protocol layer provides complete JSON-RPC 2.0 compliance with MCP extensions:</p> <pre><code>// Core JSON-RPC 2.0 types\n// Located in: src/protocol/jsonrpc/\n\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct JsonRpcRequest {\n    pub jsonrpc: String,\n    pub id: Option&lt;RequestId&gt;,\n    pub method: String,\n    pub params: Option&lt;Value&gt;,\n}\n\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct JsonRpcResponse {\n    pub jsonrpc: String,\n    pub id: Option&lt;RequestId&gt;,\n    #[serde(flatten)]\n    pub payload: ResponsePayload,\n}\n\n#[derive(Debug, Clone, PartialEq, Eq, Hash, Serialize, Deserialize)]\n#[serde(untagged)]\npub enum RequestId {\n    Number(i64),\n    String(String),\n}\n\n#[derive(Debug, Clone, Serialize, Deserialize)]\n#[serde(untagged)]\npub enum ResponsePayload {\n    Success { result: Value },\n    Error { error: JsonRpcError },\n}\n</code></pre>"},{"location":"protocols/mcp/architecture/core/#transport-client-architecture","title":"Transport Client Architecture","text":"<p>The current implementation uses a clean request-response pattern through the <code>TransportClient</code> trait:</p> <pre><code>// Transport abstraction\n// Located in: src/transport/\n\n#[async_trait]\npub trait TransportClient: Send + Sync {\n    type Error: std::error::Error + Send + Sync + 'static;\n\n    async fn call(&amp;self, request: JsonRpcRequest) -&gt; Result&lt;JsonRpcResponse, Self::Error&gt;;\n    async fn close(&amp;self) -&gt; Result&lt;(), Self::Error&gt;;\n}\n</code></pre>"},{"location":"protocols/mcp/architecture/core/#stdio-transport-client","title":"STDIO Transport Client","text":"<pre><code>// STDIO transport implementation\n// Located in: src/transport/adapters/stdio/\n\npub struct StdioTransportClient {\n    // Internal implementation details...\n}\n\nimpl StdioTransportClient {\n    pub async fn new(config: StdioTransportConfig) -&gt; Result&lt;Self, StdioTransportError&gt; {\n        // Create STDIO transport with configured process\n        // Handles process spawning, stdin/stdout management\n    }\n}\n\n#[async_trait]\nimpl TransportClient for StdioTransportClient {\n    type Error = StdioTransportError;\n\n    async fn call(&amp;self, request: JsonRpcRequest) -&gt; Result&lt;JsonRpcResponse, Self::Error&gt; {\n        // Send request via stdin, receive response via stdout\n        // Handles JSON serialization/deserialization\n        // Provides timeout and error handling\n    }\n}\n</code></pre>"},{"location":"protocols/mcp/architecture/core/#http-transport-client","title":"HTTP Transport Client","text":"<pre><code>// HTTP transport implementation\n// Located in: src/transport/adapters/http/\n\npub struct HttpTransportClient {\n    // Internal implementation with HTTP client\n}\n\nimpl HttpTransportClient {\n    pub async fn new(config: HttpTransportConfig) -&gt; Result&lt;Self, HttpTransportError&gt; {\n        // Create HTTP client with authentication\n        // Supports Bearer tokens, API keys, OAuth2\n    }\n}\n\n#[async_trait]\nimpl TransportClient for HttpTransportClient {\n    type Error = HttpTransportError;\n\n    async fn call(&amp;self, request: JsonRpcRequest) -&gt; Result&lt;JsonRpcResponse, Self::Error&gt; {\n        // Send HTTP POST with JSON-RPC request\n        // Handle authentication headers\n        // Parse JSON-RPC response from HTTP response\n    }\n}\n</code></pre>"},{"location":"protocols/mcp/architecture/core/#mcp-client-architecture","title":"MCP Client Architecture","text":"<p>The <code>McpClient</code> provides high-level MCP operations built on the transport layer:</p> <pre><code>// High-level MCP client\n// Located in: src/integration/client.rs\n\npub struct McpClient&lt;T: TransportClient&gt; {\n    transport: T,\n    session_state: McpSessionState,\n    config: McpClientConfig,\n}\n\nimpl&lt;T: TransportClient&gt; McpClient&lt;T&gt; {\n    pub async fn initialize(&amp;mut self) -&gt; McpResult&lt;InitializeResult&gt; {\n        // Send MCP initialize request\n        // Negotiate protocol version and capabilities\n        // Update session state\n    }\n\n    pub async fn list_tools(&amp;self) -&gt; McpResult&lt;ListToolsResult&gt; {\n        // Send tools/list request\n        // Parse and return available tools\n    }\n\n    pub async fn call_tool(&amp;self, request: Value) -&gt; McpResult&lt;CallToolResult&gt; {\n        // Send tools/call request with tool arguments\n        // Handle tool execution response\n    }\n\n    pub async fn list_resources(&amp;self) -&gt; McpResult&lt;ListResourcesResult&gt; {\n        // Send resources/list request\n        // Return available resources\n    }\n\n    pub async fn read_resource(&amp;self, uri: String) -&gt; McpResult&lt;ReadResourceResult&gt; {\n        // Send resources/read request\n        // Return resource content\n    }\n}\n</code></pre>"},{"location":"protocols/mcp/architecture/core/#mcp-server-architecture","title":"MCP Server Architecture","text":"<p>The <code>McpServer</code> handles incoming MCP requests and delegates to providers:</p> <pre><code>// High-level MCP server\n// Located in: src/integration/server.rs\n\npub struct McpServer&lt;T&gt; {\n    providers: ProviderRegistry,\n    server_info: ServerInfo,\n    capabilities: ServerCapabilities,\n    _phantom: PhantomData&lt;T&gt;,\n}\n\nimpl&lt;T&gt; McpServer&lt;T&gt; {\n    pub async fn handle_request(&amp;self, request: JsonRpcRequest) -&gt; JsonRpcResponse {\n        let result = match request.method.as_str() {\n            \"initialize\" =&gt; self.handle_initialize(request.params).await,\n            \"tools/list\" =&gt; self.handle_list_tools().await,\n            \"tools/call\" =&gt; self.handle_call_tool(request.params).await,\n            \"resources/list\" =&gt; self.handle_list_resources().await,\n            \"resources/read\" =&gt; self.handle_read_resource(request.params).await,\n            \"prompts/list\" =&gt; self.handle_list_prompts().await,\n            \"prompts/get\" =&gt; self.handle_get_prompt(request.params).await,\n            _ =&gt; Err(McpError::MethodNotFound(request.method.clone())),\n        };\n\n        // Convert result to JsonRpcResponse\n        self.create_response(request.id, result)\n    }\n}\n</code></pre>"},{"location":"protocols/mcp/architecture/core/#provider-system","title":"Provider System","text":"<p>The provider system allows extending server capabilities:</p> <pre><code>// Provider traits\n// Located in: src/providers/\n\n#[async_trait]\npub trait ResourceProvider: Send + Sync {\n    async fn list_resources(&amp;self) -&gt; Result&lt;Vec&lt;Resource&gt;, ProviderError&gt;;\n    async fn read_resource(&amp;self, uri: &amp;str) -&gt; Result&lt;ResourceContent, ProviderError&gt;;\n}\n\n#[async_trait]\npub trait ToolProvider: Send + Sync {\n    async fn list_tools(&amp;self) -&gt; Result&lt;Vec&lt;Tool&gt;, ProviderError&gt;;\n    async fn call_tool(&amp;self, name: &amp;str, arguments: Value) -&gt; Result&lt;ToolResult, ProviderError&gt;;\n}\n\n#[async_trait]\npub trait PromptProvider: Send + Sync {\n    async fn list_prompts(&amp;self) -&gt; Result&lt;Vec&lt;Prompt&gt;, ProviderError&gt;;\n    async fn get_prompt(&amp;self, name: &amp;str, arguments: Option&lt;Value&gt;) -&gt; Result&lt;GetPromptResult, ProviderError&gt;;\n}\n</code></pre>"},{"location":"protocols/mcp/architecture/core/#builder-pattern","title":"Builder Pattern","text":"<p>The implementation uses builder patterns for clean configuration:</p> <pre><code>// Client builder\nlet transport = StdioTransportClientBuilder::new()\n    .command(\"mcp-server\")\n    .timeout(Duration::from_secs(30))\n    .build()\n    .await?;\n\nlet mut client = McpClientBuilder::new()\n    .client_info(\"my-client\", \"1.0.0\")\n    .timeout(Duration::from_secs(60))\n    .build(transport);\n\n// Server builder  \nlet transport = HttpTransportClientBuilder::new()\n    .endpoint(\"http://localhost:3000/mcp\")?\n    .auth(AuthMethod::Bearer { token: \"token\".to_string() })\n    .build()\n    .await?;\n</code></pre>"},{"location":"protocols/mcp/architecture/core/#architecture-benefits","title":"Architecture Benefits","text":""},{"location":"protocols/mcp/architecture/core/#type-safety","title":"Type Safety","text":"<ul> <li>Compile-time validation: MCP message types validated at compile time</li> <li>Error handling: Comprehensive error types for different failure modes</li> <li>Protocol compliance: Type system enforces MCP specification requirements</li> </ul>"},{"location":"protocols/mcp/architecture/core/#performance","title":"Performance","text":"<ul> <li>Buffer Management: Uses <code>bytes</code> crate for efficient buffer management</li> <li>Async-native: Built on tokio for efficient concurrent operations</li> <li>Minimal allocations: Careful memory management in hot paths</li> </ul>"},{"location":"protocols/mcp/architecture/core/#modularity","title":"Modularity","text":"<ul> <li>Transport abstraction: Clean separation between protocol and transport</li> <li>Provider system: Extensible server capabilities through traits</li> <li>Builder pattern: Ergonomic configuration with sensible defaults</li> </ul> <p>The current architecture eliminates the complexity of correlation management by using a simple request-response pattern through the <code>TransportClient</code> trait, providing better performance and maintainability.</p>"},{"location":"protocols/mcp/architecture/data-flow/","title":"Data Flow Architecture","text":""},{"location":"protocols/mcp/architecture/data-flow/#message-flow-patterns","title":"Message Flow Patterns","text":""},{"location":"protocols/mcp/architecture/data-flow/#client-server-request-flow","title":"Client \u2192 Server Request Flow","text":"<pre><code>\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502   Client    \u2502    \u2502  Transport  \u2502    \u2502  Protocol   \u2502    \u2502   Server    \u2502\n\u2502     API     \u2502    \u2502    Layer    \u2502    \u2502   State     \u2502    \u2502  Handler    \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n       \u2502                   \u2502                   \u2502                   \u2502\n       \u2502 send_request()    \u2502                   \u2502                   \u2502\n       \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25ba\u2502                   \u2502                   \u2502\n       \u2502                   \u2502 validate_phase()  \u2502                   \u2502\n       \u2502                   \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25ba\u2502                   \u2502\n       \u2502                   \u2502                   \u2502 route_message()   \u2502\n       \u2502                   \u2502                   \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25ba\u2502\n       \u2502                   \u2502                   \u2502                   \u2502\n       \u2502                   \u2502                   \u2502 \u25c4\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n       \u2502                   \u2502 \u25c4\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524    response       \u2502\n       \u2502 \u25c4\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524    response       \u2502                   \u2502\n</code></pre>"},{"location":"protocols/mcp/architecture/data-flow/#server-client-request-flow-sampling","title":"Server \u2192 Client Request Flow (Sampling)","text":"<pre><code>\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502   Server    \u2502    \u2502  Protocol   \u2502    \u2502  Transport  \u2502    \u2502   Client    \u2502\n\u2502   Handler   \u2502    \u2502   State     \u2502    \u2502    Layer    \u2502    \u2502  Handler    \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n       \u2502                    \u2502                   \u2502                   \u2502\n       \u2502 request_sampling() \u2502                   \u2502                   \u2502\n       \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25ba \u2502                   \u2502                   \u2502\n       \u2502                    \u2502 validate_capability\u2502                  \u2502\n       \u2502                    \u2502                   \u2502 send_request()    \u2502\n       \u2502                    \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25ba\u2502                   \u2502\n       \u2502                    \u2502                   \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25ba\u2502\n       \u2502                    \u2502                   \u2502                   \u2502\n       \u2502                    \u2502                   \u2502 \u25c4\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n       \u2502                    \u2502 \u25c4\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524   approval_flow   \u2502\n       \u2502 \u25c4\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 \u2524                   \u2502                   \u2502\n</code></pre>"},{"location":"protocols/mcp/architecture/data-flow/#error-propagation-flow","title":"Error Propagation Flow","text":"<pre><code>// Hierarchical error handling with context preservation\n#[derive(Debug, thiserror::Error)]\npub enum McpError {\n    #[error(\"Transport error: {0}\")]\n    Transport(#[from] TransportError),\n\n    #[error(\"Protocol error: {0}\")]\n    Protocol(#[from] ProtocolError),\n\n    #[error(\"Security error: {0}\")]\n    Security(#[from] SecurityError),\n\n    #[error(\"Feature error: {0}\")]\n    Feature(#[from] FeatureError),\n}\n\n// Error context preservation through the stack\nimpl From&lt;ValidationError&gt; for ProtocolError {\n    fn from(err: ValidationError) -&gt; Self {\n        ProtocolError::InvalidMessage {\n            reason: err.to_string(),\n            phase: err.context.phase,\n            method: err.context.method,\n        }\n    }\n}\n</code></pre>"},{"location":"protocols/mcp/protocol/architecture/","title":"Architecture","text":""},{"location":"protocols/mcp/protocol/architecture/#protocol-architecture-patterns","title":"Protocol Architecture Patterns","text":""},{"location":"protocols/mcp/protocol/architecture/#connection-lifecycle-three-phase-state-machine","title":"Connection Lifecycle: Three-Phase State Machine","text":"<pre><code>#[derive(Debug, Clone, PartialEq)]\npub enum ConnectionPhase {\n    Initialization,  // Capability negotiation only\n    Operation,       // Full feature access\n    Shutdown,        // Cleanup and termination\n}\n\npub struct ProtocolConstraints {\n    initialization_methods: HashSet&lt;&amp;'static str&gt;, // \"initialize\", \"ping\"\n    operation_methods: HashSet&lt;&amp;'static str&gt;,      // All methods based on capabilities\n    shutdown_methods: HashSet&lt;&amp;'static str&gt;,       // Limited cleanup methods\n}\n</code></pre> <p>Phase Transition Rules:</p> <pre><code>Initialization \u2192 Operation: After successful \"initialize\" + \"initialized\" exchange\nOperation \u2192 Shutdown: On connection close or explicit shutdown\nNo reverse transitions allowed\n</code></pre>"},{"location":"protocols/mcp/protocol/architecture/#capability-negotiation-system","title":"Capability Negotiation System","text":"<pre><code>#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct ServerCapabilities {\n    // Server feature capabilities\n    pub resources: Option&lt;ResourceCapabilities&gt;,\n    pub tools: Option&lt;ToolCapabilities&gt;, \n    pub prompts: Option&lt;PromptCapabilities&gt;,\n    pub logging: Option&lt;LoggingCapabilities&gt;,\n}\n\n#[derive(Debug, Clone, Serialize, Deserialize)]  \npub struct ClientCapabilities {\n    // Client feature capabilities\n    pub sampling: Option&lt;SamplingCapabilities&gt;,\n    pub roots: Option&lt;RootsCapabilities&gt;,\n}\n\n// Runtime capability validation\nimpl Connection {\n    pub fn can_use_feature(&amp;self, feature: &amp;str) -&gt; bool {\n        self.negotiated_capabilities\n            .as_ref()\n            .map(|caps| caps.supports_feature(feature))\n            .unwrap_or(false)\n    }\n}\n</code></pre>"},{"location":"protocols/mcp/protocol/architecture/#transport-abstraction-layer","title":"Transport Abstraction Layer","text":"<pre><code>#[async_trait]\npub trait BidirectionalTransport: Send + Sync {\n    // Core messaging\n    async fn send_message(&amp;self, message: JsonRpcMessage) -&gt; Result&lt;(), TransportError&gt;;\n    async fn receive_message(&amp;self) -&gt; Result&lt;JsonRpcMessage, TransportError&gt;;\n\n    // Session management  \n    fn session_id(&amp;self) -&gt; Option&lt;&amp;str&gt;;\n    async fn close(&amp;self) -&gt; Result&lt;(), TransportError&gt;;\n\n    // Resumability (HTTP transport)\n    fn last_event_id(&amp;self) -&gt; Option&lt;&amp;str&gt;;\n    async fn resume_from(&amp;self, event_id: &amp;str) -&gt; Result&lt;(), TransportError&gt;;\n}\n</code></pre> <p>Transport Implementations:</p> <ul> <li>STDIO Transport: Process-based communication for local servers</li> <li>Streamable HTTP Transport: HTTP with Server-Sent Events for remote servers</li> <li>Custom Transports: Extensible for future transport mechanisms</li> </ul>"},{"location":"protocols/mcp/protocol/client/","title":"Client Feature Specifications","text":""},{"location":"protocols/mcp/protocol/client/#client-methods","title":"Client Methods","text":"<p>The MCP client provides high-level methods for interacting with MCP servers. All methods return <code>McpResult&lt;T&gt;</code> and automatically handle JSON-RPC protocol details.</p>"},{"location":"protocols/mcp/protocol/client/#initialization","title":"Initialization","text":"<pre><code>/// Initialize the MCP session with the server\n/// Returns server capabilities after successful handshake\npub async fn initialize(&amp;mut self) -&gt; McpResult&lt;InitializeResponse&gt;\n</code></pre>"},{"location":"protocols/mcp/protocol/client/#tool-operations","title":"Tool Operations","text":"<pre><code>/// List available tools from the server\n/// Returns Vec&lt;Tool&gt; containing tool definitions\npub async fn list_tools(&amp;mut self) -&gt; McpResult&lt;Vec&lt;Tool&gt;&gt;\n\n/// Execute a tool with the given arguments\n/// Returns Vec&lt;Content&gt; with the tool execution results\npub async fn call_tool(\n    &amp;mut self,\n    name: impl Into&lt;String&gt;,\n    arguments: Option&lt;Value&gt;,\n) -&gt; McpResult&lt;Vec&lt;Content&gt;&gt;\n</code></pre>"},{"location":"protocols/mcp/protocol/client/#resource-operations","title":"Resource Operations","text":"<pre><code>/// List available resources from the server\n/// Returns Vec&lt;Resource&gt; containing resource metadata\npub async fn list_resources(&amp;mut self) -&gt; McpResult&lt;Vec&lt;Resource&gt;&gt;\n\n/// Read content from a specific resource\n/// Returns Vec&lt;Content&gt; with the resource contents\npub async fn read_resource(\n    &amp;mut self, \n    uri: impl Into&lt;String&gt;\n) -&gt; McpResult&lt;Vec&lt;Content&gt;&gt;\n\n/// Subscribe to changes for a specific resource\npub async fn subscribe_to_resource(\n    &amp;mut self, \n    uri: impl Into&lt;String&gt;\n) -&gt; McpResult&lt;()&gt;\n</code></pre>"},{"location":"protocols/mcp/protocol/client/#prompt-operations","title":"Prompt Operations","text":"<pre><code>/// List available prompts from the server\n/// Returns Vec&lt;Prompt&gt; containing prompt definitions\npub async fn list_prompts(&amp;mut self) -&gt; McpResult&lt;Vec&lt;Prompt&gt;&gt;\n\n/// Get a prompt with the given arguments\n/// Returns Vec&lt;PromptMessage&gt; containing the rendered prompt\npub async fn get_prompt(\n    &amp;mut self,\n    name: impl Into&lt;String&gt;,\n    arguments: HashMap&lt;String, String&gt;,\n) -&gt; McpResult&lt;Vec&lt;PromptMessage&gt;&gt;\n</code></pre>"},{"location":"protocols/mcp/protocol/client/#logging-operations","title":"Logging Operations","text":"<pre><code>/// Set logging configuration\npub async fn set_logging_config(\n    &amp;mut self, \n    config: LoggingConfig\n) -&gt; McpResult&lt;()&gt;\n</code></pre>"},{"location":"protocols/mcp/protocol/client/#utility-operations","title":"Utility Operations","text":"<pre><code>/// Close the MCP session\npub async fn close(&amp;mut self) -&gt; McpResult&lt;()&gt;\n\n/// Check if the client is initialized and ready\npub fn is_ready(&amp;self) -&gt; bool\n\n/// Check if server supports a specific capability\npub fn supports_capability(\n    &amp;self, \n    check: impl Fn(&amp;ServerCapabilities) -&gt; bool\n) -&gt; bool\n</code></pre>"},{"location":"protocols/mcp/protocol/client/#sampling-server-initiated-ai-interactions","title":"Sampling: Server-Initiated AI Interactions","text":"<p>Note: The sampling feature allows servers to request AI model interactions through the client. This feature is part of the MCP specification but implementation details should be verified with the current codebase.</p> <pre><code>#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct SamplingRequest {\n    pub messages: Vec&lt;SamplingMessage&gt;,\n    pub model_preferences: Option&lt;ModelPreferences&gt;,\n    pub system_prompt: Option&lt;String&gt;,\n    pub include_context: Option&lt;ContextInclusion&gt;,\n    pub temperature: Option&lt;f64&gt;,\n    pub max_tokens: Option&lt;u32&gt;,\n    pub stop_sequences: Option&lt;Vec&lt;String&gt;&gt;,\n}\n\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct ModelPreferences {\n    pub hints: Option&lt;ModelHints&gt;,\n    pub cost_priority: Option&lt;f64&gt;,      // 0.0-1.0\n    pub speed_priority: Option&lt;f64&gt;,     // 0.0-1.0  \n    pub intelligence_priority: Option&lt;f64&gt;, // 0.0-1.0\n}\n</code></pre> <p>Double Approval Workflow:</p> <pre><code>// Step 1: Server requests sampling permission\nserver.request_sampling_approval(request).await?;\n\n// Step 2: User approves the AI interaction  \nif user_approves_sampling(request) {\n    let response = client.create_message(request).await?;\n\n    // Step 3: User approves the AI response\n    if user_approves_response(response) {\n        return Ok(response);\n    }\n}\n</code></pre> <p>Context Inclusion Controls:</p> <pre><code>#[derive(Debug, Clone, Serialize, Deserialize)]\npub enum ContextInclusion {\n    None,           // No additional context\n    ThisServer,     // Context from requesting server only\n    AllServers,     // Context from all connected servers\n}\n</code></pre>"},{"location":"protocols/mcp/protocol/security/","title":"Security Model &amp; Trust Boundaries","text":""},{"location":"protocols/mcp/protocol/security/#authentication-architecture","title":"Authentication Architecture","text":"<p>Transport-Specific Authentication:</p> <pre><code>// STDIO Transport: Environment-based credentials\npub struct StdioAuth {\n    environment_vars: HashMap&lt;String, String&gt;,\n    process_isolation: bool,\n}\n\n// HTTP Transport: OAuth 2.1 + PKCE\npub struct HttpAuth {\n    oauth_config: OAuth21Config,\n    pkce_verifier: PkceCodeVerifier,\n    token_storage: SecureTokenStorage,\n}\n</code></pre> <p>OAuth 2.1 + PKCE Implementation:</p> <pre><code>#[derive(Debug, Clone)]\npub struct OAuth21Config {\n    pub authorization_endpoint: Url,\n    pub token_endpoint: Url,\n    pub client_id: String,\n    pub redirect_uri: Url,\n    pub scopes: Vec&lt;String&gt;,\n    pub code_challenge_method: CodeChallengeMethod, // S256 only\n}\n\n#[async_trait]\npub trait OAuth21Authenticator {\n    async fn authenticate(&amp;self, config: OAuth21Config) -&gt; Result&lt;AccessToken, AuthError&gt;;\n    async fn refresh_token(&amp;self, refresh_token: &amp;str) -&gt; Result&lt;AccessToken, AuthError&gt;;\n    async fn revoke_token(&amp;self, token: &amp;str) -&gt; Result&lt;(), AuthError&gt;;\n}\n</code></pre>"},{"location":"protocols/mcp/protocol/security/#authorization-framework","title":"Authorization Framework","text":"<p>Capability-Based Access Control:</p> <pre><code>#[derive(Debug, Clone)]\npub struct PermissionSet {\n    pub can_list_resources: bool,\n    pub can_read_resources: Vec&lt;String&gt;, // URI patterns\n    pub can_execute_tools: Vec&lt;String&gt;,  // Tool names\n    pub can_access_prompts: Vec&lt;String&gt;, // Prompt names\n    pub can_request_sampling: bool,\n}\n\nimpl Connection {\n    pub fn check_permission(&amp;self, operation: &amp;Operation) -&gt; Result&lt;(), AuthError&gt; {\n        match operation {\n            Operation::ReadResource(uri) =&gt; {\n                if self.permissions.can_read_resource(uri) {\n                    Ok(())\n                } else {\n                    Err(AuthError::InsufficientPermissions)\n                }\n            }\n            // ... other permission checks\n        }\n    }\n}\n</code></pre>"},{"location":"protocols/mcp/protocol/security/#audit-compliance-framework","title":"Audit &amp; Compliance Framework","text":"<pre><code>#[derive(Debug, Clone, Serialize)]\npub struct AuditEvent {\n    pub timestamp: DateTime&lt;Utc&gt;,\n    pub connection_id: String,\n    pub operation: String,\n    pub user_id: Option&lt;String&gt;,\n    pub resource_accessed: Option&lt;String&gt;,\n    pub tool_executed: Option&lt;String&gt;,\n    pub approval_required: bool,\n    pub approval_granted: Option&lt;bool&gt;,\n    pub result: AuditResult,\n}\n\n#[async_trait]\npub trait AuditLogger {\n    async fn log_event(&amp;self, event: AuditEvent) -&gt; Result&lt;(), AuditError&gt;;\n    async fn query_events(&amp;self, query: AuditQuery) -&gt; Result&lt;Vec&lt;AuditEvent&gt;, AuditError&gt;;\n}\n</code></pre>"},{"location":"protocols/mcp/protocol/server/","title":"Server Feature Specifications","text":""},{"location":"protocols/mcp/protocol/server/#server-implementation-pattern","title":"Server Implementation Pattern","text":"<p>MCP servers in AIRS use a <code>MessageHandler</code> pattern rather than a direct server builder. The server processes JSON-RPC messages and returns responses.</p>"},{"location":"protocols/mcp/protocol/server/#basic-server-structure","title":"Basic Server Structure","text":"<pre><code>use airsprotocols_mcp::protocol::{MessageHandler, JsonRpcRequest, JsonRpcResponse};\n\nstruct MyMcpServer {\n    // Your server state\n}\n\n#[async_trait]\nimpl MessageHandler for MyMcpServer {\n    async fn handle_message(&amp;mut self, request: JsonRpcRequest) -&gt; Result&lt;JsonRpcResponse, Error&gt; {\n        // Route and handle MCP methods\n        match request.method.as_str() {\n            \"initialize\" =&gt; self.handle_initialize(request).await,\n            \"tools/list\" =&gt; self.handle_list_tools(request).await,\n            \"tools/call\" =&gt; self.handle_call_tool(request).await,\n            \"resources/list\" =&gt; self.handle_list_resources(request).await,\n            \"resources/read\" =&gt; self.handle_read_resource(request).await,\n            \"prompts/list\" =&gt; self.handle_list_prompts(request).await,\n            \"prompts/get\" =&gt; self.handle_get_prompt(request).await,\n            _ =&gt; Err(Error::method_not_found(request.method)),\n        }\n    }\n}\n</code></pre>"},{"location":"protocols/mcp/protocol/server/#resources-uri-addressable-content","title":"Resources: URI-Addressable Content","text":"<pre><code>#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct Resource {\n    pub uri: String,           // Unique identifier (custom schemes allowed)\n    pub name: String,          // Human-readable name\n    pub description: Option&lt;String&gt;,\n    pub mime_type: Option&lt;String&gt;,\n    pub size: Option&lt;u64&gt;,     // Size in bytes\n}\n\n// URI Template support (RFC 6570)\n#[derive(Debug, Clone)]\npub struct ResourceTemplate {\n    pub uri_template: String,  // e.g., \"file://{path}\"\n    pub name: String,\n    pub description: Option&lt;String&gt;,\n}\n</code></pre> <p>Resource Operations:</p> <pre><code>// Core resource methods\n\"resources/list\" \u2192 Vec&lt;Resource&gt;\n\"resources/read\" \u2192 ResourceContent  \n\"resources/templates/list\" \u2192 Vec&lt;ResourceTemplate&gt;\n\n// Subscription support (real-time updates)\n\"resources/subscribe\" \u2192 subscription_id\n\"resources/unsubscribe\" \u2192 confirmation\n// Server sends notifications: \"notifications/resources/updated\"\n</code></pre> <p>Implementation Requirements:</p> <ul> <li>URI Template Engine: RFC 6570 compliance for parameterized resources</li> <li>Subscription Management: Real-time update delivery with proper cleanup</li> <li>Content Handling: Binary (base64) and text content with MIME type support</li> <li>Pagination: Cursor-based pagination for large resource lists</li> </ul>"},{"location":"protocols/mcp/protocol/server/#tools-executable-functions-with-safety-controls","title":"Tools: Executable Functions with Safety Controls","text":"<pre><code>#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct Tool {\n    pub name: String,\n    pub description: String,\n    pub input_schema: serde_json::Value, // JSON Schema\n    pub output_schema: Option&lt;serde_json::Value&gt;,\n}\n\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct ToolCall {\n    pub name: String,\n    pub arguments: serde_json::Value,\n}\n\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct ToolResult {\n    pub content: Vec&lt;Content&gt;,    // Multi-modal results\n    pub is_error: Option&lt;bool&gt;,   // Error indication\n    pub meta: Option&lt;serde_json::Value&gt;, // Additional metadata\n}\n</code></pre> <p>Tool Safety Framework:</p> <pre><code>#[derive(Debug, Clone)]\npub enum SafetyLevel {\n    Safe,        // No approval required\n    Moderate,    // User confirmation required  \n    Dangerous,   // Explicit approval with risk warning\n}\n\n#[async_trait]\npub trait ToolExecutor {\n    async fn execute_tool(\n        &amp;self, \n        call: ToolCall,\n        approval: Option&lt;UserApproval&gt;\n    ) -&gt; Result&lt;ToolResult, ToolError&gt;;\n\n    fn get_safety_level(&amp;self, tool_name: &amp;str) -&gt; SafetyLevel;\n}\n</code></pre> <p>Human-in-the-Loop Approval:</p> <ul> <li>Risk Assessment: Automatic safety level determination</li> <li>Approval Workflow: User approval before dangerous tool execution</li> <li>Audit Trail: Complete logging of tool executions and approvals</li> </ul>"},{"location":"protocols/mcp/protocol/server/#prompts-templated-ai-interactions","title":"Prompts: Templated AI Interactions","text":"<pre><code>#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct Prompt {\n    pub name: String,\n    pub description: String,\n    pub arguments: Option&lt;Vec&lt;PromptArgument&gt;&gt;,\n}\n\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct PromptArgument {\n    pub name: String,\n    pub description: String,\n    pub required: Option&lt;bool&gt;,\n}\n\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct PromptMessage {\n    pub role: MessageRole,  // \"user\", \"assistant\", \"system\"\n    pub content: Content,   // Text or multi-modal content\n}\n</code></pre> <p>Prompt Operations:</p> <pre><code>\"prompts/list\" \u2192 Vec&lt;Prompt&gt;\n\"prompts/get\" \u2192 PromptGetResult { messages: Vec&lt;PromptMessage&gt; }\n\n// Autocompletion support\n\"completion/complete\" \u2192 CompletionResult\n</code></pre> <p>Advanced Features:</p> <ul> <li>Parameter Substitution: Dynamic argument injection into templates</li> <li>Multi-modal Content: Text and image content support</li> <li>Resource Embedding: Direct resource inclusion in prompt context</li> <li>Autocompletion: Intelligent completion for prompt arguments</li> </ul>"},{"location":"protocols/mcp/usage/advanced-patterns/","title":"Patterns","text":"<p>Implementation patterns and usage techniques</p>"},{"location":"protocols/mcp/usage/advanced-patterns/#buffer-pooling-and-performance-optimization","title":"Buffer Pooling and Performance Optimization","text":""},{"location":"protocols/mcp/usage/advanced-patterns/#http-buffer-pool-implementation","title":"HTTP Buffer Pool Implementation","text":"<p>AIRS MCP provides a production-ready HTTP buffer pool that reduces allocation overhead:</p> <pre><code>use airsprotocols_mcp::transport::http::{BufferPool, BufferPoolConfig};\n\n#[tokio::main]\nasync fn main() -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {\n    // Configure HTTP buffer pool\n    let config = BufferPoolConfig::new()\n        .max_buffers(100)              // Pool up to 100 buffers\n        .buffer_size(8 * 1024)         // 8KB buffers\n        .adaptive_sizing(true);        // Enable adaptive sizing\n\n    let pool = BufferPool::new(config);\n\n    // Get buffers with automatic pooling\n    let mut buffer = pool.get_buffer();\n    buffer.extend_from_slice(b\"Hello, World!\");\n\n    // Buffer automatically returns to pool when dropped\n\n    Ok(())\n}\n</code></pre>"},{"location":"protocols/mcp/usage/advanced-patterns/#buffer-pool-metrics-and-monitoring","title":"Buffer Pool Metrics and Monitoring","text":"<pre><code>use airsprotocols_mcp::transport::http::BufferPool;\n\nasync fn monitor_buffer_performance(pool: &amp;BufferPool) {\n    let stats = pool.stats();\n\n    println!(\"HTTP Buffer Pool Performance:\");\n    println!(\"  Available Buffers: {}\", stats.available_buffers);\n    println!(\"  Total Buffers: {}\", stats.total_buffers);\n    println!(\"  Max Buffers: {}\", stats.max_buffers);\n}\n</code></pre>"},{"location":"protocols/mcp/usage/advanced-patterns/#json-rpc-message-patterns","title":"JSON-RPC Message Patterns","text":""},{"location":"protocols/mcp/usage/advanced-patterns/#working-with-different-message-types","title":"Working with Different Message Types","text":"<pre><code>use airsprotocols_mcp::{JsonRpcRequest, JsonRpcResponse, JsonRpcNotification, RequestId, JsonRpcMessageTrait};\nuse serde_json::json;\n\n#[tokio::main]\nasync fn main() -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {\n    // Create different message types\n    let request = JsonRpcRequest::new(\n        \"ping\",\n        Some(json!({\"message\": \"hello\"})),\n        RequestId::new_string(\"req-001\")\n    );\n\n    let response = JsonRpcResponse::success(\n        json!({\"message\": \"pong\"}),\n        RequestId::new_string(\"req-001\")\n    );\n\n    let notification = JsonRpcNotification::new(\n        \"heartbeat\",\n        Some(json!({\"timestamp\": \"2025-09-20T19:00:00Z\"}))\n    );\n\n    // All message types implement the same serialization trait\n    println!(\"Request: {}\", request.to_json()?);\n    println!(\"Response: {}\", response.to_json()?);\n    println!(\"Notification: {}\", notification.to_json()?);\n\n    Ok(())\n}\n</code></pre>"},{"location":"protocols/mcp/usage/advanced-patterns/#request-id-patterns","title":"Request ID Patterns","text":"<pre><code>use airsprotocols_mcp::{JsonRpcRequest, RequestId};\nuse serde_json::json;\n\nfn request_id_examples() -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {\n    // Numeric IDs for simple counting\n    let numeric_request = JsonRpcRequest::new(\n        \"calculate\",\n        Some(json!({\"operation\": \"add\", \"values\": [1, 2, 3]})),\n        RequestId::new_number(42)\n    );\n\n    // String IDs for UUIDs or correlation tracking\n    let string_request = JsonRpcRequest::new(\n        \"fetch_data\",\n        Some(json!({\"table\": \"users\", \"limit\": 10})),\n        RequestId::new_string(\"fetch-users-001\")\n    );\n\n    // Access ID values\n    match numeric_request.id {\n        Some(RequestId::Number(n)) =&gt; println!(\"Numeric ID: {}\", n),\n        Some(RequestId::String(s)) =&gt; println!(\"String ID: {}\", s),\n        None =&gt; println!(\"No ID (notification)\"),\n    }\n\n    Ok(())\n}\n</code></pre>"},{"location":"protocols/mcp/usage/advanced-patterns/#mcp-client-patterns","title":"MCP Client Patterns","text":""},{"location":"protocols/mcp/usage/advanced-patterns/#basic-client-usage","title":"Basic Client Usage","text":"<pre><code>use airsprotocols_mcp::integration::{McpClientBuilder, McpResult};\nuse airsprotocols_mcp::transport::adapters::stdio::StdioTransportClientBuilder;\nuse std::time::Duration;\n\nasync fn basic_client_example() -&gt; McpResult&lt;()&gt; {\n    // Create transport\n    let transport = StdioTransportClientBuilder::new()\n        .command(\"python\")\n        .args(vec![\"-m\".to_string(), \"my_mcp_server\".to_string()])\n        .timeout(Duration::from_secs(30))\n        .build()\n        .await?;\n\n    // Create client\n    let mut client = McpClientBuilder::new()\n        .client_info(\"my-client\", \"1.0.0\")\n        .timeout(Duration::from_secs(60))\n        .build(transport);\n\n    // Initialize connection\n    let capabilities = client.initialize().await?;\n    println!(\"Server capabilities: {:?}\", capabilities);\n\n    // List available tools\n    let tools = client.list_tools().await?;\n    println!(\"Available tools: {}\", tools.tools.len());\n\n    // List available resources\n    let resources = client.list_resources().await?;\n    println!(\"Available resources: {}\", resources.resources.len());\n\n    client.close().await?;\n    Ok(())\n}\n</code></pre>"},{"location":"protocols/mcp/usage/advanced-patterns/#http-client-with-authentication","title":"HTTP Client with Authentication","text":"<pre><code>use airsprotocols_mcp::integration::{McpClientBuilder, McpResult};\nuse airsprotocols_mcp::transport::adapters::http::{HttpTransportClientBuilder, AuthMethod};\nuse std::time::Duration;\n\nasync fn http_client_example() -&gt; McpResult&lt;()&gt; {\n    // Create HTTP transport with Bearer token\n    let transport = HttpTransportClientBuilder::new()\n        .endpoint(\"https://api.example.com/mcp\")?\n        .auth(AuthMethod::Bearer {\n            token: \"your-access-token\".to_string(),\n        })\n        .timeout(Duration::from_secs(30))\n        .build()\n        .await?;\n\n    // Create MCP client\n    let mut client = McpClientBuilder::new()\n        .client_info(\"my-http-client\", \"1.0.0\")\n        .build(transport);\n\n    // Use the client\n    client.initialize().await?;\n    let tools = client.list_tools().await?;\n\n    // Call a specific tool\n    if let Some(tool) = tools.tools.first() {\n        let result = client.call_tool(&amp;tool.name, None).await?;\n        println!(\"Tool result: {:?}\", result);\n    }\n\n    client.close().await?;\n    Ok(())\n}\n</code></pre>"},{"location":"protocols/mcp/usage/advanced-patterns/#error-handling-patterns","title":"Error Handling Patterns","text":""},{"location":"protocols/mcp/usage/advanced-patterns/#comprehensive-error-handling","title":"Comprehensive Error Handling","text":"<pre><code>use airsprotocols_mcp::integration::{McpClient, McpError, McpResult};\nuse airsprotocols_mcp::transport::adapters::stdio::StdioTransportClient;\n\nasync fn error_handling_example(\n    client: &amp;mut McpClient&lt;StdioTransportClient&gt;\n) -&gt; McpResult&lt;()&gt; {\n    match client.call_tool(\"calculator\", Some(serde_json::json!({\"operation\": \"divide\", \"a\": 10, \"b\": 0}))).await {\n        Ok(result) =&gt; {\n            println!(\"Success: {:?}\", result);\n        }\n        Err(McpError::Protocol(protocol_error)) =&gt; {\n            eprintln!(\"Protocol error: {}\", protocol_error);\n        }\n        Err(McpError::Transport(transport_error)) =&gt; {\n            eprintln!(\"Transport error: {}\", transport_error);\n        }\n        Err(McpError::Timeout) =&gt; {\n            eprintln!(\"Request timed out\");\n        }\n        Err(McpError::InvalidState(msg)) =&gt; {\n            eprintln!(\"Invalid state: {}\", msg);\n        }\n        Err(other) =&gt; {\n            eprintln!(\"Other error: {}\", other);\n        }\n    }\n\n    Ok(())\n}\n</code></pre>"},{"location":"protocols/mcp/usage/advanced-patterns/#real-world-integration-patterns","title":"Real-World Integration Patterns","text":""},{"location":"protocols/mcp/usage/advanced-patterns/#multi-tool-workflow","title":"Multi-Tool Workflow","text":"<pre><code>use airsprotocols_mcp::integration::{McpClient, McpResult};\nuse airsprotocols_mcp::transport::adapters::stdio::StdioTransportClient;\nuse serde_json::json;\n\nasync fn multi_tool_workflow(\n    client: &amp;mut McpClient&lt;StdioTransportClient&gt;\n) -&gt; McpResult&lt;()&gt; {\n    // Step 1: Get available tools\n    let tools = client.list_tools().await?;\n    println!(\"Found {} tools\", tools.tools.len());\n\n    // Step 2: Find specific tools\n    let calculator = tools.tools.iter().find(|t| t.name == \"calculator\");\n    let text_processor = tools.tools.iter().find(|t| t.name == \"text_processor\");\n\n    if let Some(calc) = calculator {\n        // Step 3: Perform calculation\n        let calc_result = client.call_tool(\n            &amp;calc.name,\n            Some(json!({\"operation\": \"multiply\", \"a\": 25, \"b\": 4}))\n        ).await?;\n\n        println!(\"Calculation result: {:?}\", calc_result);\n\n        // Step 4: Process the result with text tool\n        if let Some(processor) = text_processor {\n            let text_result = client.call_tool(\n                &amp;processor.name,\n                Some(json!({\n                    \"action\": \"format\",\n                    \"text\": format!(\"The result is: {:?}\", calc_result.content)\n                }))\n            ).await?;\n\n            println!(\"Formatted result: {:?}\", text_result);\n        }\n    }\n\n    Ok(())\n}\n</code></pre>"},{"location":"protocols/mcp/usage/advanced-patterns/#resource-management","title":"Resource Management","text":"<pre><code>use airsprotocols_mcp::integration::{McpClient, McpResult};\nuse airsprotocols_mcp::transport::adapters::stdio::StdioTransportClient;\n\nasync fn resource_management_example(\n    client: &amp;mut McpClient&lt;StdioTransportClient&gt;\n) -&gt; McpResult&lt;()&gt; {\n    // List all available resources\n    let resources = client.list_resources().await?;\n\n    for resource in &amp;resources.resources {\n        println!(\"Resource: {} ({})\", resource.name, resource.uri);\n\n        // Read each resource\n        match client.read_resource(&amp;resource.uri).await {\n            Ok(content) =&gt; {\n                println!(\"  Content type: {:?}\", content.mimeType);\n                if let Some(text) = content.text {\n                    println!(\"  Preview: {}...\", \n                        text.chars().take(100).collect::&lt;String&gt;());\n                }\n            }\n            Err(e) =&gt; {\n                eprintln!(\"  Failed to read: {}\", e);\n            }\n        }\n    }\n\n    Ok(())\n}\n</code></pre>"},{"location":"protocols/mcp/usage/advanced-patterns/#transport-layer-patterns","title":"Transport Layer Patterns","text":""},{"location":"protocols/mcp/usage/advanced-patterns/#custom-configuration","title":"Custom Configuration","text":"<pre><code>use airsprotocols_mcp::transport::adapters::stdio::StdioTransportClientBuilder;\nuse std::time::Duration;\n\nasync fn custom_transport_config() -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {\n    // Custom STDIO configuration\n    let transport = StdioTransportClientBuilder::new()\n        .command(\"python\")\n        .args(vec![\"-m\".to_string(), \"my_server\".to_string()])\n        .timeout(Duration::from_secs(45))\n        .build()\n        .await?;\n\n    // Use the transport...\n    Ok(())\n}\n</code></pre>"},{"location":"protocols/mcp/usage/advanced-patterns/#testing-patterns","title":"Testing Patterns","text":""},{"location":"protocols/mcp/usage/advanced-patterns/#mock-responses-for-testing","title":"Mock Responses for Testing","text":"<pre><code>use airsprotocols_mcp::{JsonRpcResponse, RequestId, JsonRpcMessageTrait};\nuse serde_json::json;\n\nfn create_test_responses() -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {\n    // Create success response\n    let success = JsonRpcResponse::success(\n        json!({\"result\": \"operation completed\", \"data\": [1, 2, 3]}),\n        RequestId::new_number(1)\n    );\n\n    // Create error response\n    let error = JsonRpcResponse::error(\n        json!({\"code\": -32602, \"message\": \"Invalid params\", \"data\": \"Expected number\"}),\n        Some(RequestId::new_number(2))\n    );\n\n    // Serialize for testing\n    let success_json = success.to_json()?;\n    let error_json = error.to_json()?;\n\n    println!(\"Success response: {}\", success_json);\n    println!(\"Error response: {}\", error_json);\n\n    Ok(())\n}\n</code></pre>"},{"location":"protocols/mcp/usage/advanced-patterns/#best-practices","title":"Best Practices","text":""},{"location":"protocols/mcp/usage/advanced-patterns/#session-management","title":"Session Management","text":"<pre><code>use airsprotocols_mcp::integration::{McpClientBuilder, McpSessionState, McpResult, McpError};\nuse airsprotocols_mcp::transport::adapters::stdio::StdioTransportClientBuilder;\nuse std::time::Duration;\n\nasync fn session_management_example() -&gt; McpResult&lt;()&gt; {\n    let transport = StdioTransportClientBuilder::new()\n        .command(\"python\")\n        .args(vec![\"-m\".to_string(), \"my_server\".to_string()])\n        .timeout(Duration::from_secs(30))\n        .build()\n        .await?;\n\n    let mut client = McpClientBuilder::new()\n        .client_info(\"session-client\", \"1.0.0\")\n        .build(transport);\n\n    // Check session state before operations\n    match client.session_state() {\n        McpSessionState::NotInitialized =&gt; {\n            println!(\"Initializing session...\");\n            client.initialize().await?;\n        }\n        McpSessionState::Ready =&gt; {\n            println!(\"Session already initialized\");\n        }\n        McpSessionState::Initializing =&gt; {\n            println!(\"Session is initializing...\");\n            // Wait or handle appropriately\n        }\n        McpSessionState::Failed =&gt; {\n            return Err(McpError::InvalidState(\"Session failed\".to_string()));\n        }\n    }\n\n    // Perform operations...\n    let tools = client.list_tools().await?;\n\n    // Always clean up\n    client.close().await?;\n\n    Ok(())\n}\n</code></pre>"},{"location":"protocols/mcp/usage/basic-examples/","title":"Basic Examples","text":"<p>Examples showing common usage patterns with the actual AIRS MCP implementation.</p>"},{"location":"protocols/mcp/usage/basic-examples/#mcp-client-examples","title":"MCP Client Examples","text":""},{"location":"protocols/mcp/usage/basic-examples/#basic-client-operations","title":"Basic Client Operations","text":"<pre><code>use airsprotocols_mcp::integration::{McpClientBuilder, McpResult};\nuse airsprotocols_mcp::transport::adapters::stdio::StdioTransportClientBuilder;\nuse serde_json::json;\nuse std::time::Duration;\n\n#[tokio::main]\nasync fn main() -&gt; McpResult&lt;()&gt; {\n    // Create STDIO transport\n    let transport = StdioTransportClientBuilder::new()\n        .command(\"your-mcp-server\")\n        .timeout(Duration::from_secs(30))\n        .build()\n        .await?;\n\n    // Create and initialize client\n    let mut client = McpClientBuilder::new()\n        .client_info(\"example-client\", \"1.0.0\")\n        .build(transport);\n\n    let capabilities = client.initialize().await?;\n    println!(\"Server capabilities: {:?}\", capabilities);\n\n    // List available tools\n    let tools_response = client.list_tools().await?;\n    println!(\"Available tools: {:?}\", tools_response.tools);\n\n    // Call a tool if available\n    if let Some(tool) = tools_response.first() {\n        let result = client.call_tool(&amp;tool.name, Some(json!({\"input\": \"test data\"}))).await?;\n        println!(\"Tool result: {:?}\", result);\n    }\n\n    // List and read resources\n    let resources_response = client.list_resources().await?;\n    if let Some(resource) = resources_response.first() {\n        let content = client.read_resource(&amp;resource.uri).await?;\n        println!(\"Resource content: {:?}\", content);\n    }\n\n    // List available prompts\n    let prompts_response = client.list_prompts().await?;\n    println!(\"Available prompts: {:?}\", prompts_response);\n\n    client.close().await?;\n    Ok(())\n}\n</code></pre>"},{"location":"protocols/mcp/usage/basic-examples/#http-client-example","title":"HTTP Client Example","text":"<pre><code>use airsprotocols_mcp::integration::{McpClientBuilder, McpResult};\nuse airsprotocols_mcp::transport::adapters::http::{HttpTransportClientBuilder, AuthMethod};\nuse std::time::Duration;\n\n#[tokio::main]\nasync fn main() -&gt; McpResult&lt;()&gt; {\n    // Create HTTP transport with authentication\n    let transport = HttpTransportClientBuilder::new()\n        .endpoint(\"http://localhost:3000/mcp\")?\n        .auth(AuthMethod::Bearer {\n            token: \"your-access-token\".to_string(),\n        })\n        .timeout(Duration::from_secs(30))\n        .build()\n        .await?;\n\n    // Create client\n    let mut client = McpClientBuilder::new()\n        .client_info(\"http-client\", \"1.0.0\")\n        .build(transport);\n\n    // Initialize and perform operations\n    let _capabilities = client.initialize().await?;\n    let tools = client.list_tools().await?;\n    let resources = client.list_resources().await?;\n    let prompts = client.list_prompts().await?;\n\n    println!(\"Connected via HTTP: {} tools, {} resources, {} prompts\", \n             tools.len(), \n             resources.len(), \n             prompts.len());\n\n    Ok(())\n}\n</code></pre>"},{"location":"protocols/mcp/usage/basic-examples/#error-handling-patterns","title":"Error Handling Patterns","text":"<pre><code>use airsprotocols_mcp::integration::{McpError, McpClientBuilder, McpResult};\n\nasync fn robust_client_handling() -&gt; McpResult&lt;()&gt; {\n    // ... create transport and client ...\n\n    match client.initialize().await {\n        Ok(capabilities) =&gt; {\n            println!(\"Successfully initialized with capabilities: {:?}\", capabilities);\n        }\n        Err(McpError::Integration(integration_error)) =&gt; {\n            eprintln!(\"Integration error: {}\", integration_error);\n            return Err(McpError::Integration(integration_error));\n        }\n        Err(McpError::Protocol(protocol_error)) =&gt; {\n            eprintln!(\"Protocol error: {}\", protocol_error);\n            return Err(McpError::Protocol(protocol_error));\n        }\n        Err(McpError::NotConnected) =&gt; {\n            eprintln!(\"Not connected to server\");\n            return Err(McpError::NotConnected);\n        }\n        Err(e) =&gt; {\n            eprintln!(\"Unexpected error: {:?}\", e);\n            return Err(e);\n        }\n    }\n\n    // Continue with operations...\n    match client.list_tools().await {\n        Ok(response) =&gt; {\n            for tool in &amp;response {\n                println!(\"Tool: {} - {}\", tool.name, \n                         tool.description.as_deref().unwrap_or(\"No description\"));\n            }\n        }\n        Err(e) =&gt; {\n            eprintln!(\"Failed to list tools: {:?}\", e);\n        }\n    }\n\n    Ok(())\n}\n</code></pre>"},{"location":"protocols/mcp/usage/basic-examples/#configuration-examples","title":"Configuration Examples","text":""},{"location":"protocols/mcp/usage/basic-examples/#client-configuration","title":"Client Configuration","text":"<pre><code>use airsprotocols_mcp::integration::McpClientBuilder;\nuse airsprotocols_mcp::protocol::types::{ClientCapabilities, ProtocolVersion};\nuse std::time::Duration;\n\nlet client = McpClientBuilder::new()\n    .client_info(\"my-application\", \"2.1.0\")\n    .capabilities(ClientCapabilities {\n        experimental: None,\n        sampling: None,\n    })\n    .protocol_version(ProtocolVersion::V2024_11_05)\n    .timeout(Duration::from_secs(60))\n    .build(transport);\n</code></pre>"},{"location":"protocols/mcp/usage/basic-examples/#transport-configuration-examples","title":"Transport Configuration Examples","text":"<pre><code>// STDIO with multiple arguments\nlet stdio_transport = StdioTransportClientBuilder::new()\n    .command(\"mcp-server\")\n    .arg(\"--config\")\n    .arg(\"/path/to/config.json\")\n    .arg(\"--verbose\")\n    .timeout(Duration::from_secs(45))\n    .build()\n    .await?;\n\n// HTTP with OAuth2\nlet http_transport = HttpTransportClientBuilder::new()\n    .endpoint(\"https://api.example.com/mcp\")?\n    .auth(AuthMethod::OAuth2 {\n        access_token: \"access_token_here\".to_string(),\n        token_type: Some(\"Bearer\".to_string()),\n    })\n    .timeout(Duration::from_secs(30))\n    .build()\n    .await?;\n\n// HTTP with API key\nlet api_key_transport = HttpTransportClientBuilder::new()\n    .endpoint(\"https://api.example.com/mcp\")?\n    .auth(AuthMethod::ApiKey {\n        key: \"api-key-here\".to_string(),\n        header: \"X-API-Key\".to_string(),\n    })\n    .build()\n    .await?;\n</code></pre>"},{"location":"protocols/mcp/usage/basic-examples/#prompts-and-resources","title":"Prompts and Resources","text":""},{"location":"protocols/mcp/usage/basic-examples/#working-with-prompts","title":"Working with Prompts","text":"<pre><code>use std::collections::HashMap;\n\n// List available prompts\nlet prompts_response = client.list_prompts().await?;\n\nfor prompt in &amp;prompts_response {\n    println!(\"Prompt: {} - {}\", prompt.name, \n             prompt.description.as_deref().unwrap_or(\"No description\"));\n}\n\n// Get a specific prompt\nif let Some(prompt) = prompts_response.first() {\n    let mut args = HashMap::new();\n    args.insert(\"param1\".to_string(), \"value1\".to_string());\n\n    let prompt_messages = client.get_prompt(&amp;prompt.name, args).await?;\n    println!(\"Prompt messages: {:?}\", prompt_messages);\n}\n</code></pre>"},{"location":"protocols/mcp/usage/basic-examples/#working-with-resources","title":"Working with Resources","text":"<pre><code>// List resources\nlet resources_response = client.list_resources().await?;\n\nfor resource in &amp;resources_response {\n    println!(\"Resource: {} ({})\", resource.name, resource.uri);\n    if let Some(description) = &amp;resource.description {\n        println!(\"  Description: {}\", description);\n    }\n}\n\n// Read a specific resource\nif let Some(resource) = resources_response.first() {\n    let content_response = client.read_resource(&amp;resource.uri).await?;\n    println!(\"Resource content: {:?}\", content_response);\n}\n</code></pre>"},{"location":"protocols/mcp/usage/basic-examples/#testing-and-debugging","title":"Testing and Debugging","text":""},{"location":"protocols/mcp/usage/basic-examples/#simple-test-client","title":"Simple Test Client","text":"<pre><code>#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[tokio::test]\n    async fn test_basic_client_operations() -&gt; McpResult&lt;()&gt; {\n        let transport = StdioTransportClientBuilder::new()\n            .command(\"echo-server\")  // Your test server\n            .build()\n            .await?;\n\n        let mut client = McpClientBuilder::new()\n            .client_info(\"test-client\", \"1.0.0\")\n            .build(transport);\n\n        let capabilities = client.initialize().await?;\n        assert!(capabilities.capabilities.tools.is_some() || capabilities.capabilities.resources.is_some());\n\n        let tools = client.list_tools().await?;\n        assert!(!tools.is_empty());\n\n        Ok(())\n    }\n}\n</code></pre>"},{"location":"protocols/mcp/usage/basic-examples/#debug-logging","title":"Debug Logging","text":"<pre><code>use log::{info, debug, error};\n\n// Enable logging in your client code\n#[tokio::main]\nasync fn main() -&gt; McpResult&lt;()&gt; {\n    env_logger::init();\n\n    info!(\"Starting MCP client\");\n\n    let transport = StdioTransportClientBuilder::new()\n        .command(\"your-server\")\n        .build()\n        .await?;\n\n    debug!(\"Transport created successfully\");\n\n    let mut client = McpClientBuilder::new().build(transport);\n\n    match client.initialize().await {\n        Ok(caps) =&gt; info!(\"Client initialized: {:?}\", caps),\n        Err(e) =&gt; {\n            error!(\"Initialization failed: {:?}\", e);\n            return Err(e);\n        }\n    }\n\n    Ok(())\n}\n</code></pre>"},{"location":"protocols/mcp/usage/basic-examples/#error-handling-patterns_1","title":"Error Handling Patterns","text":""},{"location":"protocols/mcp/usage/basic-examples/#comprehensive-error-handling","title":"Comprehensive Error Handling","text":"<pre><code>use airsprotocols_mcp::integration::{McpClientBuilder, McpError};\nuse airsprotocols_mcp::transport::adapters::stdio::StdioTransportClientBuilder;\nuse std::time::Duration;\nuse serde_json::json;\n\nasync fn robust_client_example() -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {\n    let transport = StdioTransportClientBuilder::new()\n        .command(\"mcp-server\")\n        .timeout(Duration::from_secs(30))\n        .build()\n        .await?;\n    let mut client = McpClientBuilder::new()\n        .client_info(\"robust-client\", \"1.0.0\")\n        .build(transport);\n\n    // Initialize first\n    client.initialize().await?;\n\n    // Call a tool with error handling\n    match client.call_tool(\"risky_operation\", Some(json!({\"data\": \"test\"}))).await {\n        Ok(result) =&gt; {\n            println!(\"Success: {:?}\", result);\n        }\n        Err(McpError::Transport(transport_error)) =&gt; {\n            eprintln!(\"Transport error: {}\", transport_error);\n        }\n        Err(McpError::Protocol(protocol_error)) =&gt; {\n            eprintln!(\"Protocol error: {}\", protocol_error);\n        }\n        Err(McpError::Json(json_error)) =&gt; {\n            eprintln!(\"JSON parsing error: {}\", json_error);\n        }\n        Err(McpError::Timeout { timeout_ms }) =&gt; {\n            eprintln!(\"Request timed out after {}ms\", timeout_ms);\n        }\n        Err(McpError::UnexpectedResponse { details }) =&gt; {\n            eprintln!(\"Unexpected response format: {}\", details);\n        }\n        Err(McpError::Shutdown) =&gt; {\n            eprintln!(\"Client has been shutdown\");\n        }\n        Err(e) =&gt; {\n            eprintln!(\"Unexpected error: {}\", e);\n        }\n    }\n\n    Ok(())\n}\n</code></pre>"},{"location":"protocols/mcp/usage/basic-examples/#transport-configuration","title":"Transport Configuration","text":""},{"location":"protocols/mcp/usage/basic-examples/#custom-transport-setup","title":"Custom Transport Setup","text":"<p>Creating your own transport adapter allows you to support different communication protocols while maintaining compatibility with the MCP client interface.</p>"},{"location":"protocols/mcp/usage/basic-examples/#implementing-transportclient-trait","title":"Implementing TransportClient Trait","text":"<pre><code>use airsprotocols_mcp::protocol::{TransportClient, JsonRpcRequest, JsonRpcResponse, TransportError};\nuse async_trait::async_trait;\nuse std::time::Duration;\nuse tokio::time::timeout;\n\n/// Example custom transport that communicates over TCP\npub struct TcpTransportClient {\n    address: String,\n    timeout: Duration,\n    // Add your connection fields here\n}\n\nimpl TcpTransportClient {\n    pub fn new(address: String, timeout: Duration) -&gt; Self {\n        Self {\n            address,\n            timeout,\n        }\n    }\n}\n\n#[async_trait]\nimpl TransportClient for TcpTransportClient {\n    type Error = TransportError;\n\n    async fn call(&amp;mut self, request: JsonRpcRequest) -&gt; Result&lt;JsonRpcResponse, Self::Error&gt; {\n        // 1. Serialize the request\n        let request_json = serde_json::to_string(&amp;request)\n            .map_err(|e| TransportError::Serialization { source: e })?;\n\n        // 2. Send request over your transport (TCP, WebSocket, etc.)\n        // Example: send over TCP connection\n        let response_json = timeout(\n            self.timeout,\n            self.send_and_receive(&amp;request_json)\n        ).await\n        .map_err(|_| TransportError::request_timeout(self.timeout))??;\n\n        // 3. Deserialize the response\n        let response = serde_json::from_str(&amp;response_json)\n            .map_err(|e| TransportError::Serialization { source: e })?;\n\n        Ok(response)\n    }\n\n    fn is_ready(&amp;self) -&gt; bool {\n        // Return true if your transport is ready to send requests\n        true // Implement your readiness check\n    }\n\n    fn transport_type(&amp;self) -&gt; &amp;'static str {\n        \"tcp\"\n    }\n\n    async fn close(&amp;mut self) -&gt; Result&lt;(), Self::Error&gt; {\n        // Clean up your transport resources\n        Ok(())\n    }\n}\n\nimpl TcpTransportClient {\n    async fn send_and_receive(&amp;mut self, request: &amp;str) -&gt; Result&lt;String, TransportError&gt; {\n        // Implement your actual transport logic here\n        // This is where you'd:\n        // 1. Connect to your server\n        // 2. Send the JSON-RPC request\n        // 3. Receive the JSON-RPC response\n        // 4. Return the response string\n\n        // Example placeholder:\n        todo!(\"Implement your transport protocol here\")\n    }\n}\n</code></pre>"},{"location":"protocols/mcp/usage/basic-examples/#transport-builder-pattern","title":"Transport Builder Pattern","text":"<pre><code>use std::time::Duration;\n\n/// Builder for creating TCP transport clients\npub struct TcpTransportClientBuilder {\n    address: Option&lt;String&gt;,\n    timeout: Duration,\n    // Add other configuration fields\n}\n\nimpl TcpTransportClientBuilder {\n    pub fn new() -&gt; Self {\n        Self {\n            address: None,\n            timeout: Duration::from_secs(30),\n        }\n    }\n\n    pub fn address(mut self, address: impl Into&lt;String&gt;) -&gt; Self {\n        self.address = Some(address.into());\n        self\n    }\n\n    pub fn timeout(mut self, timeout: Duration) -&gt; Self {\n        self.timeout = timeout;\n        self\n    }\n\n    pub async fn build(self) -&gt; Result&lt;TcpTransportClient, TransportError&gt; {\n        let address = self.address.ok_or_else(|| {\n            TransportError::invalid_request(\"Address is required\".to_string())\n        })?;\n\n        Ok(TcpTransportClient::new(address, self.timeout))\n    }\n}\n</code></pre>"},{"location":"protocols/mcp/usage/basic-examples/#using-your-custom-transport","title":"Using Your Custom Transport","text":"<pre><code>use airsprotocols_mcp::integration::{McpClientBuilder, McpResult};\n\nasync fn use_custom_transport() -&gt; McpResult&lt;()&gt; {\n    // Create your custom transport\n    let transport = TcpTransportClientBuilder::new()\n        .address(\"tcp://localhost:8080\")\n        .timeout(Duration::from_secs(60))\n        .build()\n        .await?;\n\n    // Use it with the MCP client\n    let mut client = McpClientBuilder::new()\n        .client_info(\"tcp-client\", \"1.0.0\")\n        .build(transport);\n\n    // Now you can use the client normally\n    client.initialize().await?;\n    let tools = client.list_tools().await?;\n\n    println!(\"Tools available: {:?}\", tools);\n    Ok(())\n}\n</code></pre>"},{"location":"protocols/mcp/usage/basic-examples/#websocket-transport-example","title":"WebSocket Transport Example","text":"<pre><code>// Example of a WebSocket transport implementation\npub struct WebSocketTransportClient {\n    url: String,\n    // Add WebSocket connection fields\n}\n\n#[async_trait]\nimpl TransportClient for WebSocketTransportClient {\n    type Error = TransportError;\n\n    async fn call(&amp;mut self, request: JsonRpcRequest) -&gt; Result&lt;JsonRpcResponse, Self::Error&gt; {\n        // Implementation would use a WebSocket library like tokio-tungstenite\n        // to send JSON-RPC requests and receive responses\n        todo!(\"Implement WebSocket transport\")\n    }\n\n    fn is_ready(&amp;self) -&gt; bool {\n        // Check if WebSocket connection is open\n        true\n    }\n\n    fn transport_type(&amp;self) -&gt; &amp;'static str {\n        \"websocket\"\n    }\n\n    async fn close(&amp;mut self) -&gt; Result&lt;(), Self::Error&gt; {\n        // Close WebSocket connection\n        Ok(())\n    }\n}\n</code></pre>"},{"location":"protocols/mcp/usage/basic-examples/#connection-management","title":"Connection Management","text":"<pre><code>use tokio::time::{timeout, Duration};\nuse airsprotocols_mcp::integration::{McpClientBuilder, McpResult};\nuse airsprotocols_mcp::transport::adapters::stdio::StdioTransportClientBuilder;\n\n// Graceful connection handling\nasync fn managed_connection() -&gt; McpResult&lt;()&gt; {\n    let transport = StdioTransportClientBuilder::new()\n        .command(\"your-server\")\n        .build()\n        .await?;\n\n    let mut client = McpClientBuilder::new()\n        .client_info(\"managed-client\", \"1.0.0\")\n        .build(transport);\n\n    // Initialize the client\n    client.initialize().await?;\n\n    // Set reasonable timeout for operations\n    let result = timeout(\n        Duration::from_secs(10),\n        client.list_tools()\n    ).await??;\n\n    println!(\"Available tools: {:?}\", result);\n\n    // Always clean up\n    client.close().await?;\n    Ok(())\n}\n</code></pre>"},{"location":"protocols/mcp/usage/claude-integration/","title":"Claude Desktop Integration","text":"<p>This guide covers integration of AIRS MCP servers with Claude Desktop.</p>"},{"location":"protocols/mcp/usage/claude-integration/#overview","title":"Overview","text":"<p>AIRS MCP provides Claude Desktop integration through MCP protocol compliance. The integration supports both STDIO and HTTP transport methods for connecting to Claude Desktop applications.</p>"},{"location":"protocols/mcp/usage/claude-integration/#integration-methods","title":"Integration Methods","text":""},{"location":"protocols/mcp/usage/claude-integration/#stdio-integration","title":"STDIO Integration","text":"<p>The most common integration method uses STDIO transport for local server communication:</p> <ol> <li>Build your MCP server</li> <li>Configure Claude Desktop</li> <li>Test the connection</li> </ol>"},{"location":"protocols/mcp/usage/claude-integration/#configuration-setup","title":"Configuration Setup","text":"<p>Claude Desktop requires configuration in its settings file. The typical location varies by platform:</p> <ul> <li>macOS: <code>~/Library/Application Support/Claude/claude_desktop_config.json</code></li> <li>Windows: <code>%APPDATA%\\Claude\\claude_desktop_config.json</code></li> <li>Linux: <code>~/.config/Claude/claude_desktop_config.json</code></li> </ul>"},{"location":"protocols/mcp/usage/claude-integration/#example-configuration","title":"Example Configuration","text":"<pre><code>{\n  \"mcpServers\": {\n    \"airsprotocols-mcp-server\": {\n      \"command\": \"/path/to/your/mcp-server\",\n      \"args\": [],\n      \"env\": {}\n    }\n  }\n}\n</code></pre>"},{"location":"protocols/mcp/usage/claude-integration/#server-implementation","title":"Server Implementation","text":"<p>Basic MCP server for Claude Desktop:</p> <pre><code>use airsprotocols_mcp::integration::server::McpServer;\nuse airsprotocols_mcp::transport::adapters::stdio::StdioTransport;\n\n#[tokio::main]\nasync fn main() -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {\n    let server = McpServer::new()\n        .with_resource_provider(your_resource_provider)\n        .with_tool_provider(your_tool_provider);\n\n    let transport = StdioTransportClientBuilder::new();\n    server.serve(transport).await?;\n\n    Ok(())\n}\n</code></pre>"},{"location":"protocols/mcp/usage/claude-integration/#testing-integration","title":"Testing Integration","text":""},{"location":"protocols/mcp/usage/claude-integration/#basic-connection-test","title":"Basic Connection Test","text":"<ol> <li>Start your MCP server manually to verify it works</li> <li>Check Claude Desktop logs for connection status</li> <li>Verify MCP operations work as expected</li> </ol>"},{"location":"protocols/mcp/usage/claude-integration/#debugging-connection-issues","title":"Debugging Connection Issues","text":"<p>Common issues and solutions:</p> <ul> <li>Server not starting: Check binary path and permissions</li> <li>Connection timeout: Verify server responds to initialization</li> <li>Protocol errors: Ensure MCP compliance and proper message handling</li> </ul>"},{"location":"protocols/mcp/usage/claude-integration/#example-integration","title":"Example Integration","text":"<p>A complete working example is available in the examples directory:</p> <pre><code># Navigate to example\ncd crates/airsprotocols-mcp/examples/simple-mcp-server\n\n# Build the server\ncargo build --release\n\n# Configure path in Claude Desktop\n# Point to: target/release/simple-mcp-server\n</code></pre>"},{"location":"protocols/mcp/usage/claude-integration/#http-integration","title":"HTTP Integration","text":"<p>For remote server integration, use HTTP transport:</p> <pre><code>{\n  \"mcpServers\": {\n    \"remote-server\": {\n      \"command\": \"npx\",\n      \"args\": [\"-y\", \"@modelcontextprotocol/server-http-client\", \"http://your-server:3000/mcp\"]\n    }\n  }\n}\n</code></pre>"},{"location":"protocols/mcp/usage/claude-integration/#verification","title":"Verification","text":"<p>After configuration:</p> <ol> <li>Restart Claude Desktop</li> <li>Check for your server in available tools</li> <li>Test basic operations like listing resources or tools</li> <li>Verify tool calls work correctly</li> </ol>"},{"location":"protocols/mcp/usage/claude-integration/#troubleshooting","title":"Troubleshooting","text":""},{"location":"protocols/mcp/usage/claude-integration/#common-issues","title":"Common Issues","text":"<ul> <li>Server not visible: Check configuration file syntax and paths</li> <li>Permission errors: Ensure executable permissions on server binary</li> <li>Protocol errors: Verify server implements required MCP methods</li> <li>Timeout issues: Check server startup time and responsiveness <pre><code>**Each script includes:**\n- User confirmation for sensitive operations\n- Comprehensive error handling with recovery instructions\n- Real-time status feedback and progress indicators\n- Automatic validation and verification steps\n\n## Claude Desktop Configuration\n\n### Configuration File Location\n\nClaude Desktop reads MCP servers from:\n- **macOS**: `~/Library/Application Support/Claude/claude_desktop_config.json`\n- **Windows**: `%APPDATA%\\Claude\\claude_desktop_config.json`  \n- **Linux**: `~/.config/Claude/claude_desktop_config.json`\n\n### Example Configuration\n\n```json\n{\n  \"mcpServers\": {\n    \"simple-mcp-server\": {\n      \"command\": \"/path/to/your/simple-mcp-server\",\n      \"args\": [],\n      \"env\": {\n        \"RUST_LOG\": \"info\"\n      }\n    }\n  }\n}\n</code></pre></li> </ul>"},{"location":"protocols/mcp/usage/claude-integration/#advanced-configuration","title":"Advanced Configuration","text":"<pre><code>{\n  \"mcpServers\": {\n    \"airsprotocols-mcp-server\": {\n      \"command\": \"/usr/local/bin/airsprotocols-mcp-server\",\n      \"args\": [\"--config\", \"/etc/airsprotocols-mcp/config.json\"],\n      \"env\": {\n        \"RUST_LOG\": \"debug\",\n        \"MCP_SERVER_NAME\": \"AIRS Production Server\",\n        \"MAX_CONNECTIONS\": \"10\",\n        \"REQUEST_TIMEOUT\": \"30\"\n      }\n    }\n  }\n}\n</code></pre>"},{"location":"protocols/mcp/usage/claude-integration/#mcp-capabilities-integration","title":"MCP Capabilities Integration","text":""},{"location":"protocols/mcp/usage/claude-integration/#tools-integration","title":"Tools Integration","text":"<p>Tools appear in Claude Desktop's MCP Tools interface and can be executed in real-time:</p> <pre><code>use airsprotocols_mcp::integration::mcp::{ToolProvider, McpError};\nuse airsprotocols_mcp::protocol::protocol::Tool;\nuse async_trait::async_trait;\nuse serde_json::{json, Value};\n\n#[derive(Debug)]\nstruct CalculatorTool;\n\n#[async_trait]\nimpl ToolProvider for CalculatorTool {\n    async fn list_tools(&amp;self) -&gt; Result&lt;Vec&lt;Tool&gt;, McpError&gt; {\n        Ok(vec![\n            Tool {\n                name: \"add\".to_string(),\n                description: \"Add two numbers\".to_string(),\n                input_schema: json!({\n                    \"type\": \"object\",\n                    \"properties\": {\n                        \"a\": {\"type\": \"number\", \"description\": \"First number\"},\n                        \"b\": {\"type\": \"number\", \"description\": \"Second number\"}\n                    },\n                    \"required\": [\"a\", \"b\"]\n                }),\n            }\n        ])\n    }\n\n    async fn call_tool(&amp;self, name: &amp;str, args: Value) -&gt; Result&lt;Vec&lt;Content&gt;, McpError&gt; {\n        match name {\n            \"add\" =&gt; {\n                let a = args[\"a\"].as_f64().unwrap_or(0.0);\n                let b = args[\"b\"].as_f64().unwrap_or(0.0);\n                let result = a + b;\n\n                Ok(vec![Content::Text {\n                    text: format!(\"Result: {} + {} = {}\", a, b, result),\n                }])\n            }\n            _ =&gt; Err(McpError::InvalidRequest {\n                message: format!(\"Unknown tool: {}\", name),\n            })\n        }\n    }\n}\n</code></pre>"},{"location":"protocols/mcp/usage/claude-integration/#resources-integration","title":"Resources Integration","text":"<p>Resources are accessible through Claude Desktop's attachment menu:</p> <pre><code>use airsprotocols_mcp::integration::mcp::{ResourceProvider, McpError};\nuse airsprotocols_mcp::protocol::protocol::{Resource, Content, Uri, MimeType};\nuse async_trait::async_trait;\n\n#[derive(Debug)]\nstruct FileSystemProvider {\n    base_path: String,\n}\n\n#[async_trait]\nimpl ResourceProvider for FileSystemProvider {\n    async fn list_resources(&amp;self) -&gt; Result&lt;Vec&lt;Resource&gt;, McpError&gt; {\n        Ok(vec![\n            Resource {\n                uri: Uri::new(\"file:///docs/readme.txt\")?,\n                name: \"Project README\".to_string(),\n                description: Some(\"Main project documentation\".to_string()),\n                mime_type: Some(MimeType::new(\"text/plain\")?),\n            },\n            Resource {\n                uri: Uri::new(\"file:///config/app.json\")?,\n                name: \"App Configuration\".to_string(),\n                description: Some(\"Application configuration file\".to_string()),\n                mime_type: Some(MimeType::new(\"application/json\")?),\n            },\n        ])\n    }\n\n    async fn read_resource(&amp;self, uri: &amp;str) -&gt; Result&lt;Vec&lt;Content&gt;, McpError&gt; {\n        match uri {\n            \"file:///docs/readme.txt\" =&gt; {\n                Ok(vec![Content::Text {\n                    text: std::fs::read_to_string(&amp;format!(\"{}/docs/readme.txt\", self.base_path))\n                        .map_err(|e| McpError::InvalidRequest {\n                            message: format!(\"Failed to read file: {}\", e),\n                        })?,\n                }])\n            }\n            \"file:///config/app.json\" =&gt; {\n                let content = std::fs::read_to_string(&amp;format!(\"{}/config/app.json\", self.base_path))\n                    .map_err(|e| McpError::InvalidRequest {\n                        message: format!(\"Failed to read file: {}\", e),\n                    })?;\n\n                Ok(vec![Content::Text { text: content }])\n            }\n            _ =&gt; Err(McpError::InvalidRequest {\n                message: format!(\"Resource not found: {}\", uri),\n            })\n        }\n    }\n}\n</code></pre>"},{"location":"protocols/mcp/usage/claude-integration/#prompts-integration","title":"Prompts Integration","text":"<p>Prompts appear in Claude Desktop's prompt template interface:</p> <pre><code>use airsprotocols_mcp::integration::mcp::{PromptProvider, McpError};\nuse airsprotocols_mcp::protocol::protocol::{Prompt, PromptArgument, PromptMessage};\nuse async_trait::async_trait;\nuse serde_json::Value;\n\n#[derive(Debug)]\nstruct CodeReviewPrompts;\n\n#[async_trait]\nimpl PromptProvider for CodeReviewPrompts {\n    async fn list_prompts(&amp;self) -&gt; Result&lt;Vec&lt;Prompt&gt;, McpError&gt; {\n        Ok(vec![\n            Prompt {\n                name: \"code-review\".to_string(),\n                description: \"Perform comprehensive code review\".to_string(),\n                arguments: vec![\n                    PromptArgument {\n                        name: \"language\".to_string(),\n                        description: \"Programming language\".to_string(),\n                        required: true,\n                    },\n                    PromptArgument {\n                        name: \"code\".to_string(),\n                        description: \"Code to review\".to_string(),\n                        required: true,\n                    }\n                ],\n            }\n        ])\n    }\n\n    async fn get_prompt(&amp;self, name: &amp;str, args: Value) -&gt; Result&lt;PromptMessage, McpError&gt; {\n        match name {\n            \"code-review\" =&gt; {\n                let language = args[\"language\"].as_str().unwrap_or(\"unknown\");\n                let code = args[\"code\"].as_str().unwrap_or(\"\");\n\n                Ok(PromptMessage {\n                    role: \"user\".to_string(),\n                    content: format!(\n                        \"Please review this {} code for:\\n\\\n                         \u2022 Code quality and best practices\\n\\\n                         \u2022 Potential bugs or issues\\n\\\n                         \u2022 Performance optimizations\\n\\\n                         \u2022 Security considerations\\n\\n\\\n                         ```{}\\n{}\\n```\",\n                        language, language, code\n                    ),\n                })\n            }\n            _ =&gt; Err(McpError::InvalidRequest {\n                message: format!(\"Unknown prompt: {}\", name),\n            })\n        }\n    }\n}\n</code></pre>"},{"location":"protocols/mcp/usage/claude-integration/#server-implementation_1","title":"Server Implementation","text":""},{"location":"protocols/mcp/usage/claude-integration/#complete-mcp-server","title":"Complete MCP Server","text":"<pre><code>use airsprotocols_mcp::integration::mcp::McpServerBuilder;\nuse airsprotocols_mcp::protocol::protocol::ServerCapabilities;\nuse tracing::info;\n\n#[tokio::main]\nasync fn main() -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {\n    // Initialize logging (file-based to avoid STDIO contamination)\n    init_logging()?;\n\n    info!(\"Starting AIRS MCP Server for Claude Desktop\");\n\n    // Create server capabilities\n    let capabilities = ServerCapabilities::default()\n        .with_tools()\n        .with_resources()\n        .with_prompts()\n        .with_logging();\n\n    // Build server with providers\n    let server = McpServerBuilder::new()\n        .capabilities(capabilities)\n        .tool_provider(Box::new(CalculatorTool))\n        .resource_provider(Box::new(FileSystemProvider {\n            base_path: \"/tmp\".to_string(),\n        }))\n        .prompt_provider(Box::new(CodeReviewPrompts))\n        .build()?;\n\n    info!(\"Server built successfully, starting JSON-RPC communication\");\n\n    // Run server (connects to Claude Desktop via STDIO)\n    server.run().await?;\n\n    info!(\"\ud83d\udd04 Server shutdown complete\");\n    Ok(())\n}\n\nfn init_logging() -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {\n    use tracing_subscriber::{fmt, EnvFilter};\n    use tracing_appender::rolling::{RollingFileAppender, Rotation};\n\n    let file_appender = RollingFileAppender::new(\n        Rotation::DAILY,\n        \"/tmp/airsprotocols-mcp-server\",\n        \"server.log\",\n    );\n\n    fmt()\n        .with_writer(file_appender)\n        .with_env_filter(EnvFilter::new(\"info\"))\n        .init();\n\n    Ok(())\n}\n</code></pre>"},{"location":"protocols/mcp/usage/claude-integration/#testing-and-validation","title":"Testing and Validation","text":""},{"location":"protocols/mcp/usage/claude-integration/#mcp-inspector-testing","title":"MCP Inspector Testing","text":"<p>Test your server with the browser-based MCP Inspector:</p> <pre><code># Run MCP Inspector tests\n./scripts/test_inspector.sh\n\n# Manual testing\nnpx @modelcontextprotocol/inspector /path/to/your/server\n</code></pre>"},{"location":"protocols/mcp/usage/claude-integration/#claude-desktop-verification","title":"Claude Desktop Verification","text":"<ol> <li>Tools Testing: Look for your tools in the MCP icon in Claude's chat interface</li> <li>Resources Testing: Check the attachment menu for \"Add from [your-server-name]\"</li> <li>Prompts Testing: Find your prompts in the prompt template interface</li> </ol>"},{"location":"protocols/mcp/usage/claude-integration/#real-time-monitoring","title":"Real-time Monitoring","text":"<pre><code># Monitor server logs\ntail -f /tmp/airsprotocols-mcp-server/server.log\n\n# Debug integration status\n./scripts/debug_integration.sh\n\n# Watch Claude Desktop logs (macOS)\ntail -f ~/Library/Logs/Claude/claude-desktop.log\n</code></pre>"},{"location":"protocols/mcp/usage/claude-integration/#production-deployment","title":"Production Deployment","text":""},{"location":"protocols/mcp/usage/claude-integration/#security-considerations","title":"Security Considerations","text":"<pre><code>// Secure file system access\nimpl FileSystemProvider {\n    fn validate_path(&amp;self, path: &amp;str) -&gt; Result&lt;(), McpError&gt; {\n        let canonical = std::fs::canonicalize(path)\n            .map_err(|_| McpError::InvalidRequest {\n                message: \"Invalid file path\".to_string(),\n            })?;\n\n        if !canonical.starts_with(&amp;self.base_path) {\n            return Err(McpError::InvalidRequest {\n                message: \"Path outside allowed directory\".to_string(),\n            });\n        }\n\n        Ok(())\n    }\n}\n</code></pre>"},{"location":"protocols/mcp/usage/claude-integration/#performance-optimization","title":"Performance Optimization","text":"<pre><code>use airsprotocols_mcp::protocol::jsonrpc::concurrent::ConcurrentJsonRpcConfig;\nuse std::time::Duration;\n\nlet config = ConcurrentJsonRpcConfig::builder()\n    .request_timeout(Duration::from_secs(30))\n    .max_concurrent_requests(50)\n    .buffer_size(16384)\n    .enable_correlation_tracking(true)\n    .build();\n\nlet server = McpServerBuilder::new()\n    .with_config(config)\n    .build()?;\n</code></pre>"},{"location":"protocols/mcp/usage/claude-integration/#error-recovery","title":"Error Recovery","text":"<pre><code>use tokio::signal;\n\nasync fn run_with_graceful_shutdown() -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {\n    let server = build_server()?;\n\n    let shutdown = async {\n        signal::ctrl_c().await.expect(\"Failed to listen for Ctrl+C\");\n        info!(\"Received shutdown signal\");\n    };\n\n    tokio::select! {\n        result = server.run() =&gt; {\n            match result {\n                Ok(_) =&gt; info!(\"Server completed normally\"),\n                Err(e) =&gt; {\n                    error!(\"Server error: {}\", e);\n                    return Err(e.into());\n                }\n            }\n        }\n        _ = shutdown =&gt; {\n            info!(\"Shutting down gracefully\");\n        }\n    }\n\n    Ok(())\n}\n</code></pre>"},{"location":"protocols/mcp/usage/claude-integration/#troubleshooting_1","title":"Troubleshooting","text":""},{"location":"protocols/mcp/usage/claude-integration/#common-issues_1","title":"Common Issues","text":"<ol> <li>Server Not Appearing in Claude: Check configuration file path and syntax</li> <li>Permission Denied: Ensure server binary has execute permissions</li> <li>Connection Refused: Verify server starts without errors</li> <li>Tools Not Working: Check tool schema validation</li> </ol>"},{"location":"protocols/mcp/usage/claude-integration/#debug-commands","title":"Debug Commands","text":"<pre><code># Validate configuration\njq empty claude_desktop_config.json\n\n# Test server directly\necho '{\"jsonrpc\":\"2.0\",\"id\":1,\"method\":\"initialize\",\"params\":{}}' | your-server\n\n# Check file permissions\nls -la /path/to/your/server\n\n# Monitor Claude Desktop process\nps aux | grep -i claude\n</code></pre> <p>Next: Advanced Patterns</p> <p>Check back soon for comprehensive Claude Desktop integration guidance.</p>"},{"location":"protocols/mcp/usage/custom-transports/","title":"Custom Transports","text":"<p>Building custom transport layers and implementations</p> <p>Leverage the AIRS MCP transport abstraction layer to build custom transport implementations that suit your specific deployment requirements. Whether you need HTTP, WebSocket, TCP, or entirely custom protocols, this guide covers everything from basic implementation to production deployment.</p>"},{"location":"protocols/mcp/usage/custom-transports/#transport-architecture-overview","title":"Transport Architecture Overview","text":"<p>The AIRS MCP transport system is built around a flexible trait-based architecture:</p> <pre><code>graph TD\n    A[Transport Trait] --&gt; B[STDIO Transport]\n    A --&gt; C[HTTP Transport*]\n    A --&gt; D[WebSocket Transport*]\n    A --&gt; E[TCP Transport*]\n    A --&gt; F[Custom Transport]\n\n    G[ZeroCopyTransport] --&gt; B\n    G --&gt; F\n\n    H[StreamingTransport] --&gt; B\n    H --&gt; F\n\n    I[BufferManager] --&gt; B\n    I --&gt; F\n\n    subgraph \"Production Ready\"\n        B\n    end\n\n    subgraph \"Framework Ready\"\n        C\n        D\n        E\n    end</code></pre> <p>* Framework placeholders ready for implementation</p>"},{"location":"protocols/mcp/usage/custom-transports/#core-transport-trait","title":"Core Transport Trait","text":"<p>All transport implementations must satisfy the <code>Transport</code> trait:</p> <pre><code>use std::future::Future;\nuse airsprotocols_mcp::transport::{Transport, TransportError};\n\npub trait Transport: Send + Sync {\n    /// Transport-specific error type\n    type Error: std::error::Error + Send + Sync + 'static;\n\n    /// Send a message through the transport\n    fn send(&amp;mut self, message: &amp;[u8]) -&gt; impl Future&lt;Output = Result&lt;(), Self::Error&gt;&gt; + Send;\n\n    /// Receive a message from the transport\n    fn receive(&amp;mut self) -&gt; impl Future&lt;Output = Result&lt;Vec&lt;u8&gt;, Self::Error&gt;&gt; + Send;\n\n    /// Close the transport and clean up resources\n    fn close(&amp;mut self) -&gt; impl Future&lt;Output = Result&lt;(), Self::Error&gt;&gt; + Send;\n}\n</code></pre>"},{"location":"protocols/mcp/usage/custom-transports/#design-principles","title":"Design Principles","text":"<ul> <li>Async-native: All operations return futures for Tokio integration</li> <li>Generic messages: Uses raw bytes (<code>&amp;[u8]</code>/<code>Vec&lt;u8&gt;</code>) for flexibility</li> <li>Error transparency: Associated Error type for transport-specific handling</li> <li>Resource safety: Explicit <code>close()</code> method ensures proper cleanup</li> <li>Thread safety: All implementations must be <code>Send + Sync</code></li> </ul>"},{"location":"protocols/mcp/usage/custom-transports/#stdio-transport-deep-dive","title":"STDIO Transport Deep Dive","text":"<p>The production-ready STDIO transport serves as both the primary MCP transport and a reference implementation for custom transports.</p>"},{"location":"protocols/mcp/usage/custom-transports/#message-framing","title":"Message Framing","text":"<p>STDIO transport uses newline-delimited JSON for message framing:</p> <pre><code>use airsprotocols_mcp::transport::{Transport, StdioTransport};\n\nasync fn stdio_example() -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {\n    let mut transport = StdioTransportClientBuilder::new().await?;\n\n    // Send JSON-RPC message (automatically adds newline)\n    let request = br#\"{\"jsonrpc\":\"2.0\",\"method\":\"ping\",\"id\":\"1\"}\"#;\n    transport.send(request).await?;\n\n    // Receive response (newline automatically stripped)\n    let response = transport.receive().await?;\n    println!(\"Received: {}\", String::from_utf8_lossy(&amp;response));\n\n    transport.close().await?;\n    Ok(())\n}\n</code></pre>"},{"location":"protocols/mcp/usage/custom-transports/#buffer-management","title":"Buffer Management","text":"<p>STDIO transport supports buffer pooling:</p> <pre><code>use airsprotocols_mcp::transport::{StdioTransport, BufferConfig};\n\nasync fn high_performance_stdio() -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {\n    // Configure buffer management\n    let buffer_config = BufferConfig {\n        read_buffer_capacity: 64 * 1024,     // 64KB read buffers\n        write_buffer_capacity: 64 * 1024,    // 64KB write buffers\n        max_message_size: 16 * 1024 * 1024,  // 16MB message limit\n        pool_size: 10,                       // Pool 10 buffers\n        acquire_timeout_ms: 100,             // 100ms timeout\n        backpressure_threshold: 0.8,         // Apply backpressure at 80% capacity\n    };\n\n    let transport = StdioTransport::with_buffer_config(buffer_config).await?;\n\n    // Monitor buffer performance\n    if let Some(metrics) = transport.buffer_metrics() {\n        println!(\"Buffer efficiency: {:.2}%\", \n                 metrics.acquisition_success_rate() * 100.0);\n    }\n\n    Ok(())\n}\n</code></pre>"},{"location":"protocols/mcp/usage/custom-transports/#buffer-management_1","title":"Buffer Management","text":"<p>Implement <code>ZeroCopyTransport</code> for maximum performance:</p> <pre><code>use airsprotocols_mcp::transport::{ZeroCopyTransport, TransportError};\nuse bytes::BytesMut;\n\nasync fn zero_copy_example&lt;T: ZeroCopyTransport&gt;(\n    transport: &amp;mut T\n) -&gt; Result&lt;(), TransportError&gt; {\n    // Acquire buffer from pool\n    let mut buffer = transport.acquire_buffer().await?;\n\n    // Receive directly into buffer (no allocation)\n    let bytes_received = transport.receive_into_buffer(&amp;mut buffer).await?;\n\n    // Process message in-place\n    process_message_inplace(&amp;mut buffer[..bytes_received]);\n\n    // Send using efficient buffer operations\n    transport.send_bytes(&amp;buffer[..bytes_received]).await?;\n\n    // Buffer automatically returned to pool when dropped\n    Ok(())\n}\n\nfn process_message_inplace(buffer: &amp;mut [u8]) {\n    // Process message efficiently in-place\n    // e.g., modify headers, add routing info, etc.\n}\n</code></pre>"},{"location":"protocols/mcp/usage/custom-transports/#building-custom-transports","title":"Building Custom Transports","text":""},{"location":"protocols/mcp/usage/custom-transports/#basic-custom-transport-template","title":"Basic Custom Transport Template","text":"<p>Here's a template for implementing custom transports:</p> <pre><code>use std::sync::Arc;\nuse tokio::sync::Mutex;\nuse async_trait::async_trait;\nuse airsprotocols_mcp::transport::{Transport, TransportError};\n\n/// Custom transport implementation\npub struct CustomTransport {\n    // Your transport-specific state\n    connection: Arc&lt;Mutex&lt;Option&lt;Connection&gt;&gt;&gt;,\n    config: CustomConfig,\n    closed: Arc&lt;Mutex&lt;bool&gt;&gt;,\n}\n\n#[derive(Debug)]\npub struct CustomConfig {\n    pub endpoint: String,\n    pub timeout_ms: u64,\n    pub max_message_size: usize,\n}\n\n#[derive(Debug)]\nstruct Connection {\n    // Your connection implementation\n}\n\nimpl CustomTransport {\n    pub async fn new(config: CustomConfig) -&gt; Result&lt;Self, TransportError&gt; {\n        Ok(Self {\n            connection: Arc::new(Mutex::new(None)),\n            config,\n            closed: Arc::new(Mutex::new(false)),\n        })\n    }\n\n    async fn ensure_connected(&amp;self) -&gt; Result&lt;(), TransportError&gt; {\n        let mut conn = self.connection.lock().await;\n        if conn.is_none() {\n            *conn = Some(self.establish_connection().await?);\n        }\n        Ok(())\n    }\n\n    async fn establish_connection(&amp;self) -&gt; Result&lt;Connection, TransportError&gt; {\n        // Implement your connection logic\n        todo!(\"Implement connection establishment\")\n    }\n}\n\nimpl Transport for CustomTransport {\n    type Error = TransportError;\n\n    async fn send(&amp;mut self, message: &amp;[u8]) -&gt; Result&lt;(), Self::Error&gt; {\n        // Check if closed\n        if *self.closed.lock().await {\n            return Err(TransportError::Closed);\n        }\n\n        // Validate message size\n        if message.len() &gt; self.config.max_message_size {\n            return Err(TransportError::buffer_overflow(format!(\n                \"Message size {} exceeds limit {}\",\n                message.len(),\n                self.config.max_message_size\n            )));\n        }\n\n        // Ensure connection\n        self.ensure_connected().await?;\n\n        // Implement your send logic\n        let connection = self.connection.lock().await;\n        if let Some(conn) = connection.as_ref() {\n            // Send message through your protocol\n            self.send_through_connection(conn, message).await\n        } else {\n            Err(TransportError::connection_closed())\n        }\n    }\n\n    async fn receive(&amp;mut self) -&gt; Result&lt;Vec&lt;u8&gt;, Self::Error&gt; {\n        // Check if closed\n        if *self.closed.lock().await {\n            return Err(TransportError::Closed);\n        }\n\n        // Ensure connection\n        self.ensure_connected().await?;\n\n        // Implement your receive logic\n        let connection = self.connection.lock().await;\n        if let Some(conn) = connection.as_ref() {\n            self.receive_from_connection(conn).await\n        } else {\n            Err(TransportError::connection_closed())\n        }\n    }\n\n    async fn close(&amp;mut self) -&gt; Result&lt;(), Self::Error&gt; {\n        // Set closed flag\n        *self.closed.lock().await = true;\n\n        // Close connection\n        let mut connection = self.connection.lock().await;\n        if let Some(conn) = connection.take() {\n            self.close_connection(conn).await?;\n        }\n\n        Ok(())\n    }\n}\n\nimpl CustomTransport {\n    async fn send_through_connection(\n        &amp;self,\n        connection: &amp;Connection,\n        message: &amp;[u8]\n    ) -&gt; Result&lt;(), TransportError&gt; {\n        // Implement protocol-specific sending\n        todo!(\"Implement protocol send\")\n    }\n\n    async fn receive_from_connection(\n        &amp;self,\n        connection: &amp;Connection\n    ) -&gt; Result&lt;Vec&lt;u8&gt;, TransportError&gt; {\n        // Implement protocol-specific receiving\n        todo!(\"Implement protocol receive\")\n    }\n\n    async fn close_connection(&amp;self, connection: Connection) -&gt; Result&lt;(), TransportError&gt; {\n        // Implement connection cleanup\n        todo!(\"Implement connection cleanup\")\n    }\n}\n</code></pre>"},{"location":"protocols/mcp/usage/custom-transports/#http-transport-implementation","title":"HTTP Transport Implementation","text":"<p>Here's a production-ready HTTP transport example:</p> <pre><code>use std::sync::Arc;\nuse tokio::sync::RwLock;\nuse reqwest::{Client, Url};\nuse serde_json::Value;\nuse airsprotocols_mcp::transport::{Transport, TransportError};\n\npub struct HttpTransport {\n    client: Client,\n    endpoint: Url,\n    session_id: Arc&lt;RwLock&lt;Option&lt;String&gt;&gt;&gt;,\n    last_event_id: Arc&lt;RwLock&lt;Option&lt;String&gt;&gt;&gt;,\n    timeout: std::time::Duration,\n}\n\nimpl HttpTransport {\n    pub fn new(endpoint: Url, timeout_ms: u64) -&gt; Result&lt;Self, TransportError&gt; {\n        let client = Client::builder()\n            .timeout(std::time::Duration::from_millis(timeout_ms))\n            .build()\n            .map_err(|e| TransportError::format(format!(\"HTTP client error: {}\", e)))?;\n\n        Ok(Self {\n            client,\n            endpoint,\n            session_id: Arc::new(RwLock::new(None)),\n            last_event_id: Arc::new(RwLock::new(None)),\n            timeout: std::time::Duration::from_millis(timeout_ms),\n        })\n    }\n}\n\nimpl Transport for HttpTransport {\n    type Error = TransportError;\n\n    async fn send(&amp;mut self, message: &amp;[u8]) -&gt; Result&lt;(), Self::Error&gt; {\n        let json: Value = serde_json::from_slice(message)\n            .map_err(|e| TransportError::format(format!(\"Invalid JSON: {}\", e)))?;\n\n        let response = self.client\n            .post(self.endpoint.clone())\n            .json(&amp;json)\n            .header(\"Content-Type\", \"application/json\")\n            .send()\n            .await\n            .map_err(|e| TransportError::io(e))?;\n\n        if !response.status().is_success() {\n            return Err(TransportError::format(format!(\n                \"HTTP error: {}\", response.status()\n            )));\n        }\n\n        Ok(())\n    }\n\n    async fn receive(&amp;mut self) -&gt; Result&lt;Vec&lt;u8&gt;, Self::Error&gt; {\n        // For HTTP, you might implement Server-Sent Events or polling\n        // This is a simplified example\n        let response = self.client\n            .get(self.endpoint.clone())\n            .send()\n            .await\n            .map_err(|e| TransportError::io(e))?;\n\n        let bytes = response.bytes().await\n            .map_err(|e| TransportError::io(e))?;\n\n        Ok(bytes.to_vec())\n    }\n\n    async fn close(&amp;mut self) -&gt; Result&lt;(), Self::Error&gt; {\n        // HTTP is stateless, so just clear session state\n        *self.session_id.write().await = None;\n        *self.last_event_id.write().await = None;\n        Ok(())\n    }\n}\n</code></pre>"},{"location":"protocols/mcp/usage/custom-transports/#websocket-transport-implementation","title":"WebSocket Transport Implementation","text":"<p>For real-time bidirectional communication:</p> <pre><code>use tokio_tungstenite::{connect_async, WebSocketStream, MaybeTlsStream};\nuse tokio::net::TcpStream;\nuse tokio_tungstenite::tungstenite::Message;\nuse std::sync::Arc;\nuse tokio::sync::Mutex;\nuse airsprotocols_mcp::transport::{Transport, TransportError};\n\npub struct WebSocketTransport {\n    ws_stream: Arc&lt;Mutex&lt;Option&lt;WebSocketStream&lt;MaybeTlsStream&lt;TcpStream&gt;&gt;&gt;&gt;&gt;,\n    url: String,\n    closed: Arc&lt;Mutex&lt;bool&gt;&gt;,\n}\n\nimpl WebSocketTransport {\n    pub async fn new(url: String) -&gt; Result&lt;Self, TransportError&gt; {\n        let transport = Self {\n            ws_stream: Arc::new(Mutex::new(None)),\n            url,\n            closed: Arc::new(Mutex::new(false)),\n        };\n\n        transport.connect().await?;\n        Ok(transport)\n    }\n\n    async fn connect(&amp;self) -&gt; Result&lt;(), TransportError&gt; {\n        let (ws_stream, _) = connect_async(&amp;self.url).await\n            .map_err(|e| TransportError::io(e))?;\n\n        *self.ws_stream.lock().await = Some(ws_stream);\n        Ok(())\n    }\n}\n\nimpl Transport for WebSocketTransport {\n    type Error = TransportError;\n\n    async fn send(&amp;mut self, message: &amp;[u8]) -&gt; Result&lt;(), Self::Error&gt; {\n        if *self.closed.lock().await {\n            return Err(TransportError::Closed);\n        }\n\n        let mut stream_guard = self.ws_stream.lock().await;\n        if let Some(stream) = stream_guard.as_mut() {\n            use futures_util::SinkExt;\n\n            let text = String::from_utf8(message.to_vec())\n                .map_err(|e| TransportError::format(format!(\"Invalid UTF-8: {}\", e)))?;\n\n            stream.send(Message::Text(text)).await\n                .map_err(|e| TransportError::io(e))?;\n        } else {\n            return Err(TransportError::connection_closed());\n        }\n\n        Ok(())\n    }\n\n    async fn receive(&amp;mut self) -&gt; Result&lt;Vec&lt;u8&gt;, Self::Error&gt; {\n        if *self.closed.lock().await {\n            return Err(TransportError::Closed);\n        }\n\n        let mut stream_guard = self.ws_stream.lock().await;\n        if let Some(stream) = stream_guard.as_mut() {\n            use futures_util::StreamExt;\n\n            if let Some(msg) = stream.next().await {\n                let msg = msg.map_err(|e| TransportError::io(e))?;\n\n                match msg {\n                    Message::Text(text) =&gt; Ok(text.into_bytes()),\n                    Message::Binary(data) =&gt; Ok(data),\n                    Message::Close(_) =&gt; {\n                        *self.closed.lock().await = true;\n                        Err(TransportError::Closed)\n                    }\n                    _ =&gt; Err(TransportError::format(\"Unexpected message type\".to_string())),\n                }\n            } else {\n                Err(TransportError::Closed)\n            }\n        } else {\n            Err(TransportError::connection_closed())\n        }\n    }\n\n    async fn close(&amp;mut self) -&gt; Result&lt;(), Self::Error&gt; {\n        *self.closed.lock().await = true;\n\n        let mut stream_guard = self.ws_stream.lock().await;\n        if let Some(mut stream) = stream_guard.take() {\n            use futures_util::SinkExt;\n            let _ = stream.close(None).await; // Best effort close\n        }\n\n        Ok(())\n    }\n}\n</code></pre>"},{"location":"protocols/mcp/usage/custom-transports/#protocol-considerations","title":"Protocol Considerations","text":""},{"location":"protocols/mcp/usage/custom-transports/#message-framing_1","title":"Message Framing","text":"<p>Different transport protocols require different message framing strategies:</p> Transport Framing Strategy Example STDIO Newline-delimited <code>{\"jsonrpc\":\"2.0\",\"method\":\"ping\"}\\n</code> HTTP Content-Length header <code>Content-Length: 35\\r\\n\\r\\n{\"jsonrpc\":\"2.0\",\"method\":\"ping\"}</code> WebSocket Native framing WebSocket text/binary frames TCP Length-prefixed <code>[4-byte length][JSON payload]</code>"},{"location":"protocols/mcp/usage/custom-transports/#error-handling-strategies","title":"Error Handling Strategies","text":"<p>Implement robust error handling for network failures:</p> <pre><code>use airsprotocols_mcp::transport::TransportError;\n\n#[derive(Debug, thiserror::Error)]\npub enum CustomTransportError {\n    #[error(\"Connection timeout\")]\n    Timeout,\n\n    #[error(\"Protocol violation: {0}\")]\n    ProtocolViolation(String),\n\n    #[error(\"Authentication failed\")]\n    AuthenticationFailed,\n\n    #[error(\"Rate limit exceeded\")]\n    RateLimitExceeded,\n\n    #[error(\"Network error: {0}\")]\n    Network(#[from] std::io::Error),\n}\n\nimpl From&lt;CustomTransportError&gt; for TransportError {\n    fn from(err: CustomTransportError) -&gt; Self {\n        match err {\n            CustomTransportError::Timeout =&gt; TransportError::timeout(),\n            CustomTransportError::Network(io_err) =&gt; TransportError::io(io_err),\n            other =&gt; TransportError::format(other.to_string()),\n        }\n    }\n}\n</code></pre>"},{"location":"protocols/mcp/usage/custom-transports/#security-implementation","title":"Security Implementation","text":"<p>Implement security features for production deployments:</p> <pre><code>use std::sync::Arc;\nuse tokio_rustls::{TlsConnector, rustls::ClientConfig};\n\npub struct SecureTransport&lt;T&gt; {\n    inner: T,\n    tls_config: Arc&lt;ClientConfig&gt;,\n    certificate_validation: bool,\n}\n\nimpl&lt;T: Transport&gt; SecureTransport&lt;T&gt; {\n    pub fn new(inner: T, tls_config: ClientConfig) -&gt; Self {\n        Self {\n            inner,\n            tls_config: Arc::new(tls_config),\n            certificate_validation: true,\n        }\n    }\n\n    pub fn disable_certificate_validation(mut self) -&gt; Self {\n        self.certificate_validation = false;\n        self\n    }\n}\n\nimpl&lt;T: Transport&gt; Transport for SecureTransport&lt;T&gt; {\n    type Error = TransportError;\n\n    async fn send(&amp;mut self, message: &amp;[u8]) -&gt; Result&lt;(), Self::Error&gt; {\n        // Add authentication headers or encryption\n        let encrypted_message = self.encrypt_message(message)?;\n        self.inner.send(&amp;encrypted_message).await\n            .map_err(|e| TransportError::format(e.to_string()))\n    }\n\n    async fn receive(&amp;mut self) -&gt; Result&lt;Vec&lt;u8&gt;, Self::Error&gt; {\n        let encrypted_message = self.inner.receive().await\n            .map_err(|e| TransportError::format(e.to_string()))?;\n        self.decrypt_message(&amp;encrypted_message)\n    }\n\n    async fn close(&amp;mut self) -&gt; Result&lt;(), Self::Error&gt; {\n        self.inner.close().await\n            .map_err(|e| TransportError::format(e.to_string()))\n    }\n}\n\nimpl&lt;T&gt; SecureTransport&lt;T&gt; {\n    fn encrypt_message(&amp;self, message: &amp;[u8]) -&gt; Result&lt;Vec&lt;u8&gt;, TransportError&gt; {\n        // Implement encryption\n        Ok(message.to_vec()) // Placeholder\n    }\n\n    fn decrypt_message(&amp;self, message: &amp;[u8]) -&gt; Result&lt;Vec&lt;u8&gt;, TransportError&gt; {\n        // Implement decryption\n        Ok(message.to_vec()) // Placeholder\n    }\n}\n</code></pre>"},{"location":"protocols/mcp/usage/custom-transports/#performance-optimization","title":"Performance Optimization","text":""},{"location":"protocols/mcp/usage/custom-transports/#buffer-management-integration","title":"Buffer Management Integration","text":"<p>Integrate with AIRS MCP's buffer management:</p> <pre><code>use airsprotocols_mcp::transport::buffer::{BufferManager, BufferConfig};\nuse std::sync::Arc;\n\npub struct BufferedTransport&lt;T&gt; {\n    inner: T,\n    buffer_manager: Arc&lt;BufferManager&gt;,\n}\n\nimpl&lt;T: Transport&gt; BufferedTransport&lt;T&gt; {\n    pub fn new(inner: T, buffer_config: BufferConfig) -&gt; Self {\n        Self {\n            inner,\n            buffer_manager: Arc::new(BufferManager::new(buffer_config)),\n        }\n    }\n}\n\nimpl&lt;T: Transport&gt; Transport for BufferedTransport&lt;T&gt; {\n    type Error = TransportError;\n\n    async fn send(&amp;mut self, message: &amp;[u8]) -&gt; Result&lt;(), Self::Error&gt; {\n        // Use buffer pool for send operations\n        let mut buffer = self.buffer_manager.acquire_write_buffer().await?;\n        buffer.extend_from_slice(message);\n\n        self.inner.send(&amp;buffer).await\n            .map_err(|e| TransportError::format(e.to_string()))\n        // Buffer automatically returned to pool when dropped\n    }\n\n    async fn receive(&amp;mut self) -&gt; Result&lt;Vec&lt;u8&gt;, Self::Error&gt; {\n        let message = self.inner.receive().await\n            .map_err(|e| TransportError::format(e.to_string()))?;\n\n        // Process with buffer pool to reduce allocations\n        let mut buffer = self.buffer_manager.acquire_read_buffer().await?;\n        buffer.clear();\n        buffer.extend_from_slice(&amp;message);\n\n        Ok(buffer.to_vec())\n    }\n\n    async fn close(&amp;mut self) -&gt; Result&lt;(), Self::Error&gt; {\n        self.inner.close().await\n            .map_err(|e| TransportError::format(e.to_string()))\n    }\n}\n</code></pre>"},{"location":"protocols/mcp/usage/custom-transports/#streaming-integration","title":"Streaming Integration","text":"<p>Leverage streaming capabilities for large messages:</p> <pre><code>use airsprotocols_mcp::transport::streaming::{StreamingTransport, StreamingStats};\nuse airsprotocols_mcp::protocol::jsonrpc::streaming::StreamingConfig;\n\nasync fn create_streaming_transport&lt;T&gt;(\n    base_transport: T,\n    max_message_size: usize\n) -&gt; StreamingTransport&lt;T&gt;\nwhere\n    T: Transport + airsprotocols_mcp::transport::ZeroCopyTransport + Send + Sync,\n{\n    let config = StreamingConfig {\n        max_message_size,\n        read_buffer_size: 256 * 1024,  // 256KB streaming buffer\n        strict_validation: true,\n    };\n\n    StreamingTransport::new(base_transport, config)\n}\n</code></pre>"},{"location":"protocols/mcp/usage/custom-transports/#testing-custom-transports","title":"Testing Custom Transports","text":""},{"location":"protocols/mcp/usage/custom-transports/#mock-transport-for-testing","title":"Mock Transport for Testing","text":"<p>Create mock transports for comprehensive testing:</p> <pre><code>use std::collections::VecDeque;\nuse std::sync::Arc;\nuse tokio::sync::Mutex;\nuse airsprotocols_mcp::transport::{Transport, TransportError};\n\npub struct MockTransport {\n    messages: Arc&lt;Mutex&lt;Vec&lt;Vec&lt;u8&gt;&gt;&gt;&gt;,\n    responses: Arc&lt;Mutex&lt;VecDeque&lt;Vec&lt;u8&gt;&gt;&gt;&gt;,\n    closed: Arc&lt;Mutex&lt;bool&gt;&gt;,\n}\n\nimpl MockTransport {\n    pub fn new() -&gt; Self {\n        Self {\n            messages: Arc::new(Mutex::new(Vec::new())),\n            responses: Arc::new(Mutex::new(VecDeque::new())),\n            closed: Arc::new(Mutex::new(false)),\n        }\n    }\n\n    pub async fn add_response(&amp;self, response: Vec&lt;u8&gt;) {\n        self.responses.lock().await.push_back(response);\n    }\n\n    pub async fn get_sent_messages(&amp;self) -&gt; Vec&lt;Vec&lt;u8&gt;&gt; {\n        self.messages.lock().await.clone()\n    }\n}\n\nimpl Transport for MockTransport {\n    type Error = TransportError;\n\n    async fn send(&amp;mut self, message: &amp;[u8]) -&gt; Result&lt;(), Self::Error&gt; {\n        if *self.closed.lock().await {\n            return Err(TransportError::Closed);\n        }\n\n        self.messages.lock().await.push(message.to_vec());\n        Ok(())\n    }\n\n    async fn receive(&amp;mut self) -&gt; Result&lt;Vec&lt;u8&gt;, Self::Error&gt; {\n        if *self.closed.lock().await {\n            return Err(TransportError::Closed);\n        }\n\n        let mut responses = self.responses.lock().await;\n        responses.pop_front()\n            .ok_or_else(|| TransportError::format(\"No response available\".to_string()))\n    }\n\n    async fn close(&amp;mut self) -&gt; Result&lt;(), Self::Error&gt; {\n        *self.closed.lock().await = true;\n        Ok(())\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[tokio::test]\n    async fn test_mock_transport() {\n        let mut transport = MockTransport::new();\n\n        // Add response\n        transport.add_response(b\"test response\".to_vec()).await;\n\n        // Test send\n        transport.send(b\"test message\").await.unwrap();\n\n        // Test receive\n        let response = transport.receive().await.unwrap();\n        assert_eq!(response, b\"test response\");\n\n        // Verify sent messages\n        let sent = transport.get_sent_messages().await;\n        assert_eq!(sent.len(), 1);\n        assert_eq!(sent[0], b\"test message\");\n    }\n}\n</code></pre>"},{"location":"protocols/mcp/usage/custom-transports/#integration-testing","title":"Integration Testing","text":"<p>Test transport integration with the MCP protocol:</p> <pre><code>use airsprotocols_mcp::integration::server::JsonRpcServer;\nuse airsprotocols_mcp::protocol::jsonrpc::message::*;\n\n#[tokio::test]\nasync fn test_custom_transport_integration() {\n    let transport = CustomTransport::new(CustomConfig {\n        endpoint: \"ws://localhost:8080\".to_string(),\n        timeout_ms: 5000,\n        max_message_size: 1024 * 1024,\n    }).await.unwrap();\n\n    let server = JsonRpcServer::new(transport).await.unwrap();\n\n    // Test request handling\n    let request_handler = |req: JsonRpcRequest| async move {\n        JsonRpcResponse::success(req.id, serde_json::Value::String(\"pong\".to_string()))\n    };\n\n    let notification_handler = |_notif: JsonRpcNotification| async {\n        // Handle notification\n    };\n\n    // Run server with custom transport\n    server.run(request_handler, notification_handler).await.unwrap();\n}\n</code></pre>"},{"location":"protocols/mcp/usage/custom-transports/#production-deployment","title":"Production Deployment","text":""},{"location":"protocols/mcp/usage/custom-transports/#configuration-management","title":"Configuration Management","text":"<p>Structure configuration for production deployments:</p> <pre><code>use serde::{Deserialize, Serialize};\n\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct TransportConfig {\n    pub transport_type: TransportType,\n    pub stdio: Option&lt;StdioConfig&gt;,\n    pub http: Option&lt;HttpConfig&gt;,\n    pub websocket: Option&lt;WebSocketConfig&gt;,\n    pub custom: Option&lt;CustomConfig&gt;,\n}\n\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub enum TransportType {\n    Stdio,\n    Http,\n    WebSocket,\n    Custom(String),\n}\n\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct StdioConfig {\n    pub max_message_size: usize,\n    pub buffer_pool_size: Option&lt;usize&gt;,\n    pub enable_buffers: bool,\n}\n\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct HttpConfig {\n    pub endpoint: String,\n    pub timeout_ms: u64,\n    pub max_retries: u32,\n    pub enable_tls: bool,\n    pub certificate_path: Option&lt;String&gt;,\n}\n\npub async fn create_transport_from_config(\n    config: &amp;TransportConfig\n) -&gt; Result&lt;Box&lt;dyn Transport&lt;Error = TransportError&gt;&gt;, TransportError&gt; {\n    match config.transport_type {\n        TransportType::Stdio =&gt; {\n            let stdio_config = config.stdio.as_ref()\n                .ok_or_else(|| TransportError::format(\"Missing STDIO config\".to_string()))?;\n\n            if stdio_config.enable_buffers {\n                let buffer_config = BufferConfig {\n                    pool_size: stdio_config.buffer_pool_size.unwrap_or(10),\n                    max_message_size: stdio_config.max_message_size,\n                    ..Default::default()\n                };\n                Ok(Box::new(StdioTransport::with_buffer_config(buffer_config).await?))\n            } else {\n                Ok(Box::new(StdioTransport::with_max_message_size(\n                    stdio_config.max_message_size\n                ).await?))\n            }\n        }\n        TransportType::Http =&gt; {\n            let http_config = config.http.as_ref()\n                .ok_or_else(|| TransportError::format(\"Missing HTTP config\".to_string()))?;\n\n            let endpoint = http_config.endpoint.parse()\n                .map_err(|e| TransportError::format(format!(\"Invalid endpoint: {}\", e)))?;\n\n            Ok(Box::new(HttpTransport::new(endpoint, http_config.timeout_ms)?))\n        }\n        TransportType::WebSocket =&gt; {\n            let ws_config = config.websocket.as_ref()\n                .ok_or_else(|| TransportError::format(\"Missing WebSocket config\".to_string()))?;\n\n            Ok(Box::new(WebSocketTransport::new(ws_config.url.clone()).await?))\n        }\n        TransportType::Custom(name) =&gt; {\n            // Load custom transport by name\n            Err(TransportError::format(format!(\"Custom transport '{}' not implemented\", name)))\n        }\n    }\n}\n</code></pre>"},{"location":"protocols/mcp/usage/custom-transports/#monitoring-and-metrics","title":"Monitoring and Metrics","text":"<p>Implement comprehensive monitoring:</p> <pre><code>use std::sync::atomic::{AtomicU64, Ordering};\nuse std::time::Instant;\n\npub struct TransportMetrics {\n    pub messages_sent: AtomicU64,\n    pub messages_received: AtomicU64,\n    pub bytes_sent: AtomicU64,\n    pub bytes_received: AtomicU64,\n    pub errors: AtomicU64,\n    pub connection_count: AtomicU64,\n}\n\nimpl TransportMetrics {\n    pub fn new() -&gt; Self {\n        Self {\n            messages_sent: AtomicU64::new(0),\n            messages_received: AtomicU64::new(0),\n            bytes_sent: AtomicU64::new(0),\n            bytes_received: AtomicU64::new(0),\n            errors: AtomicU64::new(0),\n            connection_count: AtomicU64::new(0),\n        }\n    }\n\n    pub fn record_send(&amp;self, byte_count: usize) {\n        self.messages_sent.fetch_add(1, Ordering::Relaxed);\n        self.bytes_sent.fetch_add(byte_count as u64, Ordering::Relaxed);\n    }\n\n    pub fn record_receive(&amp;self, byte_count: usize) {\n        self.messages_received.fetch_add(1, Ordering::Relaxed);\n        self.bytes_received.fetch_add(byte_count as u64, Ordering::Relaxed);\n    }\n\n    pub fn record_error(&amp;self) {\n        self.errors.fetch_add(1, Ordering::Relaxed);\n    }\n}\n\npub struct MonitoredTransport&lt;T&gt; {\n    inner: T,\n    metrics: Arc&lt;TransportMetrics&gt;,\n}\n\nimpl&lt;T: Transport&gt; Transport for MonitoredTransport&lt;T&gt; {\n    type Error = TransportError;\n\n    async fn send(&amp;mut self, message: &amp;[u8]) -&gt; Result&lt;(), Self::Error&gt; {\n        let start = Instant::now();\n\n        match self.inner.send(message).await {\n            Ok(()) =&gt; {\n                self.metrics.record_send(message.len());\n                Ok(())\n            }\n            Err(e) =&gt; {\n                self.metrics.record_error();\n                Err(TransportError::format(e.to_string()))\n            }\n        }\n    }\n\n    async fn receive(&amp;mut self) -&gt; Result&lt;Vec&lt;u8&gt;, Self::Error&gt; {\n        match self.inner.receive().await {\n            Ok(message) =&gt; {\n                self.metrics.record_receive(message.len());\n                Ok(message)\n            }\n            Err(e) =&gt; {\n                self.metrics.record_error();\n                Err(TransportError::format(e.to_string()))\n            }\n        }\n    }\n\n    async fn close(&amp;mut self) -&gt; Result&lt;(), Self::Error&gt; {\n        self.inner.close().await\n            .map_err(|e| TransportError::format(e.to_string()))\n    }\n}\n</code></pre>"},{"location":"protocols/mcp/usage/custom-transports/#next-steps","title":"Next Steps","text":"<p>With custom transport implementation complete, you're ready to:</p> <ol> <li>Patterns \u2192 - Explore patterns and techniques</li> </ol> <p>Transport flexibility is one of AIRS MCP's key strengths. Whether you need simple STDIO communication or complex multi-protocol routing, the transport abstraction layer provides the foundation for any deployment scenario.</p>"},{"location":"servers/filesystem/","title":"MCP Filesystem Server","text":"<p>Security-first filesystem bridge that enables Claude Desktop and other MCP-compatible AI tools to safely read, write, and manage files in local development environments.</p>"},{"location":"servers/filesystem/#overview","title":"Overview","text":"<p><code>airsprotocols-mcpserver-filesystem</code> transforms AI assistance from passive consultation to active collaboration by providing secure, standardized filesystem operations through the Model Context Protocol (MCP). AI agents can now both understand your project context and create tangible artifacts directly in your local environment.</p>"},{"location":"servers/filesystem/#key-features","title":"Key Features","text":"<ul> <li>\ud83d\udd10 Security-First Design: Human-in-the-loop approval workflows with configurable security policies</li> <li>\ud83d\udcc1 Complete Filesystem Operations: Read, write, create, delete, move, and copy files and directories</li> <li>\ud83d\udee1\ufe0f Binary File Restriction: Text-only processing with comprehensive binary file blocking</li> <li>\u26a1 Performance Optimized: Sub-100ms response times with efficient memory management</li> <li>\ud83d\udd27 AIRS Ecosystem Integration: Seamless compatibility with other AIRS MCP tools</li> <li>\ud83d\udd12 Security Implementation: Path validation, audit logging, threat detection, and binary file protection</li> </ul>"},{"location":"servers/filesystem/#quick-links","title":"Quick Links","text":"<ul> <li>Quick Start: Get up and running in 5 minutes</li> <li>Installation: Detailed installation instructions</li> <li>Configuration: Complete configuration guide</li> <li>Security: Security model and best practices</li> <li>Usage Examples: Common use cases and examples</li> </ul>"},{"location":"servers/filesystem/#core-capabilities","title":"Core Capabilities","text":""},{"location":"servers/filesystem/#file-operations","title":"File Operations","text":"<ul> <li>read_file: Read text files with automatic encoding detection</li> <li>write_file: Create or update files with approval workflows</li> <li>list_directory: Browse filesystem with metadata and filtering</li> <li>create_directory: Create directory structures recursively</li> <li>delete_file/delete_directory: Safe deletion with confirmation</li> <li>move_file/copy_file: File manipulation with atomic operations</li> </ul>"},{"location":"servers/filesystem/#security-features","title":"Security Features","text":"<ul> <li>Binary File Restriction: Comprehensive blocking of binary files</li> <li>Human Approval: Interactive confirmation for write/delete operations</li> <li>Path Validation: Prevent directory traversal and unauthorized access</li> <li>Access Control: Configurable allowlists and denylists</li> <li>Audit Logging: Comprehensive operation tracking</li> <li>Threat Detection: Enhanced security monitoring</li> </ul>"},{"location":"servers/filesystem/#installation","title":"Installation","text":""},{"location":"servers/filesystem/#from-cratesio-recommended","title":"From crates.io (Recommended)","text":"<pre><code>cargo install airsprotocols-mcpserver-filesystem\n</code></pre>"},{"location":"servers/filesystem/#from-source","title":"From Source","text":"<pre><code>git clone https://github.com/airsstack/airsprotocols.git\ncd airsprotocols\ncargo build --release --package airsprotocols-mcpserver-filesystem\n</code></pre>"},{"location":"servers/filesystem/#quick-start","title":"Quick Start","text":"<ol> <li> <p>Install the server:    <pre><code>cargo install airsprotocols-mcpserver-filesystem\n</code></pre></p> </li> <li> <p>Generate configuration:    <pre><code>airsprotocols-mcpserver-filesystem config --env development\n</code></pre></p> </li> <li> <p>Configure Claude Desktop (<code>~/Library/Application Support/Claude/claude_desktop_config.json</code>):    <pre><code>{\n  \"mcpServers\": {\n    \"airsprotocols-mcpserver-filesystem\": {\n      \"command\": \"airsprotocols-mcpserver-filesystem\",\n      \"env\": {\n        \"AIRSPROTOCOLS_MCPSERVER_FS_ENV\": \"development\"\n      }\n    }\n  }\n}\n</code></pre></p> </li> <li> <p>Restart Claude Desktop and start using filesystem operations!</p> </li> </ol>"},{"location":"servers/filesystem/#documentation","title":"Documentation","text":"<ul> <li>Configuration Guide: Complete configuration system</li> <li>Security Policies: Advanced security configuration</li> <li>Troubleshooting: Common issues and solutions</li> </ul>"},{"location":"servers/filesystem/#use-cases","title":"Use Cases","text":""},{"location":"servers/filesystem/#development-workflow","title":"Development Workflow","text":"<ul> <li>Code analysis and refactoring</li> <li>Documentation generation</li> <li>Project scaffolding</li> <li>Configuration management</li> </ul>"},{"location":"servers/filesystem/#content-management","title":"Content Management","text":"<ul> <li>File organization</li> <li>Backup creation</li> <li>Text processing</li> <li>Duplicate detection</li> </ul>"},{"location":"servers/filesystem/#research-analysis","title":"Research &amp; Analysis","text":"<ul> <li>Code metadata extraction</li> <li>Content analysis</li> <li>Pattern matching</li> <li>Data processing</li> </ul>"},{"location":"servers/filesystem/#support","title":"Support","text":"<ul> <li>Documentation: Complete guides and references</li> <li>Issues: GitHub Issues</li> <li>Discussions: GitHub Discussions</li> </ul>"},{"location":"servers/filesystem/#license","title":"License","text":"<p>Licensed under MIT OR Apache-2.0 at your option.</p>"},{"location":"servers/filesystem/architecture/","title":"Technical Architecture","text":""},{"location":"servers/filesystem/architecture/#core-technology-stack","title":"Core Technology Stack","text":""},{"location":"servers/filesystem/architecture/#foundation-layer","title":"Foundation Layer","text":"<ul> <li>Language: Rust 2021 Edition (performance, safety, AIRS ecosystem alignment)</li> <li>MCP Protocol: Built on AIRS MCP foundation with STDIO transport for Claude Desktop</li> <li>Async Runtime: Tokio for high-performance file I/O operations</li> <li>Security Framework: Custom approval workflows with binary file restriction</li> </ul>"},{"location":"servers/filesystem/architecture/#security-first-processing-stack","title":"Security-First Processing Stack","text":"<ul> <li>Binary File Restriction: Complete blocking of binary file operations for enhanced security</li> <li>Text Processing: Focus on source code, configuration, and documentation files</li> <li>Format Detection: Extension-based and content-based binary detection for rejection</li> <li>Audit Logging: Comprehensive tracking of security events and file operations</li> </ul>"},{"location":"servers/filesystem/architecture/#security-configuration","title":"Security &amp; Configuration","text":"<ul> <li>Path Validation: Canonical path resolution with allowlist/denylist patterns</li> <li>Approval Workflows: Human-in-the-loop confirmation for write operations</li> <li>Configuration: TOML-based security policies and operational settings</li> </ul>"},{"location":"servers/filesystem/architecture/#system-architecture","title":"System Architecture","text":"<pre><code>\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502                    Claude Desktop                           \u2502\n\u2502                   (MCP Client)                              \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                      \u2502 STDIO Transport\n                      \u2502 JSON-RPC 2.0 Messages\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25bc\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502                  AIRS MCP-FS                                \u2502\n\u2502                  (MCP Server)                               \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502  Security Layer                                             \u2502\n\u2502  \u251c\u2500 Binary File Restriction (First Layer of Defense)        \u2502\n\u2502  \u251c\u2500 Path Validation &amp; Access Control                        \u2502\n\u2502  \u251c\u2500 Human-in-the-Loop Approval Workflows                    \u2502\n\u2502  \u2514\u2500 Operation Audit Logging                                 \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502  Tool Layer                                                 \u2502\n\u2502  \u251c\u2500 read_file, write_file, list_directory                   \u2502\n\u2502  \u251c\u2500 create_directory, delete_file, move_file                \u2502\n\u2502  \u2514\u2500 Text-only file operations (binary files rejected)       \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502  Text Processing Engine                                     \u2502\n\u2502  \u251c\u2500 Source Code Processing (Rust, Python, JavaScript, etc.) \u2502\n\u2502  \u251c\u2500 Configuration File Processing (TOML, JSON, YAML, etc.)  \u2502\n\u2502  \u251c\u2500 Documentation Processing (Markdown, Text, etc.)         \u2502\n\u2502  \u2514\u2500 Streaming Support for Large Text Files                  \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502  Filesystem Abstraction                                     \u2502\n\u2502  \u251c\u2500 Cross-Platform Path Handling                            \u2502\n\u2502  \u251c\u2500 Efficient I/O with Memory Management                    \u2502\n\u2502  \u2514\u2500 File Watching &amp; Change Detection                        \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                      \u2502\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25bc\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502                Local Filesystem                             \u2502\n\u2502           (User's Development Environment)                  \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"servers/filesystem/features/","title":"Core Features &amp; Capabilities","text":""},{"location":"servers/filesystem/features/#1-fundamental-filesystem-operations","title":"1. Fundamental Filesystem Operations","text":""},{"location":"servers/filesystem/features/#file-operations","title":"File Operations","text":"<pre><code>// Read text and binary files with intelligent encoding\nread_file(path: String, encoding: Option&lt;String&gt;) -&gt; FileContent\n\n// Write files with human approval workflow\nwrite_file(path: String, content: String, create_directories: bool) -&gt; WriteResult\n\n// Atomic file operations for safety\nmove_file(source: String, destination: String) -&gt; MoveResult\ncopy_file(source: String, destination: String) -&gt; CopyResult\ndelete_file(path: String) -&gt; DeleteResult\n</code></pre>"},{"location":"servers/filesystem/features/#directory-operations","title":"Directory Operations","text":"<pre><code>// Efficient directory listing with metadata\nlist_directory(path: String, recursive: bool, include_hidden: bool) -&gt; DirectoryListing\n\n// Directory management with permission checking\ncreate_directory(path: String, recursive: bool) -&gt; CreateResult\ndelete_directory(path: String, recursive: bool) -&gt; DeleteResult\n</code></pre>"},{"location":"servers/filesystem/features/#2-security-first-file-processing","title":"2. Security-First File Processing","text":""},{"location":"servers/filesystem/features/#binary-file-restriction","title":"Binary File Restriction","text":"<ul> <li>Complete Binary Blocking: All binary file operations are disabled for maximum security</li> <li>Text-Only Processing: Focus on development files like source code, configuration, and documentation</li> <li>Attack Surface Reduction: Eliminates entire classes of binary-based security vulnerabilities</li> <li>Memory Safety: Prevents buffer overflows and memory corruption from binary parsing</li> <li>Malware Prevention: Blocks execution of potentially malicious binary content</li> </ul>"},{"location":"servers/filesystem/features/#supported-text-file-types","title":"Supported Text File Types","text":"<ul> <li>Source Code: <code>.rs</code>, <code>.py</code>, <code>.js</code>, <code>.ts</code>, <code>.java</code>, <code>.cpp</code>, <code>.c</code>, <code>.go</code>, etc.</li> <li>Configuration: <code>.toml</code>, <code>.json</code>, <code>.yaml</code>, <code>.yml</code>, <code>.ini</code>, <code>.conf</code>, etc.</li> <li>Documentation: <code>.md</code>, <code>.txt</code>, <code>.rst</code>, <code>.adoc</code>, <code>.tex</code>, etc.</li> <li>Data Files: <code>.csv</code>, <code>.log</code>, <code>.sql</code>, <code>.xml</code>, <code>.html</code>, etc.</li> <li>Web Files: <code>.css</code>, <code>.scss</code>, <code>.less</code>, <code>.vue</code>, <code>.svelte</code>, etc.</li> </ul>"},{"location":"servers/filesystem/features/#binary-file-detection","title":"Binary File Detection","text":"<ul> <li>Extension-Based Validation: Comprehensive list of known binary extensions</li> <li>Content-Based Detection: Analysis of file content to identify binary data</li> <li>Magic Number Recognition: Detection of binary file signatures</li> <li>Audit Logging: Comprehensive logging of all binary file rejection events</li> </ul>"},{"location":"servers/filesystem/features/#3-security-access-control","title":"3. Security &amp; Access Control","text":""},{"location":"servers/filesystem/features/#multi-layer-security-architecture","title":"Multi-Layer Security Architecture","text":"<pre><code>// Configuration-driven security policies\nSecurityPolicy {\n    allowed_read_paths: Vec&lt;PathBuf&gt;,\n    allowed_write_paths: Vec&lt;PathBuf&gt;,\n    forbidden_patterns: Vec&lt;Regex&gt;,\n    max_file_size_mb: u64,\n    require_approval_for_writes: bool,\n    require_approval_for_deletes: bool,\n}\n</code></pre>"},{"location":"servers/filesystem/features/#human-in-the-loop-workflows","title":"Human-in-the-Loop Workflows","text":"<ul> <li>Write Operation Approval: Interactive confirmation for file creation/modification</li> <li>Dangerous Operation Protection: Special approval for deletions, moves, executable files</li> <li>Path Validation: Prevent directory traversal and unauthorized access</li> <li>Operation Auditing: Comprehensive logging of all filesystem interactions</li> </ul>"},{"location":"servers/filesystem/features/#risk-based-controls","title":"Risk-Based Controls","text":"<ul> <li>File Type Restrictions: Configurable policies for different file types</li> <li>Size Limitations: Prevent resource exhaustion from large file operations</li> <li>Rate Limiting: Prevent abuse through excessive operation requests</li> <li>Quarantine Mode: Safe handling of potentially dangerous files</li> </ul>"},{"location":"servers/filesystem/installation/","title":"Installation","text":"<p>Complete installation instructions for the AIRS MCP Filesystem Server.</p>"},{"location":"servers/filesystem/installation/#system-requirements","title":"System Requirements","text":"<ul> <li>Rust: Version 1.88.0 or later</li> <li>Operating System: macOS, Linux, or Windows</li> <li>Disk Space: ~50MB for binary and dependencies</li> <li>Claude Desktop: Latest version (optional, for Claude integration)</li> </ul>"},{"location":"servers/filesystem/installation/#installation-methods","title":"Installation Methods","text":""},{"location":"servers/filesystem/installation/#method-1-from-cratesio-recommended","title":"Method 1: From crates.io (Recommended)","text":"<p>The simplest way to install:</p> <pre><code>cargo install airsprotocols-mcpserver-filesystem\n</code></pre> <p>The binary will be installed to <code>~/.cargo/bin/airsprotocols-mcpserver-filesystem</code>.</p>"},{"location":"servers/filesystem/installation/#method-2-from-source","title":"Method 2: From Source","text":"<p>For the latest development version:</p> <pre><code># Clone the repository\ngit clone https://github.com/airsstack/airsprotocols.git\ncd airsprotocols\n\n# Build and install\ncargo install --path mcp/servers/filesystem\n</code></pre>"},{"location":"servers/filesystem/installation/#method-3-pre-built-binaries","title":"Method 3: Pre-built Binaries","text":"<p>Download pre-built binaries from the releases page.</p>"},{"location":"servers/filesystem/installation/#verification","title":"Verification","text":"<p>Verify the installation:</p> <pre><code>airsprotocols-mcpserver-filesystem --version\n</code></pre> <p>Expected output: <pre><code>airsprotocols-mcpserver-filesystem 1.0.0-rc.1\n</code></pre></p>"},{"location":"servers/filesystem/installation/#post-installation-setup","title":"Post-Installation Setup","text":""},{"location":"servers/filesystem/installation/#1-create-directory-structure","title":"1. Create Directory Structure","text":"<pre><code>airsprotocols-mcpserver-filesystem setup\n</code></pre> <p>This creates: - Configuration directory: <code>~/.config/airsprotocols-mcpserver-filesystem/</code> - Log directory: <code>~/.local/share/airsprotocols-mcpserver-filesystem/logs/</code></p>"},{"location":"servers/filesystem/installation/#2-generate-initial-configuration","title":"2. Generate Initial Configuration","text":"<pre><code>airsprotocols-mcpserver-filesystem config --env development\n</code></pre> <p>This generates <code>~/.config/airsprotocols-mcpserver-filesystem/development.toml</code> with sensible defaults.</p>"},{"location":"servers/filesystem/installation/#integration-with-claude-desktop","title":"Integration with Claude Desktop","text":"<p>See the Quick Start Guide for Claude Desktop integration instructions.</p>"},{"location":"servers/filesystem/installation/#updating","title":"Updating","text":"<p>To update to the latest version:</p> <pre><code>cargo install airsprotocols-mcpserver-filesystem --force\n</code></pre>"},{"location":"servers/filesystem/installation/#uninstallation","title":"Uninstallation","text":"<p>To remove the server:</p> <pre><code>cargo uninstall airsprotocols-mcpserver-filesystem\n\n# Optionally remove configuration and logs\nrm -rf ~/.config/airsprotocols-mcpserver-filesystem\nrm -rf ~/.local/share/airsprotocols-mcpserver-filesystem\n</code></pre>"},{"location":"servers/filesystem/installation/#troubleshooting","title":"Troubleshooting","text":""},{"location":"servers/filesystem/installation/#cargo-command-not-found","title":"\"cargo: command not found\"","text":"<p>Install Rust: <pre><code>curl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.sh | sh\n</code></pre></p>"},{"location":"servers/filesystem/installation/#failed-to-compile","title":"\"failed to compile\"","text":"<p>Ensure you have the latest Rust version: <pre><code>rustup update stable\n</code></pre></p>"},{"location":"servers/filesystem/installation/#binary-not-in-path","title":"Binary not in PATH","text":"<p>Add cargo bin directory to PATH: <pre><code># Add to ~/.bashrc or ~/.zshrc\nexport PATH=\"$HOME/.cargo/bin:$PATH\"\n</code></pre></p>"},{"location":"servers/filesystem/installation/#next-steps","title":"Next Steps","text":"<ul> <li>Quick Start Guide: Get running in 5 minutes</li> <li>Configuration: Customize your setup</li> <li>Usage Examples: Learn common patterns</li> </ul>"},{"location":"servers/filesystem/overview/","title":"AIRS MCP Server - Filesystem: Intelligent Filesystem Bridge for AI-Assisted Development","text":""},{"location":"servers/filesystem/overview/#overview","title":"Overview","text":"<p>AIRS MCP Server - Filesystem is a security-first filesystem bridge that enables Claude Desktop and other MCP-compatible AI tools to intelligently read, write, and manage files in local development environments. The tool transforms AI assistance from passive consultation to active collaboration, where AI agents can both understand project context and create tangible artifacts.</p> <p>Core Value Proposition: Bridge the gap between cloud-based AI intelligence and local development workflows through standardized, secure filesystem operations.</p> <p>Key Innovation: Advanced binary file support with intelligent format detection, enabling multimodal AI interactions with images, PDFs, and other binary content through the MCP protocol.</p>"},{"location":"servers/filesystem/overview/#project-vision-objectives","title":"Project Vision &amp; Objectives","text":""},{"location":"servers/filesystem/overview/#primary-vision","title":"Primary Vision","text":"<p>Create the foundational filesystem layer for AI-assisted development, enabling seamless bidirectional interaction between AI agents and local development environments while maintaining enterprise-grade security and performance.</p>"},{"location":"servers/filesystem/overview/#strategic-objectives","title":"Strategic Objectives","text":"<ol> <li>Universal Filesystem Access: Provide standardized MCP interface for all filesystem operations</li> <li>Security-First Design: Human-in-the-loop approval workflows with configurable security policies</li> <li>Advanced Binary Support: Industry-leading binary file handling through intelligent encoding and processing</li> <li>Performance Excellence: Sub-second response times with efficient memory management for large files</li> <li>AIRS Ecosystem Integration: Natural integration with existing AIRS MCP infrastructure</li> </ol>"},{"location":"servers/filesystem/overview/#code-standards","title":"Code Standards","text":"<ul> <li>Follow Rust API guidelines</li> <li>Write comprehensive tests</li> <li>Document public APIs</li> <li>Follow security best practices</li> </ul>"},{"location":"servers/filesystem/overview/#risk-analysis-mitigation","title":"Risk Analysis &amp; Mitigation","text":""},{"location":"servers/filesystem/overview/#technical-risks","title":"Technical Risks","text":""},{"location":"servers/filesystem/overview/#risk-security-vulnerabilities","title":"Risk: Security Vulnerabilities","text":"<ul> <li>Probability: Medium</li> <li>Impact: High</li> <li>Mitigation: </li> <li>Comprehensive security testing</li> <li>Regular security audits</li> <li>Bug bounty program</li> <li>Responsible disclosure process</li> </ul>"},{"location":"servers/filesystem/overview/#risk-performance-issues-with-large-files","title":"Risk: Performance Issues with Large Files","text":"<ul> <li>Probability: Medium</li> <li>Impact: Medium</li> <li>Mitigation:</li> <li>Streaming architecture for large files</li> <li>Configurable resource limits</li> <li>Performance monitoring and alerting</li> <li>Optimization based on usage patterns</li> </ul>"},{"location":"servers/filesystem/overview/#risk-mcp-protocol-evolution","title":"Risk: MCP Protocol Evolution","text":"<ul> <li>Probability: Low</li> <li>Impact: Medium</li> <li>Mitigation:</li> <li>Close monitoring of MCP specification changes</li> <li>Modular architecture for easy protocol updates</li> <li>Version compatibility layers</li> <li>Early adoption of new MCP features</li> </ul>"},{"location":"servers/filesystem/overview/#conclusion","title":"Conclusion","text":"<p>AIRS MCP-FS represents a transformative opportunity to bridge the gap between AI intelligence and local development environments. By combining the standardization benefits of the MCP protocol with advanced filesystem capabilities and sophisticated binary processing, this tool positions itself as an essential component of the next generation of AI-assisted development workflows.</p>"},{"location":"servers/filesystem/overview/#key-strategic-advantages","title":"Key Strategic Advantages","text":"<ol> <li>First-Mover Advantage: Early entry into the MCP filesystem tool market</li> <li>Technical Moat: Advanced binary processing capabilities and Rust performance</li> <li>Security Leadership: Enterprise-grade security with human-in-the-loop workflows</li> <li>Ecosystem Integration: Natural fit within the growing AIRS platform</li> </ol>"},{"location":"servers/filesystem/overview/#implementation-confidence","title":"Implementation Confidence","text":"<p>The technical architecture is sound, the market opportunity is significant, and the implementation path is clear. The combination of existing AIRS MCP expertise with the growing demand for AI development tools creates a compelling business case.</p>"},{"location":"servers/filesystem/performance/","title":"Performance &amp; Scalability","text":""},{"location":"servers/filesystem/performance/#performance-targets","title":"Performance Targets","text":"<ul> <li>Response Time: &lt;100ms for typical file operations</li> <li>Large File Handling: Support files up to 1GB with streaming</li> <li>Concurrent Operations: Handle 10+ concurrent file operations</li> <li>Memory Usage: &lt;50MB baseline memory footprint</li> </ul>"},{"location":"servers/filesystem/performance/#optimization-strategies","title":"Optimization Strategies","text":""},{"location":"servers/filesystem/performance/#memory-management","title":"Memory Management","text":"<pre><code>// Streaming for large files\nconst CHUNK_SIZE: usize = 1024 * 1024; // 1MB chunks\nconst MAX_MEMORY_LOAD: u64 = 10 * 1024 * 1024; // 10MB\n\nasync fn read_large_file_streamed(&amp;self, path: &amp;Path) -&gt; Result&lt;FileStream, FsError&gt; {\n    let file = tokio::fs::File::open(path).await?;\n    let file_size = file.metadata().await?.len();\n\n    if file_size &gt; MAX_MEMORY_LOAD {\n        Ok(FileStream::chunked(file, CHUNK_SIZE))\n    } else {\n        Ok(FileStream::direct(file))\n    }\n}\n</code></pre>"},{"location":"servers/filesystem/performance/#caching-strategy","title":"Caching Strategy","text":"<pre><code>pub struct FileCache {\n    metadata_cache: LruCache&lt;PathBuf, FileMetadata&gt;,\n    content_cache: LruCache&lt;PathBuf, CachedContent&gt;,\n    // Binary caching removed for security - text-only processing\n}\n\nimpl FileCache {\n    async fn get_or_compute_metadata(&amp;mut self, path: &amp;Path) -&gt; Result&lt;FileMetadata, FsError&gt; {\n        if let Some(cached) = self.metadata_cache.get(path) {\n            if !cached.is_stale() {\n                return Ok(cached.clone());\n            }\n        }\n\n        let metadata = self.compute_metadata(path).await?;\n        self.metadata_cache.put(path.to_path_buf(), metadata.clone());\n        Ok(metadata)\n    }\n}\n</code></pre>"},{"location":"servers/filesystem/performance/#scalability-considerations","title":"Scalability Considerations","text":"<ul> <li>Async-First Design: All I/O operations are non-blocking</li> <li>Resource Limits: Configurable limits prevent resource exhaustion</li> <li>Connection Pooling: Efficient handling of multiple MCP clients</li> <li>Background Processing: Heavy operations run in background tasks</li> </ul>"},{"location":"servers/filesystem/quick-start/","title":"Quick Start Guide","text":"<p>Get up and running with AIRS MCP Server - Filesystem in under 5 minutes.</p>"},{"location":"servers/filesystem/quick-start/#prerequisites","title":"Prerequisites","text":"<ul> <li>Rust: Version 1.88.0 or later</li> <li>Claude Desktop: Latest version with MCP support</li> <li>Operating System: macOS, Linux, or Windows</li> </ul>"},{"location":"servers/filesystem/quick-start/#installation","title":"Installation","text":""},{"location":"servers/filesystem/quick-start/#option-1-from-source-recommended","title":"Option 1: From Source (Recommended)","text":"<pre><code># Clone the repository\ngit clone https://github.com/airsstack/airsprotocols.git\ncd airsstack\n\n# Build the binary\ncargo build --release --bin airsprotocols-mcpserver-filesystem\n\n# The binary will be at: target/release/airsprotocols-mcpserver-filesystem\n</code></pre>"},{"location":"servers/filesystem/quick-start/#option-2-using-cargo","title":"Option 2: Using Cargo","text":"<pre><code>cargo install --path mcp-servers/airsprotocols-mcpserver-filesystem\n</code></pre>"},{"location":"servers/filesystem/quick-start/#basic-setup","title":"Basic Setup","text":""},{"location":"servers/filesystem/quick-start/#step-1-generate-configuration","title":"Step 1: Generate Configuration","text":"<pre><code># Generate development configuration\nairsprotocols-mcpserver-filesystem generate-config\n\n# This creates ~/.config/airsprotocols-mcpserver-filesystem/development.toml\n</code></pre>"},{"location":"servers/filesystem/quick-start/#step-2-configure-claude-desktop","title":"Step 2: Configure Claude Desktop","text":"<p>Add to your Claude Desktop MCP configuration (<code>~/Library/Application Support/Claude/claude_desktop_config.json</code> on macOS):</p> <pre><code>{\n  \"mcpServers\": {\n    \"airsprotocols-mcpserver-filesystem\": {\n      \"command\": \"/path/to/airsprotocols-mcpserver-filesystem\",\n      \"env\": {\n        \"AIRSPROTOCOLS_MCPSERVER_FS_ENV\": \"development\",\n        \"AIRSPROTOCOLS_MCPSERVER_FS_CONFIG_DIR\": \"/Users/yourusername/.config/airsprotocols-mcpserver-filesystem\",\n        \"AIRSPROTOCOLS_MCPSERVER_FS_LOG_DIR\": \"/Users/yourusername/.local/share/airsprotocols-mcpserver-filesystem/logs\"\n      }\n    }\n  }\n}\n</code></pre> <p>Important: Replace <code>/path/to/airsprotocols-mcpserver-filesystem</code> with the actual path to your binary and <code>yourusername</code> with your actual username.</p>"},{"location":"servers/filesystem/quick-start/#step-3-restart-claude-desktop","title":"Step 3: Restart Claude Desktop","text":"<p>Restart Claude Desktop to load the new MCP server configuration.</p>"},{"location":"servers/filesystem/quick-start/#test-your-setup","title":"Test Your Setup","text":"<p>Once Claude Desktop restarts, try these commands:</p> <pre><code>User: \"List the files in my Documents directory\"\nClaude: *uses list_directory tool* \u2192 shows your Documents contents\n\nUser: \"Read my project's README.md file\"\nClaude: *uses read_file tool* \u2192 displays the README content\n\nUser: \"Create a new file called hello.txt with 'Hello World' in my Documents\"\nClaude: *uses write_file tool* \u2192 creates the file with approval prompt\n</code></pre>"},{"location":"servers/filesystem/quick-start/#common-issues","title":"Common Issues","text":""},{"location":"servers/filesystem/quick-start/#permission-denied-errors","title":"\"Permission Denied\" Errors","text":"<ul> <li>Cause: Path not in allowed_paths configuration</li> <li>Solution: Edit your configuration file to include the required paths</li> </ul>"},{"location":"servers/filesystem/quick-start/#security-validation-failed","title":"\"Security validation failed\"","text":"<ul> <li>Cause: File pattern not matching security policies</li> <li>Solution: Check glob patterns in your configuration file</li> </ul>"},{"location":"servers/filesystem/quick-start/#invalid-server-response","title":"\"Invalid server response\"","text":"<ul> <li>Cause: Environment variables not set correctly</li> <li>Solution: Verify AIRSPROTOCOLS_MCPSERVER_FS_ENV and config directory paths</li> </ul>"},{"location":"servers/filesystem/quick-start/#next-steps","title":"Next Steps","text":"<ul> <li>Configuration Guide: Customize security policies and file access</li> <li>Security Policies: Understand the security model</li> <li>Claude Desktop Integration: Advanced integration options</li> <li>Troubleshooting: Solve common problems</li> </ul> <p>For development work, your configuration should include your project directories:</p> <pre><code># ~/.config/airsprotocols-mcpserver-filesystem/development.toml\n[security.filesystem]\nallowed_paths = [\n    \"~/projects/**/*\",           # All your projects\n    \"~/Documents/**/*\",          # Documents directory\n    \"~/Desktop/**/*\",            # Desktop files\n    \"./**/*\"                     # Current directory when running from project\n]\n\n[security.operations]\nread_allowed = true\nwrite_requires_policy = false    # Allow writes in development\ndelete_requires_explicit_allow = true\n\n# Named policies for different file types\n[security.policies.journal_files]\npatterns = [\"/Users/yourusername/Documents/**/*\"]\noperations = [\"read\", \"write\", \"list\"]\nrisk_level = \"low\"\ndescription = \"Personal journal and document files\"\n</code></pre> <p>This configuration allows Claude to work with your development files while maintaining reasonable security boundaries.</p>"},{"location":"servers/filesystem/configuration/","title":"Configuration Guide","text":"<p>AIRS MCP-FS uses a sophisticated multi-layered configuration system that balances security, flexibility, and ease of use. This guide covers everything from basic setup to advanced security policies.</p>"},{"location":"servers/filesystem/configuration/#configuration-architecture","title":"Configuration Architecture","text":"<p>The configuration system follows a hierarchical approach:</p> <pre><code>Environment Detection \u2192 Base Configuration \u2192 Policy Application \u2192 Environment Variable Overrides\n</code></pre>"},{"location":"servers/filesystem/configuration/#key-components","title":"Key Components","text":"<ol> <li>Security Policies: Named policies for different file types and use cases</li> <li>Path Validation: Glob pattern-based path allowlists and denylists</li> <li>Operation Controls: Fine-grained permissions for read/write/delete operations</li> <li>Binary File Restriction: Enhanced security through complete binary file blocking</li> </ol>"},{"location":"servers/filesystem/configuration/#configuration-file-locations","title":"Configuration File Locations","text":"<p>AIRS MCP-FS searches for configuration files in the following order:</p> <ol> <li>Environment Variable: <code>AIRSPROTOCOLS_MCPSERVER_FS_CONFIG_DIR</code></li> <li>User Config Directory: <code>~/.config/airsprotocols-mcpserver-filesystem/</code></li> <li>System Config Directory: <code>/etc/airsprotocols-mcpserver-filesystem/</code></li> <li>Built-in Defaults: Secure production defaults</li> </ol>"},{"location":"servers/filesystem/configuration/#environment-specific-files","title":"Environment-Specific Files","text":"<ul> <li><code>development.toml</code> - Development environment (permissive)</li> <li><code>staging.toml</code> - Staging environment (production-like)</li> <li><code>production.toml</code> - Production environment (secure)</li> <li><code>test.toml</code> - Testing environment (minimal)</li> </ul>"},{"location":"servers/filesystem/configuration/#basic-configuration-structure","title":"Basic Configuration Structure","text":"<pre><code># Security configuration\n[security.filesystem]\nallowed_paths = [\"~/projects/**/*\"]\ndenied_paths = [\"**/.env*\", \"**/secrets/**\"]\n\n[security.operations]\nread_allowed = true\nwrite_requires_policy = false\ndelete_requires_explicit_allow = true\n\n# Named security policies\n[security.policies.source_code]\npatterns = [\"**/*.{rs,py,js,ts}\"]\noperations = [\"read\", \"write\"]\nrisk_level = \"low\"\ndescription = \"Source code files\"\n\n# Security configuration (binary processing disabled)\n[security]\nbinary_processing_disabled = true\ntext_only_mode = true\nmax_file_size = 104857600  # 100MB for text files\n\n# Server configuration\n[server]\nname = \"airsprotocols-mcpserver-filesystem\"\nversion = \"1.0.0\"\n</code></pre>"},{"location":"servers/filesystem/configuration/#environment-variable-overrides","title":"Environment Variable Overrides","text":"<p>All configuration values can be overridden using environment variables with the <code>AIRSPROTOCOLS_MCPSERVER_FS_</code> prefix:</p> Environment Variable Configuration Path Example <code>AIRSPROTOCOLS_MCPSERVER_FS_ENV</code> Environment type <code>development</code> <code>AIRSPROTOCOLS_MCPSERVER_FS_CONFIG_DIR</code> Config directory <code>~/.config/airsprotocols-mcpserver-filesystem</code> <code>AIRSPROTOCOLS_MCPSERVER_FS_LOG_DIR</code> Log directory <code>~/.local/share/airsprotocols-mcpserver-filesystem/logs</code> <code>AIRSPROTOCOLS_MCPSERVER_FS_SECURITY_FILESYSTEM_ALLOWED_PATHS</code> Filesystem allowed paths <code>~/projects/**/*,~/docs/**/*</code> <code>AIRSPROTOCOLS_MCPSERVER_FS_SECURITY_MAX_FILE_SIZE</code> Max file size <code>52428800</code> (50MB)"},{"location":"servers/filesystem/configuration/#security-modes","title":"Security Modes","text":"<p>AIRS MCP-FS provides three pre-configured security modes:</p>"},{"location":"servers/filesystem/configuration/#production-mode-default","title":"Production Mode (Default)","text":"<ul> <li>Secure by default: Minimal permissions</li> <li>Explicit policies: All operations require policy matches</li> <li>Audit logging: Comprehensive operation tracking</li> <li>Path restrictions: Limited to safe directories</li> </ul> <pre><code>[security.operations]\nread_allowed = true\nwrite_requires_policy = true\ndelete_requires_explicit_allow = true\n</code></pre>"},{"location":"servers/filesystem/configuration/#development-mode","title":"Development Mode","text":"<ul> <li>Balanced security: Reasonable for development work</li> <li>Broader access: More directories allowed</li> <li>Relaxed writes: Writes allowed without strict policies</li> <li>Safety nets: Delete operations still require explicit permission</li> </ul> <pre><code>[security.filesystem]\nallowed_paths = [\n    \"~/projects/**/*\",\n    \"~/Documents/**/*\", \n    \"./**/*\"\n]\n\n[security.operations]\nwrite_requires_policy = false\n</code></pre>"},{"location":"servers/filesystem/configuration/#permissive-mode","title":"Permissive Mode","text":"<ul> <li>Minimal restrictions: Suitable for testing</li> <li>Universal access: All operations allowed</li> <li>Testing focus: Optimized for development testing</li> <li>Not recommended: For production environments</li> </ul> <pre><code>[security.policies.permissive_universal]\npatterns = [\"**/*\"]\noperations = [\"read\", \"write\", \"delete\", \"list\", \"create_dir\"]\nrisk_level = \"low\"\n</code></pre>"},{"location":"servers/filesystem/configuration/#quick-configuration-examples","title":"Quick Configuration Examples","text":""},{"location":"servers/filesystem/configuration/#development-workstation","title":"Development Workstation","text":"<pre><code># ~/.config/airsprotocols-mcpserver-filesystem/development.toml\n[security.filesystem]\nallowed_paths = [\n    \"~/projects/**/*\",\n    \"~/Documents/**/*\",\n    \"~/Desktop/**/*\",\n    \"./**/*\"\n]\n\ndenied_paths = [\n    \"**/.git/**\",\n    \"**/.env*\",\n    \"~/.*/**\"\n]\n\n[security.operations]\nread_allowed = true\nwrite_requires_policy = false\ndelete_requires_explicit_allow = true\n\n[security.policies.journal_files]\npatterns = [\"/Users/yourusername/Documents/**/*\"]\noperations = [\"read\", \"write\", \"list\"]\nrisk_level = \"low\"\n</code></pre>"},{"location":"servers/filesystem/configuration/#content-creation-setup","title":"Content Creation Setup","text":"<pre><code>[security.policies.content_creation]\npatterns = [\n    \"~/content/**/*.{md,txt}\",\n    \"~/blog/**/*\",\n    \"~/docs/**/*\"\n]\noperations = [\"read\", \"write\", \"create_dir\"]\nrisk_level = \"low\"\ndescription = \"Content creation and blogging files\"\n\n[security]\n# Binary processing disabled for security\nbinary_processing_disabled = true\ntext_only_mode = true\nmax_file_size = 209715200  # 200MB for large text files\n</code></pre>"},{"location":"servers/filesystem/configuration/#secure-production-environment","title":"Secure Production Environment","text":"<pre><code>[security.filesystem]\nallowed_paths = [\n    \"/app/data/**/*\",\n    \"/app/config/*.json\"\n]\n\ndenied_paths = [\n    \"/app/secrets/**\",\n    \"**/.*/**\",\n    \"**/*.key\"\n]\n\n[security.operations]\nread_allowed = true\nwrite_requires_policy = true\ndelete_requires_explicit_allow = true\n\n[security.policies.app_data]\npatterns = [\"/app/data/**/*.json\"]\noperations = [\"read\", \"write\"]\nrisk_level = \"medium\"\n</code></pre>"},{"location":"servers/filesystem/configuration/#advanced-topics","title":"Advanced Topics","text":"<ul> <li>Environment Setup: Environment detection and variable configuration</li> <li>Security Policies: Detailed security policy configuration</li> <li>Claude Desktop Integration: MCP client configuration</li> <li>Troubleshooting: Common configuration issues and solutions</li> </ul>"},{"location":"servers/filesystem/configuration/#best-practices","title":"Best Practices","text":""},{"location":"servers/filesystem/configuration/#path-configuration","title":"Path Configuration","text":"<ul> <li>Use absolute paths when possible for clarity</li> <li>Prefer specific patterns over broad wildcards</li> <li>Test path patterns before deploying to production</li> <li>Regularly review and audit allowed paths</li> </ul>"},{"location":"servers/filesystem/configuration/#security-policies","title":"Security Policies","text":"<ul> <li>Create named policies for different file types</li> <li>Use appropriate risk levels for audit logging</li> <li>Document policy purposes with descriptions</li> <li>Regular policy reviews and updates</li> </ul>"},{"location":"servers/filesystem/configuration/#environment-management","title":"Environment Management","text":"<ul> <li>Use environment-specific configuration files</li> <li>Leverage environment variables for sensitive values</li> <li>Implement proper configuration validation</li> <li>Maintain configuration documentation</li> </ul>"},{"location":"servers/filesystem/configuration/#next-steps","title":"Next Steps","text":"<p>Once you understand the configuration basics, explore specific configuration areas:</p> <ol> <li>Environment Setup - Environment detection and management</li> <li>Security Policies - Advanced security configuration</li> <li>Claude Desktop Integration - MCP client setup</li> <li>Troubleshooting - Solving configuration problems</li> </ol>"},{"location":"servers/filesystem/configuration/claude-desktop/","title":"Claude Desktop Integration","text":"<p>This section covers comprehensive integration of AIRS MCP-FS with Claude Desktop, including configuration, troubleshooting, and advanced usage patterns.</p>"},{"location":"servers/filesystem/configuration/claude-desktop/#mcp-server-configuration","title":"MCP Server Configuration","text":"<p>Claude Desktop uses JSON configuration to define MCP servers. AIRS MCP-FS integrates as a standard MCP server with additional environment variable support.</p>"},{"location":"servers/filesystem/configuration/claude-desktop/#basic-configuration","title":"Basic Configuration","text":"<p>Add AIRS MCP-FS to your Claude Desktop configuration file:</p> <p>macOS: <code>~/Library/Application Support/Claude/claude_desktop_config.json</code> Windows: <code>%APPDATA%\\Claude\\claude_desktop_config.json</code> Linux: <code>~/.config/claude/claude_desktop_config.json</code></p> <pre><code>{\n  \"mcpServers\": {\n    \"airsprotocols-mcpserver-filesystem\": {\n      \"command\": \"/path/to/airsprotocols-mcpserver-filesystem\",\n      \"env\": {\n        \"AIRS_MCP_FS_ENV\": \"development\"\n      }\n    }\n  }\n}\n</code></pre>"},{"location":"servers/filesystem/configuration/claude-desktop/#complete-configuration","title":"Complete Configuration","text":"<p>For full control over AIRS MCP-FS behavior:</p> <pre><code>{\n  \"mcpServers\": {\n    \"airsprotocols-mcpserver-filesystem\": {\n      \"command\": \"/Users/username/path/to/airsprotocols-mcpserver-filesystem\",\n      \"env\": {\n        \"AIRS_MCP_FS_ENV\": \"development\",\n        \"AIRS_MCP_FS_CONFIG_DIR\": \"/Users/username/.config/airsprotocols-mcpserver-filesystem\",\n        \"AIRS_MCP_FS_LOG_DIR\": \"/Users/username/.local/share/airsprotocols-mcpserver-filesystem/logs\",\n        \"RUST_LOG\": \"info\"\n      }\n    }\n  }\n}\n</code></pre>"},{"location":"servers/filesystem/configuration/claude-desktop/#environment-variable-configuration","title":"Environment Variable Configuration","text":"<p>AIRS MCP-FS behavior is controlled through environment variables in the Claude Desktop configuration:</p>"},{"location":"servers/filesystem/configuration/claude-desktop/#core-environment-variables","title":"Core Environment Variables","text":"Variable Purpose Example Required <code>AIRS_MCP_FS_ENV</code> Environment type <code>development</code> Yes <code>AIRS_MCP_FS_CONFIG_DIR</code> Configuration directory <code>~/.config/airsprotocols-mcpserver-filesystem</code> Recommended <code>AIRS_MCP_FS_LOG_DIR</code> Log output directory <code>~/.local/share/airsprotocols-mcpserver-filesystem/logs</code> Recommended <code>RUST_LOG</code> Logging level <code>info</code>, <code>debug</code> Optional"},{"location":"servers/filesystem/configuration/claude-desktop/#security-override-variables","title":"Security Override Variables","text":"Variable Purpose Example <code>AIRS_MCP_FS_SECURITY_FILESYSTEM_ALLOWED_PATHS</code> Override allowed paths <code>~/projects/**/*,~/docs/**/*</code> <code>AIRS_MCP_FS_SECURITY_OPERATIONS_WRITE_REQUIRES_POLICY</code> Control write policy <code>false</code> <code>AIRS_MCP_FS_BINARY_MAX_FILE_SIZE</code> Max file size <code>52428800</code> (50MB)"},{"location":"servers/filesystem/configuration/claude-desktop/#configuration-examples","title":"Configuration Examples","text":""},{"location":"servers/filesystem/configuration/claude-desktop/#development-workstation","title":"Development Workstation","text":"<p>Ideal for local development with broad file access:</p> <pre><code>{\n  \"mcpServers\": {\n    \"airsprotocols-mcpserver-filesystem\": {\n      \"command\": \"/usr/local/bin/airsprotocols-mcpserver-filesystem\",\n      \"env\": {\n        \"AIRS_MCP_FS_ENV\": \"development\",\n        \"AIRS_MCP_FS_CONFIG_DIR\": \"/Users/developer/.config/airsprotocols-mcpserver-filesystem\",\n        \"AIRS_MCP_FS_LOG_DIR\": \"/Users/developer/.local/share/airsprotocols-mcpserver-filesystem/logs\",\n        \"AIRS_MCP_FS_SECURITY_FILESYSTEM_ALLOWED_PATHS\": \"/Users/developer/projects/**/*,/Users/developer/Documents/**/*,/Users/developer/Desktop/**/*\",\n        \"RUST_LOG\": \"info\"\n      }\n    }\n  }\n}\n</code></pre>"},{"location":"servers/filesystem/configuration/claude-desktop/#content-creation-setup","title":"Content Creation Setup","text":"<p>Optimized for writing, blogging, and content management:</p> <pre><code>{\n  \"mcpServers\": {\n    \"airsprotocols-mcpserver-filesystem\": {\n      \"command\": \"/usr/local/bin/airsprotocols-mcpserver-filesystem\",\n      \"env\": {\n        \"AIRS_MCP_FS_ENV\": \"development\",\n        \"AIRS_MCP_FS_CONFIG_DIR\": \"/Users/writer/.config/airsprotocols-mcpserver-filesystem\",\n        \"AIRS_MCP_FS_SECURITY_FILESYSTEM_ALLOWED_PATHS\": \"/Users/writer/writing/**/*,/Users/writer/blog/**/*,/Users/writer/assets/**/*\",\n        \"AIRS_MCP_FS_BINARY_ENABLE_IMAGE_PROCESSING\": \"true\",\n        \"AIRS_MCP_FS_BINARY_MAX_FILE_SIZE\": \"209715200\"\n      }\n    }\n  }\n}\n</code></pre>"},{"location":"servers/filesystem/configuration/claude-desktop/#secure-production-environment","title":"Secure Production Environment","text":"<p>Minimal permissions for production use:</p> <pre><code>{\n  \"mcpServers\": {\n    \"airsprotocols-mcpserver-filesystem\": {\n      \"command\": \"/opt/airsprotocols-mcpserver-filesystem/bin/airsprotocols-mcpserver-filesystem\",\n      \"env\": {\n        \"AIRS_MCP_FS_ENV\": \"production\",\n        \"AIRS_MCP_FS_CONFIG_DIR\": \"/etc/airsprotocols-mcpserver-filesystem\",\n        \"AIRS_MCP_FS_LOG_DIR\": \"/var/log/airsprotocols-mcpserver-filesystem\",\n        \"AIRS_MCP_FS_SECURITY_FILESYSTEM_ALLOWED_PATHS\": \"/app/data/**/*.json\",\n        \"AIRS_MCP_FS_SECURITY_OPERATIONS_WRITE_REQUIRES_POLICY\": \"true\",\n        \"RUST_LOG\": \"warn\"\n      }\n    }\n  }\n}\n</code></pre>"},{"location":"servers/filesystem/configuration/claude-desktop/#integration-workflow","title":"Integration Workflow","text":""},{"location":"servers/filesystem/configuration/claude-desktop/#initial-setup-process","title":"Initial Setup Process","text":"<ol> <li> <p>Install AIRS MCP-FS <pre><code>cargo build --release --bin airsprotocols-mcpserver-filesystem\n</code></pre></p> </li> <li> <p>Generate Configuration <pre><code>airsprotocols-mcpserver-filesystem generate-config --env development\n</code></pre></p> </li> <li> <p>Configure Claude Desktop <pre><code># Edit Claude Desktop configuration\nnano \"~/Library/Application Support/Claude/claude_desktop_config.json\"\n</code></pre></p> </li> <li> <p>Restart Claude Desktop</p> </li> <li>Quit Claude Desktop completely</li> <li> <p>Restart to load new MCP server configuration</p> </li> <li> <p>Verify Integration <pre><code>User: \"List the files in my current directory\"\nClaude: *uses list_directory tool* \u2192 shows directory contents\n</code></pre></p> </li> </ol>"},{"location":"servers/filesystem/configuration/claude-desktop/#configuration-validation","title":"Configuration Validation","text":"<p>After setup, validate your configuration:</p> <ol> <li> <p>Check Configuration Loading <pre><code># Run AIRS MCP-FS manually to check configuration\nAIRS_MCP_FS_ENV=development /path/to/airsprotocols-mcpserver-filesystem\n</code></pre></p> </li> <li> <p>Verify File Access <pre><code>User: \"Can you read my README.md file?\"\nClaude: *uses read_file tool* \u2192 displays README content\n</code></pre></p> </li> <li> <p>Test Security Policies <pre><code>User: \"Try to read a file in a restricted directory\"\nClaude: *attempts access* \u2192 should receive permission denied\n</code></pre></p> </li> </ol>"},{"location":"servers/filesystem/configuration/claude-desktop/#advanced-integration-patterns","title":"Advanced Integration Patterns","text":""},{"location":"servers/filesystem/configuration/claude-desktop/#multi-environment-setup","title":"Multi-Environment Setup","text":"<p>Configure different AIRS MCP-FS instances for different environments:</p> <pre><code>{\n  \"mcpServers\": {\n    \"airsprotocols-mcpserver-filesystem-dev\": {\n      \"command\": \"/usr/local/bin/airsprotocols-mcpserver-filesystem\",\n      \"env\": {\n        \"AIRS_MCP_FS_ENV\": \"development\",\n        \"AIRS_MCP_FS_CONFIG_DIR\": \"/Users/dev/.config/airsprotocols-mcpserver-filesystem-dev\"\n      }\n    },\n    \"airsprotocols-mcpserver-filesystem-prod\": {\n      \"command\": \"/usr/local/bin/airsprotocols-mcpserver-filesystem\",\n      \"env\": {\n        \"AIRS_MCP_FS_ENV\": \"production\",\n        \"AIRS_MCP_FS_CONFIG_DIR\": \"/Users/dev/.config/airsprotocols-mcpserver-filesystem-prod\"\n      }\n    }\n  }\n}\n</code></pre>"},{"location":"servers/filesystem/configuration/claude-desktop/#project-specific-configuration","title":"Project-Specific Configuration","text":"<p>Use different configurations for different projects:</p> <pre><code>{\n  \"mcpServers\": {\n    \"airsprotocols-mcpserver-filesystem-project-a\": {\n      \"command\": \"/usr/local/bin/airsprotocols-mcpserver-filesystem\",\n      \"env\": {\n        \"AIRS_MCP_FS_ENV\": \"development\",\n        \"AIRS_MCP_FS_SECURITY_FILESYSTEM_ALLOWED_PATHS\": \"/Users/dev/project-a/**/*\"\n      }\n    },\n    \"airsprotocols-mcpserver-filesystem-project-b\": {\n      \"command\": \"/usr/local/bin/airsprotocols-mcpserver-filesystem\", \n      \"env\": {\n        \"AIRS_MCP_FS_ENV\": \"development\",\n        \"AIRS_MCP_FS_SECURITY_FILESYSTEM_ALLOWED_PATHS\": \"/Users/dev/project-b/**/*\"\n      }\n    }\n  }\n}\n</code></pre>"},{"location":"servers/filesystem/configuration/claude-desktop/#mcp-tool-usage","title":"MCP Tool Usage","text":"<p>Once configured, Claude Desktop can use AIRS MCP-FS tools:</p>"},{"location":"servers/filesystem/configuration/claude-desktop/#available-tools","title":"Available Tools","text":"Tool Purpose Example Usage <code>read_file</code> Read file contents \"Read my package.json file\" <code>write_file</code> Create or update files \"Create a new component file\" <code>list_directory</code> Browse directories \"List files in my src directory\" <code>create_directory</code> Create directories \"Create a new folder structure\" <code>delete_file</code> Remove files \"Delete the old backup files\" <code>move_file</code> Move/rename files \"Rename this file to main.rs\" <code>copy_file</code> Copy files \"Make a backup copy of this file\""},{"location":"servers/filesystem/configuration/claude-desktop/#example-interactions","title":"Example Interactions","text":""},{"location":"servers/filesystem/configuration/claude-desktop/#reading-project-files","title":"Reading Project Files","text":"<pre><code>User: \"Analyze the structure of my Rust project\"\nClaude: *uses list_directory and read_file tools*\n\u2192 Examines Cargo.toml, src/ directory, and main source files\n\u2192 Provides comprehensive project analysis\n</code></pre>"},{"location":"servers/filesystem/configuration/claude-desktop/#creating-new-files","title":"Creating New Files","text":"<pre><code>User: \"Create a new React component for user authentication\"\nClaude: *uses write_file tool*\n\u2192 Creates src/components/AuthComponent.tsx\n\u2192 Includes proper TypeScript interfaces and React hooks\n</code></pre>"},{"location":"servers/filesystem/configuration/claude-desktop/#file-organization","title":"File Organization","text":"<pre><code>User: \"Organize my Downloads folder by file type\"\nClaude: *uses list_directory, create_directory, and move_file tools*\n\u2192 Creates folders by file type\n\u2192 Moves files into appropriate directories\n\u2192 Provides summary of organization\n</code></pre>"},{"location":"servers/filesystem/configuration/claude-desktop/#troubleshooting-integration","title":"Troubleshooting Integration","text":""},{"location":"servers/filesystem/configuration/claude-desktop/#common-integration-issues","title":"Common Integration Issues","text":""},{"location":"servers/filesystem/configuration/claude-desktop/#mcp-server-not-loading","title":"MCP Server Not Loading","text":"<p>Symptoms: Claude Desktop doesn't show filesystem tools available</p> <p>Solutions: 1. Check Binary Path <pre><code># Verify binary exists and is executable\nls -la /path/to/airsprotocols-mcpserver-filesystem\nchmod +x /path/to/airsprotocols-mcpserver-filesystem\n</code></pre></p> <ol> <li> <p>Validate JSON Configuration <pre><code># Check JSON syntax\ncat \"~/Library/Application Support/Claude/claude_desktop_config.json\" | python -m json.tool\n</code></pre></p> </li> <li> <p>Check Logs <pre><code># Check AIRS MCP-FS logs\ntail -f ~/.local/share/airsprotocols-mcpserver-filesystem/logs/airsprotocols-mcpserver-filesystem.log\n</code></pre></p> </li> </ol>"},{"location":"servers/filesystem/configuration/claude-desktop/#permission-denied-errors","title":"Permission Denied Errors","text":"<p>Symptoms: \"Security validation failed: Access denied\"</p> <p>Solutions: 1. Check Allowed Paths <pre><code># Verify path is in allowed_paths\n[security.filesystem]\nallowed_paths = [\"/Users/username/Documents/**/*\"]\n</code></pre></p> <ol> <li> <p>Check Glob Patterns <pre><code># Ensure patterns include both directory and contents\nallowed_paths = [\n    \"/Users/username/Documents\",      # Directory itself\n    \"/Users/username/Documents/**/*\"  # Directory contents\n]\n</code></pre></p> </li> <li> <p>Review Security Policies <pre><code># Check if operation is allowed by policy\n[security.policies.documents]\npatterns = [\"/Users/username/Documents/**/*\"]\noperations = [\"read\", \"write\", \"list\"]\n</code></pre></p> </li> </ol>"},{"location":"servers/filesystem/configuration/claude-desktop/#configuration-not-loading","title":"Configuration Not Loading","text":"<p>Symptoms: AIRS MCP-FS using default configuration instead of custom</p> <p>Solutions: 1. Verify Environment Variables <pre><code>{\n  \"env\": {\n    \"AIRS_MCP_FS_ENV\": \"development\",\n    \"AIRS_MCP_FS_CONFIG_DIR\": \"/correct/path/to/config\"\n  }\n}\n</code></pre></p> <ol> <li> <p>Check File Existence <pre><code># Verify configuration file exists\nls -la ~/.config/airsprotocols-mcpserver-filesystem/development.toml\n</code></pre></p> </li> <li> <p>Validate Configuration Syntax <pre><code># Test configuration loading\nAIRS_MCP_FS_ENV=development /path/to/airsprotocols-mcpserver-filesystem\n</code></pre></p> </li> </ol>"},{"location":"servers/filesystem/configuration/claude-desktop/#debug-mode","title":"Debug Mode","text":"<p>Enable debug logging for detailed troubleshooting:</p> <pre><code>{\n  \"mcpServers\": {\n    \"airsprotocols-mcpserver-filesystem\": {\n      \"command\": \"/usr/local/bin/airsprotocols-mcpserver-filesystem\",\n      \"env\": {\n        \"AIRS_MCP_FS_ENV\": \"development\",\n        \"RUST_LOG\": \"debug\"\n      }\n    }\n  }\n}\n</code></pre> <p>This provides detailed logging of: - Configuration loading process - Security validation decisions - MCP protocol communication - File operation execution</p>"},{"location":"servers/filesystem/configuration/claude-desktop/#integration-best-practices","title":"Integration Best Practices","text":""},{"location":"servers/filesystem/configuration/claude-desktop/#security-best-practices","title":"Security Best Practices","text":"<ol> <li>Environment-Specific Configuration: Use different configurations for different environments</li> <li>Minimal Permissions: Grant only necessary file access permissions</li> <li>Regular Updates: Keep AIRS MCP-FS updated for security fixes</li> <li>Audit Logging: Monitor file access patterns and unusual activity</li> </ol>"},{"location":"servers/filesystem/configuration/claude-desktop/#configuration-management","title":"Configuration Management","text":"<ol> <li>Version Control: Keep configuration files in version control</li> <li>Documentation: Document environment-specific settings</li> <li>Testing: Test configuration changes before deploying</li> <li>Backup: Maintain backup configurations for rollback</li> </ol>"},{"location":"servers/filesystem/configuration/claude-desktop/#performance-optimization","title":"Performance Optimization","text":"<ol> <li>Specific Paths: Use specific path patterns to reduce security checking overhead</li> <li>File Size Limits: Set appropriate file size limits for your use case</li> <li>Binary Processing: Disable unused binary processing features</li> <li>Log Levels: Use appropriate log levels (avoid debug in production)</li> </ol>"},{"location":"servers/filesystem/configuration/claude-desktop/#maintenance","title":"Maintenance","text":"<ol> <li>Regular Reviews: Periodically review and update configurations</li> <li>Log Monitoring: Monitor logs for errors and security issues</li> <li>Performance Monitoring: Track file operation performance</li> <li>Update Planning: Plan for AIRS MCP-FS updates and migrations</li> </ol>"},{"location":"servers/filesystem/configuration/claude-desktop/#related-sections","title":"Related Sections","text":"<ul> <li>Configuration Overview: Overall configuration architecture</li> <li>Environment Setup: Environment-specific configuration</li> <li>Security Policies: Security policy configuration</li> <li>Troubleshooting: Detailed troubleshooting guide</li> </ul>"},{"location":"servers/filesystem/configuration/deployment/","title":"Configuration &amp; Deployment","text":""},{"location":"servers/filesystem/configuration/deployment/#configuration-management","title":"Configuration Management","text":""},{"location":"servers/filesystem/configuration/deployment/#hierarchical-configuration-system","title":"Hierarchical Configuration System","text":"<pre><code># Global configuration: ~/.config/airsprotocols-mcpserver-filesystem/config.toml\n[server]\nname = \"airsprotocols-mcpserver-filesystem\"\nversion = \"1.0.0\"\ntransport = \"stdio\"\n\n[performance]\nmax_concurrent_operations = 10\ncache_size_mb = 50\ntemp_directory = \"/tmp/airsprotocols-mcpserver-filesystem\"\n\n[logging]\nlevel = \"info\"\nfile = \"~/.config/airsprotocols-mcpserver-filesystem/logs/airsprotocols-mcpserver-filesystem.log\"\nmax_size_mb = 100\nmax_files = 10\n\n# Project-specific configuration: ./.airsprotocols-mcpserver-filesystem.toml\n[project]\nname = \"my-awesome-project\"\nroot_path = \"./\"\nexclude_patterns = [\"node_modules/**\", \".git/**\", \"target/**\"]\n\n[security]\n# Override global security settings for this project\nallowed_write_paths = [\"./src/**\", \"./docs/**\", \"./tests/**\"]\nrequire_approval_for_writes = false  # Relaxed for development\n</code></pre>"},{"location":"servers/filesystem/configuration/deployment/#environment-based-configuration","title":"Environment-Based Configuration","text":"<pre><code>#[derive(Deserialize)]\npub struct FsConfig {\n    pub server: ServerConfig,\n    pub security: SecurityConfig,\n    pub performance: PerformanceConfig,\n    pub logging: LoggingConfig,\n    pub project: Option&lt;ProjectConfig&gt;,\n}\n\nimpl FsConfig {\n    pub fn load() -&gt; Result&lt;Self, ConfigError&gt; {\n        let mut config = Self::load_global_config()?;\n\n        // Override with project-specific config if present\n        if let Ok(project_config) = Self::load_project_config() {\n            config.merge_project_config(project_config)?;\n        }\n\n        // Override with environment variables\n        config.apply_env_overrides()?;\n\n        Ok(config)\n    }\n\n    fn load_global_config() -&gt; Result&lt;Self, ConfigError&gt; {\n        let config_path = dirs::config_dir()\n            .ok_or(ConfigError::NoConfigDir)?\n            .join(\"airsprotocols-mcpserver-filesystem\")\n            .join(\"config.toml\");\n\n        if config_path.exists() {\n            let content = std::fs::read_to_string(&amp;config_path)?;\n            Ok(toml::from_str(&amp;content)?)\n        } else {\n            Ok(Self::default())\n        }\n    }\n}\n</code></pre>"},{"location":"servers/filesystem/configuration/deployment/#deployment-strategies","title":"Deployment Strategies","text":""},{"location":"servers/filesystem/configuration/deployment/#development-deployment","title":"Development Deployment","text":"<pre><code># Install from source for development\ngit clone https://github.com/airsstack/airsprotocols.git\ncd airs\ncargo build --release --bin airsprotocols-mcpserver-filesystem\n\n# Configure for Claude Desktop\n# Add to Claude Desktop MCP configuration:\n{\n  \"mcpServers\": {\n    \"airsprotocols-mcpserver-filesystem\": {\n      \"command\": \"path/to/airsprotocols-mcpserver-filesystem\",\n      \"args\": [\"--config\", \"./.airsprotocols-mcpserver-filesystem.toml\"]\n    }\n  }\n}\n</code></pre>"},{"location":"servers/filesystem/configuration/deployment/#production-deployment","title":"Production Deployment","text":"<pre><code># Install via cargo\ncargo install airsprotocols-mcpserver-filesystem\n\n# System-wide configuration\nsudo mkdir -p /etc/airsprotocols-mcpserver-filesystem\nsudo cp config.toml /etc/airsprotocols-mcpserver-filesystem/\n\n# User configuration\nmkdir -p ~/.config/airsprotocols-mcpserver-filesystem\ncp user-config.toml ~/.config/airsprotocols-mcpserver-filesystem/config.toml\n\n# Systemd service for enterprise environments\n[Unit]\nDescription=AIRS MCP-FS Server\nAfter=network.target\n\n[Service]\nType=simple\nUser=mcp-fs\nExecStart=/usr/local/bin/airsprotocols-mcpserver-filesystem --daemon\nRestart=always\nRestartSec=5\n\n[Install]\nWantedBy=multi-user.target\n</code></pre>"},{"location":"servers/filesystem/configuration/environment/","title":"Environment Setup","text":"<p>AIRS MCP-FS uses environment-aware configuration to automatically adapt to different deployment contexts. This section covers environment detection, configuration, and best practices.</p>"},{"location":"servers/filesystem/configuration/environment/#environment-types","title":"Environment Types","text":"<p>AIRS MCP-FS supports four distinct environments, each with different security and operational defaults:</p>"},{"location":"servers/filesystem/configuration/environment/#development-environment","title":"Development Environment","text":"<p>Purpose: Local development and testing Security: Balanced - permissive enough for productivity, secure enough for safety Configuration File: <code>development.toml</code></p> <pre><code># development.toml\n[security.filesystem]\nallowed_paths = [\n    \"~/projects/**/*\",      # All project directories\n    \"~/Documents/**/*\",     # Personal documents\n    \"~/Desktop/**/*\",       # Desktop files\n    \"./**/*\"               # Current working directory\n]\n\n[security.operations]\nread_allowed = true\nwrite_requires_policy = false    # Allow writes for development\ndelete_requires_explicit_allow = true\n</code></pre>"},{"location":"servers/filesystem/configuration/environment/#staging-environment","title":"Staging Environment","text":"<p>Purpose: Pre-production testing and validation Security: Production-like with slightly relaxed monitoring Configuration File: <code>staging.toml</code></p> <pre><code># staging.toml\n[security.filesystem]\nallowed_paths = [\n    \"/app/staging/**/*\",\n    \"/tmp/staging-data/**/*\"\n]\n\n[security.operations]\nread_allowed = true\nwrite_requires_policy = true     # Require policies like production\ndelete_requires_explicit_allow = true\n</code></pre>"},{"location":"servers/filesystem/configuration/environment/#production-environment","title":"Production Environment","text":"<p>Purpose: Live deployment with maximum security Security: Secure by default, minimal permissions Configuration File: <code>production.toml</code></p> <pre><code># production.toml\n[security.filesystem]\nallowed_paths = [\n    \"/app/data/**/*.json\",       # Only specific data files\n    \"/app/config/app.toml\"       # Only application config\n]\n\ndenied_paths = [\n    \"/app/secrets/**\",           # Never access secrets\n    \"**/*.key\",                  # No key files\n    \"**/.env*\"                   # No environment files\n]\n\n[security.operations]\nread_allowed = true\nwrite_requires_policy = true     # All writes need policies\ndelete_requires_explicit_allow = true\n</code></pre>"},{"location":"servers/filesystem/configuration/environment/#test-environment","title":"Test Environment","text":"<p>Purpose: Unit and integration testing Security: Minimal restrictions for test execution Configuration File: <code>test.toml</code></p> <pre><code># test.toml\n[security.filesystem]\nallowed_paths = [\"**/*\"]         # Allow all paths for testing\n\n[security.operations]\nread_allowed = true\nwrite_requires_policy = false    # No restrictions for tests\ndelete_requires_explicit_allow = false\n</code></pre>"},{"location":"servers/filesystem/configuration/environment/#environment-detection","title":"Environment Detection","text":"<p>AIRS MCP-FS uses multiple strategies to detect the current environment:</p>"},{"location":"servers/filesystem/configuration/environment/#environment-variable-detection","title":"Environment Variable Detection","text":"<p>Checked in priority order:</p> <ol> <li> <p><code>AIRSPROTOCOLS_MCPSERVER_FS_ENV</code> - Primary environment variable    <pre><code>export AIRSPROTOCOLS_MCPSERVER_FS_ENV=development\n</code></pre></p> </li> <li> <p><code>NODE_ENV</code> - Node.js ecosystem compatibility    <pre><code>export NODE_ENV=production\n</code></pre></p> </li> <li> <p><code>ENVIRONMENT</code> - Generic environment variable    <pre><code>export ENVIRONMENT=staging\n</code></pre></p> </li> </ol>"},{"location":"servers/filesystem/configuration/environment/#automatic-detection","title":"Automatic Detection","text":"<p>When no environment variables are set:</p> <pre><code>// Automatic environment detection logic\nif cfg!(test) {\n    ConfigEnvironment::Test\n} else if cfg!(debug_assertions) {\n    ConfigEnvironment::Development\n} else {\n    ConfigEnvironment::Production\n}\n</code></pre> <ul> <li>Test runs: Automatically use <code>test</code> environment</li> <li>Debug builds: Default to <code>development</code></li> <li>Release builds: Default to <code>production</code></li> </ul>"},{"location":"servers/filesystem/configuration/environment/#configuration-file-management","title":"Configuration File Management","text":""},{"location":"servers/filesystem/configuration/environment/#file-location-priority","title":"File Location Priority","text":"<p>AIRS MCP-FS searches for configuration files in order:</p> <ol> <li> <p>Environment Variable Path <pre><code>export AIRSPROTOCOLS_MCPSERVER_FS_CONFIG_DIR=~/.config/airsprotocols-mcpserver-filesystem\n# Looks for: ~/.config/airsprotocols-mcpserver-filesystem/development.toml\n</code></pre></p> </li> <li> <p>User Configuration Directory <pre><code>~/.config/airsprotocols-mcpserver-filesystem/development.toml\n</code></pre></p> </li> <li> <p>System Configuration Directory <pre><code>/etc/airsprotocols-mcpserver-filesystem/development.toml\n</code></pre></p> </li> <li> <p>Built-in Defaults <pre><code>Compiled defaults for the detected environment\n</code></pre></p> </li> </ol>"},{"location":"servers/filesystem/configuration/environment/#file-naming-convention","title":"File Naming Convention","text":"<p>Environment-specific configuration files follow this pattern:</p> <ul> <li><code>development.toml</code> - Development environment</li> <li><code>staging.toml</code> - Staging environment</li> <li><code>production.toml</code> - Production environment</li> <li><code>test.toml</code> - Testing environment</li> </ul>"},{"location":"servers/filesystem/configuration/environment/#environment-variable-overrides","title":"Environment Variable Overrides","text":"<p>All configuration values can be overridden using environment variables:</p>"},{"location":"servers/filesystem/configuration/environment/#common-environment-variables","title":"Common Environment Variables","text":"<pre><code># Core environment setup\nexport AIRSPROTOCOLS_MCPSERVER_FS_ENV=development\nexport AIRSPROTOCOLS_MCPSERVER_FS_CONFIG_DIR=~/.config/airsprotocols-mcpserver-filesystem\nexport AIRSPROTOCOLS_MCPSERVER_FS_LOG_DIR=~/.local/share/airsprotocols-mcpserver-filesystem/logs\n\n# Security overrides\nexport AIRSPROTOCOLS_MCPSERVER_FS_SECURITY_OPERATIONS_READ_ALLOWED=true\nexport AIRSPROTOCOLS_MCPSERVER_FS_SECURITY_OPERATIONS_WRITE_REQUIRES_POLICY=false\n\n# File access overrides\nexport AIRSPROTOCOLS_MCPSERVER_FS_SECURITY_FILESYSTEM_ALLOWED_PATHS=\"~/projects/**/*,~/docs/**/*\"\n\n# Binary processing overrides\nexport AIRSPROTOCOLS_MCPSERVER_FS_BINARY_MAX_FILE_SIZE=52428800  # 50MB\nexport AIRSPROTOCOLS_MCPSERVER_FS_BINARY_ENABLE_IMAGE_PROCESSING=true\n</code></pre>"},{"location":"servers/filesystem/configuration/environment/#variable-naming-convention","title":"Variable Naming Convention","text":"<p>Environment variables follow this pattern: <pre><code>AIRSPROTOCOLS_MCPSERVER_FS_{SECTION}_{SUBSECTION}_{SETTING}\n</code></pre></p> <p>Examples: - <code>security.filesystem.allowed_paths</code> \u2192 <code>AIRSPROTOCOLS_MCPSERVER_FS_SECURITY_FILESYSTEM_ALLOWED_PATHS</code> - <code>binary.max_file_size</code> \u2192 <code>AIRSPROTOCOLS_MCPSERVER_FS_BINARY_MAX_FILE_SIZE</code> - <code>server.name</code> \u2192 <code>AIRSPROTOCOLS_MCPSERVER_FS_SERVER_NAME</code></p>"},{"location":"servers/filesystem/configuration/environment/#environment-specific-examples","title":"Environment-Specific Examples","text":""},{"location":"servers/filesystem/configuration/environment/#development-workstation-setup","title":"Development Workstation Setup","text":"<pre><code># ~/.bashrc or ~/.zshrc\nexport AIRSPROTOCOLS_MCPSERVER_FS_ENV=development\nexport AIRSPROTOCOLS_MCPSERVER_FS_CONFIG_DIR=~/.config/airsprotocols-mcpserver-filesystem\nexport AIRSPROTOCOLS_MCPSERVER_FS_LOG_DIR=~/.local/share/airsprotocols-mcpserver-filesystem/logs\n\n# Allow broader access for development\nexport AIRSPROTOCOLS_MCPSERVER_FS_SECURITY_FILESYSTEM_ALLOWED_PATHS=\"~/projects/**/*,~/Documents/**/*,~/Desktop/**/*,./**/*\"\n</code></pre> <p>Configuration file (<code>~/.config/airsprotocols-mcpserver-filesystem/development.toml</code>): <pre><code>[security.filesystem]\nallowed_paths = [\n    \"~/projects/**/*\",\n    \"~/Documents/**/*\",\n    \"~/Desktop/**/*\",\n    \"./**/*\"\n]\n\n[security.operations]\nread_allowed = true\nwrite_requires_policy = false\ndelete_requires_explicit_allow = true\n\n[security.policies.development_files]\npatterns = [\"~/projects/**/*.{rs,py,js,ts,md}\"]\noperations = [\"read\", \"write\", \"create_dir\"]\nrisk_level = \"low\"\ndescription = \"Development source files\"\n</code></pre></p>"},{"location":"servers/filesystem/configuration/environment/#cicd-pipeline-setup","title":"CI/CD Pipeline Setup","text":"<pre><code># .github/workflows/test.yml\nenv:\n  AIRSPROTOCOLS_MCPSERVER_FS_ENV: test\n  AIRSPROTOCOLS_MCPSERVER_FS_SECURITY_OPERATIONS_WRITE_REQUIRES_POLICY: false\n  AIRSPROTOCOLS_MCPSERVER_FS_SECURITY_OPERATIONS_DELETE_REQUIRES_EXPLICIT_ALLOW: false\n</code></pre>"},{"location":"servers/filesystem/configuration/environment/#docker-production-setup","title":"Docker Production Setup","text":"<pre><code># Dockerfile\nENV AIRSPROTOCOLS_MCPSERVER_FS_ENV=production\nENV AIRSPROTOCOLS_MCPSERVER_FS_CONFIG_DIR=/app/config\nENV AIRSPROTOCOLS_MCPSERVER_FS_LOG_DIR=/app/logs\nENV AIRSPROTOCOLS_MCPSERVER_FS_SECURITY_FILESYSTEM_ALLOWED_PATHS=\"/app/data/**/*\"\n</code></pre> <p>Production configuration (<code>/app/config/production.toml</code>): <pre><code>[security.filesystem]\nallowed_paths = [\"/app/data/**/*.json\"]\ndenied_paths = [\"/app/secrets/**\", \"**/*.key\", \"**/.env*\"]\n\n[security.operations]\nread_allowed = true\nwrite_requires_policy = true\ndelete_requires_explicit_allow = true\n\n[security.policies.app_data]\npatterns = [\"/app/data/**/*.json\"]\noperations = [\"read\", \"write\"]\nrisk_level = \"medium\"\ndescription = \"Application data files\"\n</code></pre></p>"},{"location":"servers/filesystem/configuration/environment/#environment-validation","title":"Environment Validation","text":"<p>AIRS MCP-FS validates environment configuration at startup:</p>"},{"location":"servers/filesystem/configuration/environment/#validation-checks","title":"Validation Checks","text":"<ol> <li>Environment Consistency: Warns if environment settings don't match detected environment</li> <li>Security Validation: Checks for potential security issues in permissive environments</li> <li>Path Validation: Ensures all configured paths are accessible</li> <li>Policy Validation: Verifies security policies are properly configured</li> </ol>"},{"location":"servers/filesystem/configuration/environment/#validation-output-example","title":"Validation Output Example","text":"<pre><code>\ud83d\udccb Configuration loaded from development environment\n   Configuration files: [\"/Users/username/.config/airsprotocols-mcpserver-filesystem/development.toml\"]\n   Environment variables: 3 overrides\n\n\u2705 Environment validation passed\n   - Security policies: 4 active policies\n   - Allowed paths: 4 patterns validated\n   - Risk assessment: Low risk configuration\n</code></pre>"},{"location":"servers/filesystem/configuration/environment/#environment-migration","title":"Environment Migration","text":""},{"location":"servers/filesystem/configuration/environment/#development-to-staging","title":"Development to Staging","text":"<p>When promoting to staging:</p> <ol> <li>Review Security: Ensure policies are appropriate for staging</li> <li>Update Paths: Change paths from local development to staging paths</li> <li>Enable Monitoring: Increase logging and audit levels</li> <li>Test Configuration: Validate configuration with staging data</li> </ol>"},{"location":"servers/filesystem/configuration/environment/#staging-to-production","title":"Staging to Production","text":"<p>When promoting to production:</p> <ol> <li>Security Audit: Complete security review of all policies</li> <li>Minimal Permissions: Reduce allowed paths to absolute minimum</li> <li>Enable Auditing: Full audit logging and monitoring</li> <li>Backup Configuration: Maintain configuration backups</li> </ol>"},{"location":"servers/filesystem/configuration/environment/#troubleshooting-environment-issues","title":"Troubleshooting Environment Issues","text":""},{"location":"servers/filesystem/configuration/environment/#common-environment-problems","title":"Common Environment Problems","text":"<ol> <li> <p>Wrong Environment Detected <pre><code># Check environment detection\necho $AIRSPROTOCOLS_MCPSERVER_FS_ENV\n\n# Set explicitly\nexport AIRSPROTOCOLS_MCPSERVER_FS_ENV=development\n</code></pre></p> </li> <li> <p>Configuration File Not Found <pre><code># Check file existence\nls -la ~/.config/airsprotocols-mcpserver-filesystem/\n\n# Generate missing configuration\nairsprotocols-mcpserver-filesystem generate-config --env development\n</code></pre></p> </li> <li> <p>Permission Denied in Environment <pre><code># Check allowed paths in configuration\ncat ~/.config/airsprotocols-mcpserver-filesystem/development.toml | grep allowed_paths\n\n# Add required paths to configuration\n</code></pre></p> </li> </ol>"},{"location":"servers/filesystem/configuration/environment/#environment-debugging","title":"Environment Debugging","text":"<p>Enable debug logging to troubleshoot environment issues:</p> <pre><code>export RUST_LOG=debug\nexport AIRSPROTOCOLS_MCPSERVER_FS_ENV=development\nairsprotocols-mcpserver-filesystem\n</code></pre> <p>This will show detailed information about: - Environment detection process - Configuration file loading - Security policy evaluation - Path validation results</p>"},{"location":"servers/filesystem/configuration/environment/#best-practices","title":"Best Practices","text":""},{"location":"servers/filesystem/configuration/environment/#environment-separation","title":"Environment Separation","text":"<ol> <li>Use Different Configurations: Each environment should have its own configuration file</li> <li>Environment Variables: Use environment variables for environment-specific values</li> <li>Version Control: Keep configuration files in version control with environment branches</li> <li>Documentation: Document environment-specific requirements and constraints</li> </ol>"},{"location":"servers/filesystem/configuration/environment/#security-across-environments","title":"Security Across Environments","text":"<ol> <li>Progressive Security: Each environment should be more secure than the previous</li> <li>Regular Reviews: Periodically review environment configurations</li> <li>Audit Trails: Maintain audit logs for all environment changes</li> <li>Testing: Test security policies in staging before production</li> </ol>"},{"location":"servers/filesystem/configuration/environment/#configuration-management","title":"Configuration Management","text":"<ol> <li>Consistent Naming: Use consistent naming across environments</li> <li>Template-Based: Use configuration templates for consistency</li> <li>Validation: Validate configurations before deployment</li> <li>Rollback Plans: Maintain previous configurations for rollback</li> </ol>"},{"location":"servers/filesystem/configuration/environment/#related-sections","title":"Related Sections","text":"<ul> <li>Configuration Overview: Overall configuration system architecture</li> <li>Security Policies: Detailed security configuration</li> <li>Claude Desktop Integration: MCP client environment setup</li> <li>Troubleshooting: Environment-specific troubleshooting</li> </ul>"},{"location":"servers/filesystem/configuration/overview/","title":"Configuration Overview","text":"<p>This section provides a comprehensive overview of AIRS MCP-FS configuration system, its components, and design principles.</p>"},{"location":"servers/filesystem/configuration/overview/#configuration-philosophy","title":"Configuration Philosophy","text":"<p>AIRS MCP-FS configuration is built on four core principles:</p> <ol> <li>Security by Default: Safe defaults that protect your system</li> <li>Policy-Driven Access: Named policies for different file types and use cases</li> <li>12-Factor Compliance: Environment variable overrides for deployment flexibility</li> </ol>"},{"location":"servers/filesystem/configuration/overview/#configuration-hierarchy","title":"Configuration Hierarchy","text":"<p>The configuration system uses a layered approach where each layer can override the previous:</p> <pre><code>graph TD\n    A[Built-in Defaults] --&gt; B[Environment-Specific File]\n    B --&gt; C[Local Overrides]\n    C --&gt; D[Environment Variables]\n    D --&gt; E[Final Configuration]\n\n    style A fill:#f9f9f9\n    style E fill:#d4edda</code></pre>"},{"location":"servers/filesystem/configuration/overview/#layer-details","title":"Layer Details","text":"<ol> <li>Built-in Defaults: Secure production defaults compiled into the binary</li> <li>Environment-Specific File: <code>development.toml</code>, <code>staging.toml</code>, or <code>production.toml</code></li> <li>Local Overrides: Project-specific or user-specific customizations</li> <li>Environment Variables: Runtime overrides for deployment and CI/CD</li> </ol>"},{"location":"servers/filesystem/configuration/overview/#core-configuration-sections","title":"Core Configuration Sections","text":""},{"location":"servers/filesystem/configuration/overview/#security-configuration","title":"Security Configuration","text":"<p>The heart of AIRS MCP-FS configuration, controlling file system access and operations:</p> <pre><code>[security]\n# Filesystem access control\n[security.filesystem]\nallowed_paths = [\"~/projects/**/*\"]\ndenied_paths = [\"**/.env*\"]\n\n# Operation-level controls\n[security.operations]\nread_allowed = true\nwrite_requires_policy = false\ndelete_requires_explicit_allow = true\n\n# Named security policies\n[security.policies.source_code]\npatterns = [\"**/*.{rs,py,js}\"]\noperations = [\"read\", \"write\"]\nrisk_level = \"low\"\n</code></pre> <p>Key Features: - Path-based access control using glob patterns - Operation-level permissions for read/write/delete - Named policies for different file types - Risk-level categorization for audit logging</p>"},{"location":"servers/filesystem/configuration/overview/#binary-processing-configuration","title":"Binary Processing Configuration","text":"<p>Controls how AIRS MCP-FS handles images, PDFs, and other binary files:</p> <pre><code>[binary]\nmax_file_size = 104857600           # 100MB\nenable_image_processing = true\nenable_pdf_processing = true\n</code></pre> <p>Capabilities: - File size limits to prevent resource exhaustion - Format-specific processing for images and PDFs - Metadata extraction from binary files - Thumbnail generation for images</p>"},{"location":"servers/filesystem/configuration/overview/#server-configuration","title":"Server Configuration","text":"<p>Basic MCP server identity and capabilities:</p> <pre><code>[server]\nname = \"airsprotocols-mcpserver-filesystem\"\nversion = \"1.0.0\"\n</code></pre>"},{"location":"servers/filesystem/configuration/overview/#environment-detection","title":"Environment Detection","text":"<p>AIRS MCP-FS automatically detects the runtime environment using multiple strategies:</p>"},{"location":"servers/filesystem/configuration/overview/#environment-variable-detection","title":"Environment Variable Detection","text":"<p>Checked in order of preference:</p> <ol> <li><code>AIRS_MCP_FS_ENV</code> - AIRS-specific environment</li> <li><code>NODE_ENV</code> - Node.js convention</li> <li><code>ENVIRONMENT</code> - Generic environment variable</li> </ol>"},{"location":"servers/filesystem/configuration/overview/#automatic-detection","title":"Automatic Detection","text":"<p>If no environment variables are set:</p> <ul> <li>Debug builds: Default to <code>development</code></li> <li>Release builds: Default to <code>production</code></li> <li>Test runs: Automatically use <code>test</code> environment</li> </ul>"},{"location":"servers/filesystem/configuration/overview/#environment-specific-defaults","title":"Environment-Specific Defaults","text":"<p>Each environment has different security defaults:</p> Environment Write Policy Delete Policy Allowed Paths Production Policy Required Explicit Allow Minimal Staging Policy Required Explicit Allow Moderate Development Allowed Explicit Allow Broad Test Allowed Allowed Universal"},{"location":"servers/filesystem/configuration/overview/#file-discovery-process","title":"File Discovery Process","text":"<p>AIRS MCP-FS searches for configuration files using a systematic approach:</p> <pre><code>1. Check AIRS_MCP_FS_CONFIG_DIR environment variable\n   \u2514\u2500\u2500 $AIRS_MCP_FS_CONFIG_DIR/{environment}.toml\n\n2. Check user configuration directory\n   \u2514\u2500\u2500 ~/.config/airsprotocols-mcpserver-filesystem/{environment}.toml\n\n3. Check system configuration directory\n   \u2514\u2500\u2500 /etc/airsprotocols-mcpserver-filesystem/{environment}.toml\n\n4. Use built-in defaults\n   \u2514\u2500\u2500 Compiled secure defaults\n</code></pre>"},{"location":"servers/filesystem/configuration/overview/#configuration-file-naming","title":"Configuration File Naming","text":"<ul> <li><code>development.toml</code> - Development environment</li> <li><code>staging.toml</code> - Staging environment  </li> <li><code>production.toml</code> - Production environment</li> <li><code>test.toml</code> - Testing environment</li> </ul>"},{"location":"servers/filesystem/configuration/overview/#security-policy-system","title":"Security Policy System","text":"<p>Named policies provide fine-grained control over file access patterns:</p>"},{"location":"servers/filesystem/configuration/overview/#policy-components","title":"Policy Components","text":"<pre><code>[security.policies.example_policy]\npatterns = [\"**/*.txt\"]              # Glob patterns\noperations = [\"read\", \"write\"]       # Allowed operations\nrisk_level = \"low\"                   # Risk category\ndescription = \"Text files policy\"   # Human description\n</code></pre>"},{"location":"servers/filesystem/configuration/overview/#built-in-policies","title":"Built-in Policies","text":"<p>AIRS MCP-FS includes several built-in policies:</p> <ul> <li>source_code: Programming language files</li> <li>documentation: Markdown, text, and doc files</li> <li>config_files: Configuration and settings files</li> <li>build_artifacts: Build outputs and temporary files</li> </ul>"},{"location":"servers/filesystem/configuration/overview/#risk-levels","title":"Risk Levels","text":"<p>Risk levels control audit logging and monitoring:</p> <ul> <li>Low: Normal operations, minimal logging</li> <li>Medium: Moderate risk, standard logging</li> <li>High: Elevated risk, detailed logging</li> <li>Critical: High-risk operations, comprehensive audit</li> </ul>"},{"location":"servers/filesystem/configuration/overview/#environment-variable-overrides","title":"Environment Variable Overrides","text":"<p>All configuration values can be overridden using environment variables:</p>"},{"location":"servers/filesystem/configuration/overview/#variable-naming-convention","title":"Variable Naming Convention","text":"<p>Environment variables use the prefix <code>AIRS_MCP_FS_</code> followed by the configuration path in uppercase:</p> <pre><code>Configuration: security.filesystem.allowed_paths\nEnvironment:   AIRS_MCP_FS_SECURITY_FILESYSTEM_ALLOWED_PATHS\n</code></pre>"},{"location":"servers/filesystem/configuration/overview/#common-overrides","title":"Common Overrides","text":"<pre><code># Environment and directories\nexport AIRS_MCP_FS_ENV=development\nexport AIRS_MCP_FS_CONFIG_DIR=~/.config/airsprotocols-mcpserver-filesystem\nexport AIRS_MCP_FS_LOG_DIR=~/.local/share/airsprotocols-mcpserver-filesystem/logs\n\n# File size limits\nexport AIRS_MCP_FS_BINARY_MAX_FILE_SIZE=52428800  # 50MB\n\n# Security overrides\nexport AIRS_MCP_FS_SECURITY_OPERATIONS_READ_ALLOWED=true\n</code></pre>"},{"location":"servers/filesystem/configuration/overview/#array-values","title":"Array Values","text":"<p>For configuration arrays (like <code>allowed_paths</code>), use comma-separated values:</p> <pre><code>export AIRS_MCP_FS_SECURITY_FILESYSTEM_ALLOWED_PATHS=\"~/projects/**/*,~/docs/**/*\"\n</code></pre>"},{"location":"servers/filesystem/configuration/overview/#configuration-validation","title":"Configuration Validation","text":"<p>AIRS MCP-FS validates configuration at startup:</p>"},{"location":"servers/filesystem/configuration/overview/#validation-checks","title":"Validation Checks","text":"<ol> <li>Path Validation: Ensures glob patterns are valid</li> <li>Size Limits: Validates file size limits are reasonable</li> <li>Policy Consistency: Checks that policies reference valid operations</li> <li>Environment Compatibility: Warns about potential security issues</li> </ol>"},{"location":"servers/filesystem/configuration/overview/#error-handling","title":"Error Handling","text":"<p>Configuration errors are handled gracefully:</p> <ul> <li>Invalid patterns: Logged with suggestions for correction</li> <li>Missing files: Falls back to secure defaults</li> <li>Permission errors: Detailed error messages with solutions</li> </ul>"},{"location":"servers/filesystem/configuration/overview/#configuration-best-practices","title":"Configuration Best Practices","text":""},{"location":"servers/filesystem/configuration/overview/#security-best-practices","title":"Security Best Practices","text":"<ol> <li>Principle of Least Privilege: Grant minimal necessary permissions</li> <li>Regular Audits: Review configuration periodically</li> <li>Environment Separation: Use different configs for different environments</li> <li>Documentation: Comment complex policies and patterns</li> </ol>"},{"location":"servers/filesystem/configuration/overview/#performance-best-practices","title":"Performance Best Practices","text":"<ol> <li>Specific Patterns: Use precise glob patterns to avoid unnecessary checks</li> <li>Reasonable Size Limits: Set appropriate file size limits</li> <li>Binary Processing: Disable unused binary processing features</li> <li>Caching: Leverage built-in configuration caching</li> </ol>"},{"location":"servers/filesystem/configuration/overview/#maintenance-best-practices","title":"Maintenance Best Practices","text":"<ol> <li>Version Control: Keep configuration files in version control</li> <li>Testing: Test configuration changes before deployment</li> <li>Monitoring: Monitor configuration effectiveness</li> <li>Documentation: Maintain up-to-date configuration documentation</li> </ol>"},{"location":"servers/filesystem/configuration/overview/#related-sections","title":"Related Sections","text":"<ul> <li>Environment Setup: Detailed environment configuration</li> <li>Security Policies: Advanced security policy configuration  </li> <li>Claude Desktop Integration: MCP client setup</li> <li>Troubleshooting: Configuration problem solving</li> </ul>"},{"location":"servers/filesystem/configuration/security/","title":"Security Policies","text":"<p>AIRS MCP-FS implements a comprehensive security model based on named policies, path validation, and operation controls. This section covers advanced security configuration and best practices.</p>"},{"location":"servers/filesystem/configuration/security/#security-architecture","title":"Security Architecture","text":"<p>The security system uses multiple layers of protection:</p> <pre><code>Request \u2192 Path Validation \u2192 Policy Matching \u2192 Operation Authorization \u2192 Audit Logging\n</code></pre>"},{"location":"servers/filesystem/configuration/security/#security-components","title":"Security Components","text":"<ol> <li>Path Validation: Glob pattern-based allowlists and denylists</li> <li>Named Policies: Fine-grained control for specific file types</li> <li>Operation Controls: Global permissions for read/write/delete operations</li> <li>Risk Assessment: Risk-level categorization for audit and monitoring</li> <li>Audit Logging: Comprehensive operation tracking</li> </ol>"},{"location":"servers/filesystem/configuration/security/#path-based-security","title":"Path-Based Security","text":""},{"location":"servers/filesystem/configuration/security/#allowed-paths","title":"Allowed Paths","text":"<p>Allowed paths define what directories and files AIRS MCP-FS can access:</p> <pre><code>[security.filesystem]\nallowed_paths = [\n    \"~/projects/**/*\",              # All files in projects directory\n    \"~/Documents/**/*.{md,txt}\",    # Only markdown and text in Documents\n    \"./**/*\",                       # Current directory and subdirectories\n    \"/tmp/airsprotocols-mcpserver-filesystem/**/*\"        # Temporary files\n]\n</code></pre>"},{"location":"servers/filesystem/configuration/security/#denied-paths","title":"Denied Paths","text":"<p>Denied paths take precedence over allowed paths and prevent access to sensitive locations:</p> <pre><code>[security.filesystem]\ndenied_paths = [\n    \"**/.git/**\",                   # Git repositories\n    \"**/.env*\",                     # Environment files\n    \"~/.*/**\",                      # Hidden directories (except specific allowlist)\n    \"**/id_rsa*\",                   # SSH keys\n    \"**/credentials*\",              # Credential files\n    \"**/secrets*\",                  # Secret files\n    \"**/*.key\",                     # Private key files\n    \"/etc/passwd\",                  # System password file\n    \"/etc/shadow\"                   # System shadow file\n]\n</code></pre>"},{"location":"servers/filesystem/configuration/security/#glob-pattern-syntax","title":"Glob Pattern Syntax","text":"<p>AIRS MCP-FS uses standard glob patterns for path matching:</p> Pattern Description Example <code>*</code> Matches any character except <code>/</code> <code>*.txt</code> matches <code>file.txt</code> <code>**</code> Matches any character including <code>/</code> <code>**/src/**</code> matches any src directory <code>?</code> Matches single character <code>file?.txt</code> matches <code>file1.txt</code> <code>[...]</code> Character class <code>*.[jt]s</code> matches <code>.js</code> and <code>.ts</code> <code>{...}</code> Alternation <code>*.{md,txt}</code> matches <code>.md</code> and <code>.txt</code>"},{"location":"servers/filesystem/configuration/security/#path-validation-examples","title":"Path Validation Examples","text":"<pre><code># Development workstation\n[security.filesystem]\nallowed_paths = [\n    \"~/projects/**/*\",          # All project files\n    \"~/Documents/**/*\",         # All documents\n    \"~/Desktop/**/*\",           # Desktop files\n    \"./**/*\"                    # Current working directory\n]\n\ndenied_paths = [\n    \"**/.git/**\",               # No Git internals\n    \"**/.env*\",                 # No environment files\n    \"~/.*/**\"                   # No hidden directories\n]\n</code></pre> <pre><code># Content creation setup\n[security.filesystem]\nallowed_paths = [\n    \"~/writing/**/*.{md,txt}\",  # Writing files only\n    \"~/blog/**/*\",              # Blog content\n    \"~/assets/images/**/*.{jpg,png,gif}\"  # Image assets\n]\n\ndenied_paths = [\n    \"**/drafts/private/**\",     # Private drafts\n    \"**/*.backup\"               # Backup files\n]\n</code></pre>"},{"location":"servers/filesystem/configuration/security/#named-security-policies","title":"Named Security Policies","text":"<p>Named policies provide fine-grained control over specific file types and use cases:</p>"},{"location":"servers/filesystem/configuration/security/#policy-structure","title":"Policy Structure","text":"<pre><code>[security.policies.policy_name]\npatterns = [\"**/*.{ext1,ext2}\"]     # File patterns this policy covers\noperations = [\"read\", \"write\"]       # Allowed operations\nrisk_level = \"low\"                   # Risk category for auditing\ndescription = \"Policy description\"   # Human-readable description\n</code></pre>"},{"location":"servers/filesystem/configuration/security/#available-operations","title":"Available Operations","text":"Operation Description Usage <code>read</code> Read file contents Reading source code, documents <code>write</code> Create or modify files Creating new files, editing existing <code>delete</code> Remove files or directories Cleanup, refactoring <code>list</code> List directory contents Directory browsing <code>create_dir</code> Create directories Project setup, organization <code>move</code> Move/rename files File organization <code>copy</code> Copy files Backup, duplication"},{"location":"servers/filesystem/configuration/security/#risk-levels","title":"Risk Levels","text":"<p>Risk levels control audit logging and monitoring intensity:</p> Level Description Use Cases Logging <code>low</code> Normal operations Source code, documentation Basic <code>medium</code> Moderate risk Configuration files, scripts Standard <code>high</code> Elevated risk System files, databases Detailed <code>critical</code> High-risk operations Security files, credentials Comprehensive"},{"location":"servers/filesystem/configuration/security/#built-in-policies","title":"Built-in Policies","text":"<p>AIRS MCP-FS includes several built-in security policies:</p>"},{"location":"servers/filesystem/configuration/security/#source-code-policy","title":"Source Code Policy","text":"<pre><code>[security.policies.source_code]\npatterns = [\n    \"**/*.{rs,py,js,ts,jsx,tsx}\",\n    \"**/*.{c,cpp,h,hpp}\",\n    \"**/*.{java,kt,scala}\",\n    \"**/*.{go,rb,php,swift}\"\n]\noperations = [\"read\", \"write\"]\nrisk_level = \"low\"\ndescription = \"Source code files - safe for development\"\n</code></pre>"},{"location":"servers/filesystem/configuration/security/#documentation-policy","title":"Documentation Policy","text":"<pre><code>[security.policies.documentation]\npatterns = [\n    \"**/*.{md,txt,rst}\",\n    \"**/README*\",\n    \"**/CHANGELOG*\",\n    \"**/LICENSE*\"\n]\noperations = [\"read\", \"write\"]\nrisk_level = \"low\"\ndescription = \"Documentation files - safe for editing\"\n</code></pre>"},{"location":"servers/filesystem/configuration/security/#configuration-files-policy","title":"Configuration Files Policy","text":"<pre><code>[security.policies.config_files]\npatterns = [\n    \"**/Cargo.toml\",\n    \"**/*.{json,yaml,yml,toml}\",\n    \"**/*.{xml,ini,conf}\"\n]\noperations = [\"read\", \"write\"]\nrisk_level = \"medium\"\ndescription = \"Configuration files - moderate risk\"\n</code></pre>"},{"location":"servers/filesystem/configuration/security/#build-artifacts-policy","title":"Build Artifacts Policy","text":"<pre><code>[security.policies.build_artifacts]\npatterns = [\n    \"**/target/**\",\n    \"**/dist/**\",\n    \"**/build/**\",\n    \"**/*.{tmp,bak,log}\"\n]\noperations = [\"read\", \"delete\"]\nrisk_level = \"low\"\ndescription = \"Build artifacts and temporary files - safe to clean\"\n</code></pre>"},{"location":"servers/filesystem/configuration/security/#operation-controls","title":"Operation Controls","text":"<p>Global operation controls provide default permissions:</p> <pre><code>[security.operations]\nread_allowed = true                      # Allow read operations globally\nwrite_requires_policy = false           # Writes need matching policy\ndelete_requires_explicit_allow = true   # Deletes need explicit permission\ncreate_dir_allowed = true               # Allow directory creation\n</code></pre>"},{"location":"servers/filesystem/configuration/security/#operation-control-examples","title":"Operation Control Examples","text":""},{"location":"servers/filesystem/configuration/security/#development-mode","title":"Development Mode","text":"<pre><code>[security.operations]\nread_allowed = true\nwrite_requires_policy = false           # Allow writes for development\ndelete_requires_explicit_allow = true   # Still require explicit delete\ncreate_dir_allowed = true\n</code></pre>"},{"location":"servers/filesystem/configuration/security/#production-mode","title":"Production Mode","text":"<pre><code>[security.operations]\nread_allowed = true\nwrite_requires_policy = true            # All writes need policies\ndelete_requires_explicit_allow = true   # All deletes need explicit permission\ncreate_dir_allowed = false              # No directory creation\n</code></pre>"},{"location":"servers/filesystem/configuration/security/#custom-security-policies","title":"Custom Security Policies","text":""},{"location":"servers/filesystem/configuration/security/#content-creation-policy","title":"Content Creation Policy","text":"<pre><code>[security.policies.content_creation]\npatterns = [\n    \"~/blog/**/*.{md,txt}\",\n    \"~/articles/**/*.{md,txt}\",\n    \"~/drafts/**/*.{md,txt}\"\n]\noperations = [\"read\", \"write\", \"create_dir\"]\nrisk_level = \"low\"\ndescription = \"Content creation and blogging files\"\n</code></pre>"},{"location":"servers/filesystem/configuration/security/#image-processing-policy","title":"Image Processing Policy","text":"<pre><code>[security.policies.image_assets]\npatterns = [\n    \"~/assets/images/**/*.{jpg,jpeg,png,gif,webp}\",\n    \"~/photos/**/*.{jpg,jpeg,png,raw}\",\n    \"~/screenshots/**/*.png\"\n]\noperations = [\"read\", \"write\", \"copy\"]\nrisk_level = \"low\"\ndescription = \"Image files for processing and optimization\"\n</code></pre>"},{"location":"servers/filesystem/configuration/security/#database-files-policy","title":"Database Files Policy","text":"<pre><code>[security.policies.database_files]\npatterns = [\n    \"~/data/**/*.{db,sqlite,sqlite3}\",\n    \"~/backups/**/*.sql\"\n]\noperations = [\"read\", \"write\"]\nrisk_level = \"high\"\ndescription = \"Database files - handle with care\"\n</code></pre>"},{"location":"servers/filesystem/configuration/security/#sensitive-configuration-policy","title":"Sensitive Configuration Policy","text":"<pre><code>[security.policies.sensitive_config]\npatterns = [\n    \"**/config/production/**\",\n    \"**/*_secrets.toml\",\n    \"**/api_keys.json\"\n]\noperations = [\"read\"]                    # Read-only for sensitive configs\nrisk_level = \"critical\"\ndescription = \"Sensitive configuration files - read-only access\"\n</code></pre>"},{"location":"servers/filesystem/configuration/security/#environment-specific-security","title":"Environment-Specific Security","text":""},{"location":"servers/filesystem/configuration/security/#development-environment","title":"Development Environment","text":"<pre><code># development.toml\n[security.filesystem]\nallowed_paths = [\n    \"~/projects/**/*\",\n    \"~/Documents/**/*\",\n    \"./**/*\"\n]\n\n[security.operations]\nread_allowed = true\nwrite_requires_policy = false\ndelete_requires_explicit_allow = true\n\n[security.policies.dev_files]\npatterns = [\"~/dev-projects/**/*\"]\noperations = [\"read\", \"write\", \"delete\", \"create_dir\"]\nrisk_level = \"low\"\ndescription = \"Development files - permissive access\"\n</code></pre>"},{"location":"servers/filesystem/configuration/security/#staging-environment","title":"Staging Environment","text":"<pre><code># staging.toml\n[security.filesystem]\nallowed_paths = [\n    \"/app/staging/**/*\",\n    \"/tmp/staging-data/**/*\"\n]\n\n[security.operations]\nread_allowed = true\nwrite_requires_policy = true            # Require policies\ndelete_requires_explicit_allow = true\n\n[security.policies.staging_data]\npatterns = [\"/app/staging/**/*.json\"]\noperations = [\"read\", \"write\"]\nrisk_level = \"medium\"\ndescription = \"Staging environment data files\"\n</code></pre>"},{"location":"servers/filesystem/configuration/security/#production-environment","title":"Production Environment","text":"<pre><code># production.toml\n[security.filesystem]\nallowed_paths = [\"/app/data/**/*.json\"]\ndenied_paths = [\"/app/secrets/**\", \"**/*.key\"]\n\n[security.operations]\nread_allowed = true\nwrite_requires_policy = true\ndelete_requires_explicit_allow = true\n\n[security.policies.production_data]\npatterns = [\"/app/data/**/*.json\"]\noperations = [\"read\", \"write\"]\nrisk_level = \"high\"\ndescription = \"Production data files - high security\"\n</code></pre>"},{"location":"servers/filesystem/configuration/security/#security-validation","title":"Security Validation","text":"<p>AIRS MCP-FS performs comprehensive security validation:</p>"},{"location":"servers/filesystem/configuration/security/#path-traversal-protection","title":"Path Traversal Protection","text":"<p>Protection against directory traversal attacks:</p> <pre><code>\u274c Blocked: ../../../etc/passwd\n\u274c Blocked: ..\\..\\..\\..\\windows\\system32\n\u274c Blocked: /app/data/../secrets/key.pem\n\u2705 Allowed: ~/projects/my-app/src/main.rs\n</code></pre>"},{"location":"servers/filesystem/configuration/security/#policy-validation","title":"Policy Validation","text":"<p>Ensures security policies are correctly configured:</p> <ul> <li>Pattern Validation: Glob patterns are syntactically correct</li> <li>Operation Validation: Operations are recognized and valid</li> <li>Risk Level Validation: Risk levels are properly categorized</li> <li>Consistency Checks: No conflicting policies or permissions</li> </ul>"},{"location":"servers/filesystem/configuration/security/#real-time-security-monitoring","title":"Real-time Security Monitoring","text":"<pre><code>\ud83d\udd0d Security audit: high_risk_operation\n   File: /app/config/database.toml\n   Operation: write\n   Policy: sensitive_config\n   Risk Level: critical\n   Result: \u2705 Allowed (explicit policy match)\n</code></pre>"},{"location":"servers/filesystem/configuration/security/#audit-logging","title":"Audit Logging","text":"<p>Comprehensive security audit logging:</p>"},{"location":"servers/filesystem/configuration/security/#log-levels-by-risk","title":"Log Levels by Risk","text":"<ul> <li>Low Risk: Basic operation logging</li> <li>Medium Risk: Detailed operation logging with context</li> <li>High Risk: Comprehensive logging with full request details</li> <li>Critical Risk: Maximum logging with security analysis</li> </ul>"},{"location":"servers/filesystem/configuration/security/#audit-log-example","title":"Audit Log Example","text":"<pre><code>{\n  \"timestamp\": \"2025-08-30T10:30:00Z\",\n  \"operation\": \"write\",\n  \"file_path\": \"/app/config/database.toml\",\n  \"policy_matched\": \"sensitive_config\",\n  \"risk_level\": \"critical\",\n  \"result\": \"allowed\",\n  \"user_context\": \"mcp_client\",\n  \"request_id\": \"req_123456\"\n}\n</code></pre>"},{"location":"servers/filesystem/configuration/security/#security-best-practices","title":"Security Best Practices","text":""},{"location":"servers/filesystem/configuration/security/#policy-design","title":"Policy Design","text":"<ol> <li>Principle of Least Privilege: Grant minimal necessary permissions</li> <li>Specific Patterns: Use precise glob patterns instead of broad wildcards</li> <li>Risk Categorization: Properly categorize operations by risk level</li> <li>Regular Reviews: Periodically review and update policies</li> </ol>"},{"location":"servers/filesystem/configuration/security/#path-configuration","title":"Path Configuration","text":"<ol> <li>Explicit Allowlists: Use explicit allowed paths instead of permissive patterns</li> <li>Comprehensive Denylists: Block access to sensitive directories</li> <li>Environment Separation: Different path restrictions for different environments</li> <li>Path Testing: Test path patterns before deployment</li> </ol>"},{"location":"servers/filesystem/configuration/security/#operation-security","title":"Operation Security","text":"<ol> <li>Write Protection: Require policies for write operations in production</li> <li>Delete Confirmation: Always require explicit permission for deletions</li> <li>Operation Auditing: Log all security-relevant operations</li> <li>Failure Handling: Secure failure modes that deny access by default</li> </ol>"},{"location":"servers/filesystem/configuration/security/#monitoring-and-maintenance","title":"Monitoring and Maintenance","text":"<ol> <li>Regular Audits: Review security logs and access patterns</li> <li>Policy Updates: Keep security policies current with changing requirements</li> <li>Incident Response: Have procedures for security incidents</li> <li>Documentation: Maintain up-to-date security documentation</li> </ol>"},{"location":"servers/filesystem/configuration/security/#troubleshooting-security-issues","title":"Troubleshooting Security Issues","text":""},{"location":"servers/filesystem/configuration/security/#common-security-problems","title":"Common Security Problems","text":"<ol> <li>Access Denied Errors</li> <li>Check allowed_paths configuration</li> <li>Verify no denied_paths patterns match</li> <li> <p>Ensure appropriate policy exists for file type</p> </li> <li> <p>Policy Not Matching</p> </li> <li>Test glob patterns with intended file paths</li> <li>Check policy operation permissions</li> <li> <p>Verify risk level is appropriate</p> </li> <li> <p>Environment Security Conflicts</p> </li> <li>Review environment-specific configurations</li> <li>Check environment variable overrides</li> <li>Validate policy inheritance between environments</li> </ol>"},{"location":"servers/filesystem/configuration/security/#security-debugging","title":"Security Debugging","text":"<p>Enable security debugging for detailed analysis:</p> <pre><code>export RUST_LOG=debug\nexport AIRSPROTOCOLS_MCPSERVER_FS_ENV=development\nairsprotocols-mcpserver-filesystem\n</code></pre> <p>This provides detailed logging of: - Path validation decisions - Policy matching process - Security check results - Risk assessment details</p>"},{"location":"servers/filesystem/configuration/security/#related-sections","title":"Related Sections","text":"<ul> <li>Configuration Overview: Overall security architecture</li> <li>Environment Setup: Environment-specific security</li> <li>Claude Desktop Integration: Client security considerations</li> <li>Troubleshooting: Security problem resolution</li> </ul>"},{"location":"servers/filesystem/configuration/troubleshooting/","title":"Configuration Troubleshooting","text":"<p>This section provides comprehensive troubleshooting guidance for common AIRS MCP-FS configuration issues, complete with diagnostic steps and solutions.</p>"},{"location":"servers/filesystem/configuration/troubleshooting/#quick-diagnostic-checklist","title":"Quick Diagnostic Checklist","text":"<p>When experiencing issues, run through this checklist:</p> <ol> <li>\u2705 Binary Accessibility: Can you run <code>airsprotocols-mcpserver-filesystem --help</code>?</li> <li>\u2705 Configuration File: Does your config file exist and have correct syntax?</li> <li>\u2705 Environment Detection: Is <code>AIRS_MCP_FS_ENV</code> set correctly?</li> <li>\u2705 Path Permissions: Are your allowed paths accessible?</li> <li>\u2705 Claude Desktop Config: Is the JSON configuration syntactically correct?</li> <li>\u2705 Log Files: Are there error messages in the log files?</li> </ol>"},{"location":"servers/filesystem/configuration/troubleshooting/#configuration-loading-issues","title":"Configuration Loading Issues","text":""},{"location":"servers/filesystem/configuration/troubleshooting/#problem-configuration-file-not-found","title":"Problem: Configuration File Not Found","text":"<p>Symptoms: <pre><code>\ud83d\udccb Configuration loaded from production environment\n   Configuration files: []\n   Environment variables: 0 overrides\n\n\u26a0\ufe0f  Using built-in defaults - no configuration file found\n</code></pre></p> <p>Diagnostic Steps: <pre><code># Check if environment is detected correctly\necho $AIRS_MCP_FS_ENV\n\n# Check if config directory exists\nls -la ~/.config/airsprotocols-mcpserver-filesystem/\n\n# Check if config file exists for your environment\nls -la ~/.config/airsprotocols-mcpserver-filesystem/development.toml\n</code></pre></p> <p>Solutions:</p> <ol> <li> <p>Generate Missing Configuration <pre><code># Generate development configuration\nairsprotocols-mcpserver-filesystem generate-config --env development\n\n# Generate for specific environment\nairsprotocols-mcpserver-filesystem generate-config --env production --output ~/.config/airsprotocols-mcpserver-filesystem\n</code></pre></p> </li> <li> <p>Set Explicit Config Directory <pre><code>{\n  \"mcpServers\": {\n    \"airsprotocols-mcpserver-filesystem\": {\n      \"env\": {\n        \"AIRS_MCP_FS_CONFIG_DIR\": \"/Users/username/.config/airsprotocols-mcpserver-filesystem\"\n      }\n    }\n  }\n}\n</code></pre></p> </li> <li> <p>Create Manual Configuration <pre><code># Create config directory\nmkdir -p ~/.config/airsprotocols-mcpserver-filesystem\n\n# Create basic development configuration\ncat &gt; ~/.config/airsprotocols-mcpserver-filesystem/development.toml &lt;&lt; 'EOF'\n[security.filesystem]\nallowed_paths = [\"~/Documents/**/*\", \"~/projects/**/*\"]\n\n[security.operations]\nread_allowed = true\nwrite_requires_policy = false\ndelete_requires_explicit_allow = true\nEOF\n</code></pre></p> </li> </ol>"},{"location":"servers/filesystem/configuration/troubleshooting/#problem-configuration-syntax-errors","title":"Problem: Configuration Syntax Errors","text":"<p>Symptoms: <pre><code>\u274c Configuration loading failed: TOML parse error at line 5, column 1\n</code></pre></p> <p>Diagnostic Steps: <pre><code># Validate TOML syntax\npython3 -c \"import tomllib; tomllib.load(open('~/.config/airsprotocols-mcpserver-filesystem/development.toml', 'rb'))\"\n\n# Or use a TOML validator\ntoml-validator ~/.config/airsprotocols-mcpserver-filesystem/development.toml\n</code></pre></p> <p>Solutions:</p> <ol> <li> <p>Fix Common TOML Errors <pre><code># \u274c Missing quotes around strings\nallowed_paths = [~/Documents/**/*]\n\n# \u2705 Correct string quoting\nallowed_paths = [\"~/Documents/**/*\"]\n\n# \u274c Invalid section header\n[security][filesystem]\n\n# \u2705 Correct nested section\n[security.filesystem]\n</code></pre></p> </li> <li> <p>Validate Configuration Structure <pre><code># Test configuration loading manually\nRUST_LOG=debug airsprotocols-mcpserver-filesystem 2&gt;&amp;1 | grep -i config\n</code></pre></p> </li> </ol>"},{"location":"servers/filesystem/configuration/troubleshooting/#permission-and-security-issues","title":"Permission and Security Issues","text":""},{"location":"servers/filesystem/configuration/troubleshooting/#problem-security-validation-failed-access-denied","title":"Problem: \"Security validation failed: Access denied\"","text":"<p>Symptoms: <pre><code>\u274c Security validation failed: Access denied for path: /Users/username/Documents/file.txt\n</code></pre></p> <p>Diagnostic Steps: <pre><code># Check current configuration\ncat ~/.config/airsprotocols-mcpserver-filesystem/development.toml | grep -A 5 allowed_paths\n\n# Test path matching manually\nRUST_LOG=debug airsprotocols-mcpserver-filesystem 2&gt;&amp;1 | grep -i \"path validation\"\n</code></pre></p> <p>Root Causes and Solutions:</p> <ol> <li> <p>Path Not in Allowed Paths <pre><code># \u274c Path not included\n[security.filesystem]\nallowed_paths = [\"~/projects/**/*\"]\n\n# \u2705 Add required path\n[security.filesystem]\nallowed_paths = [\n    \"~/projects/**/*\",\n    \"~/Documents/**/*\"  # Add this line\n]\n</code></pre></p> </li> <li> <p>Glob Pattern Doesn't Match <pre><code># \u274c Pattern doesn't match directory itself\nallowed_paths = [\"~/Documents/**/*\"]  # Matches contents but not directory\n\n# \u2705 Include both directory and contents\nallowed_paths = [\n    \"~/Documents\",        # Directory itself\n    \"~/Documents/**/*\"    # Directory contents\n]\n</code></pre></p> </li> <li> <p>Denied Paths Taking Precedence <pre><code># Check if path is in denied_paths\n[security.filesystem]\nallowed_paths = [\"~/Documents/**/*\"]\ndenied_paths = [\"~/.*/**\"]  # This might block ~/Documents\n\n# \u2705 Make denied paths more specific\ndenied_paths = [\n    \"**/.git/**\",\n    \"**/.env*\",\n    \"~/Library/**\"  # More specific than ~/.*/**\n]\n</code></pre></p> </li> </ol>"},{"location":"servers/filesystem/configuration/troubleshooting/#problem-write-operation-requires-policy","title":"Problem: \"Write operation requires policy\"","text":"<p>Symptoms: <pre><code>\u274c Write operation denied: No matching policy found for /Users/username/Documents/file.txt\n</code></pre></p> <p>Diagnostic Steps: <pre><code># Check operation configuration\ncat ~/.config/airsprotocols-mcpserver-filesystem/development.toml | grep -A 5 operations\n\n# Check security policies\ncat ~/.config/airsprotocols-mcpserver-filesystem/development.toml | grep -A 10 policies\n</code></pre></p> <p>Solutions:</p> <ol> <li> <p>Disable Policy Requirement for Development <pre><code>[security.operations]\nread_allowed = true\nwrite_requires_policy = false  # Allow writes without policy\ndelete_requires_explicit_allow = true\n</code></pre></p> </li> <li> <p>Create Appropriate Security Policy <pre><code>[security.policies.document_files]\npatterns = [\"~/Documents/**/*.{txt,md,doc}\"]\noperations = [\"read\", \"write\"]\nrisk_level = \"low\"\ndescription = \"Personal document files\"\n</code></pre></p> </li> <li> <p>Use Environment Variables Override <pre><code>{\n  \"mcpServers\": {\n    \"airsprotocols-mcpserver-filesystem\": {\n      \"env\": {\n        \"AIRS_MCP_FS_SECURITY_OPERATIONS_WRITE_REQUIRES_POLICY\": \"false\"\n      }\n    }\n  }\n}\n</code></pre></p> </li> </ol>"},{"location":"servers/filesystem/configuration/troubleshooting/#environment-detection-issues","title":"Environment Detection Issues","text":""},{"location":"servers/filesystem/configuration/troubleshooting/#problem-wrong-environment-detected","title":"Problem: Wrong Environment Detected","text":"<p>Symptoms: <pre><code>\ud83d\udccb Configuration loaded from production environment\n</code></pre> (When you expected development)</p> <p>Diagnostic Steps: <pre><code># Check environment variables\necho \"AIRS_MCP_FS_ENV: $AIRS_MCP_FS_ENV\"\necho \"NODE_ENV: $NODE_ENV\"\necho \"ENVIRONMENT: $ENVIRONMENT\"\n\n# Check if running in debug mode\ncargo --version\nrustc --version\n</code></pre></p> <p>Solutions:</p> <ol> <li> <p>Set Explicit Environment Variable <pre><code>{\n  \"mcpServers\": {\n    \"airsprotocols-mcpserver-filesystem\": {\n      \"env\": {\n        \"AIRS_MCP_FS_ENV\": \"development\"\n      }\n    }\n  }\n}\n</code></pre></p> </li> <li> <p>Check for Conflicting Environment Variables <pre><code># Unset conflicting variables\nunset NODE_ENV\nunset ENVIRONMENT\n\n# Set AIRS-specific variable\nexport AIRS_MCP_FS_ENV=development\n</code></pre></p> </li> </ol>"},{"location":"servers/filesystem/configuration/troubleshooting/#claude-desktop-integration-issues","title":"Claude Desktop Integration Issues","text":""},{"location":"servers/filesystem/configuration/troubleshooting/#problem-mcp-server-not-loading","title":"Problem: MCP Server Not Loading","text":"<p>Symptoms: Claude Desktop doesn't show filesystem tools available</p> <p>Diagnostic Steps: <pre><code># Check if binary exists and is executable\nls -la /path/to/airsprotocols-mcpserver-filesystem\nfile /path/to/airsprotocols-mcpserver-filesystem\n\n# Test binary directly\n/path/to/airsprotocols-mcpserver-filesystem --help\n\n# Validate JSON configuration\npython3 -m json.tool &lt; \"~/Library/Application Support/Claude/claude_desktop_config.json\"\n</code></pre></p> <p>Solutions:</p> <ol> <li> <p>Fix Binary Path <pre><code># Find correct binary path\nwhich airsprotocols-mcpserver-filesystem\n\n# Or use absolute path\nrealpath target/release/airsprotocols-mcpserver-filesystem\n</code></pre></p> </li> <li> <p>Fix JSON Configuration <pre><code>{\n  \"mcpServers\": {\n    \"airsprotocols-mcpserver-filesystem\": {\n      \"command\": \"/correct/absolute/path/to/airsprotocols-mcpserver-filesystem\",\n      \"env\": {\n        \"AIRS_MCP_FS_ENV\": \"development\"\n      }\n    }\n  }\n}\n</code></pre></p> </li> <li> <p>Check Binary Permissions <pre><code># Make binary executable\nchmod +x /path/to/airsprotocols-mcpserver-filesystem\n\n# Check architecture compatibility\nfile /path/to/airsprotocols-mcpserver-filesystem\n</code></pre></p> </li> </ol>"},{"location":"servers/filesystem/configuration/troubleshooting/#problem-invalid-server-response-errors","title":"Problem: \"Invalid server response\" Errors","text":"<p>Symptoms: Claude Desktop shows MCP communication errors</p> <p>Diagnostic Steps: <pre><code># Check log files\ntail -f ~/.local/share/airsprotocols-mcpserver-filesystem/logs/airsprotocols-mcpserver-filesystem.log\n\n# Test server communication manually\necho '{\"jsonrpc\":\"2.0\",\"id\":1,\"method\":\"initialize\",\"params\":{}}' | /path/to/airsprotocols-mcpserver-filesystem\n</code></pre></p> <p>Solutions:</p> <ol> <li> <p>Check Log Directory Permissions <pre><code># Create log directory if it doesn't exist\nmkdir -p ~/.local/share/airsprotocols-mcpserver-filesystem/logs\n\n# Set proper permissions\nchmod 755 ~/.local/share/airsprotocols-mcpserver-filesystem/logs\n</code></pre></p> </li> <li> <p>Set Explicit Log Directory <pre><code>{\n  \"mcpServers\": {\n    \"airsprotocols-mcpserver-filesystem\": {\n      \"env\": {\n        \"AIRS_MCP_FS_LOG_DIR\": \"/Users/username/.local/share/airsprotocols-mcpserver-filesystem/logs\"\n      }\n    }\n  }\n}\n</code></pre></p> </li> </ol>"},{"location":"servers/filesystem/configuration/troubleshooting/#path-and-glob-pattern-issues","title":"Path and Glob Pattern Issues","text":""},{"location":"servers/filesystem/configuration/troubleshooting/#problem-glob-patterns-not-matching-expected-files","title":"Problem: Glob Patterns Not Matching Expected Files","text":"<p>Symptoms: Files you expect to be accessible are denied</p> <p>Diagnostic Steps: <pre><code># Test glob patterns manually\nfind ~/Documents -name \"*.txt\" | head -5\n\n# Check pattern syntax\necho \"Pattern: ~/Documents/**/*.txt\"\necho \"Test file: ~/Documents/notes/todo.txt\"\n</code></pre></p> <p>Pattern Testing Tool: <pre><code># Create a simple pattern tester\ncat &gt; test_pattern.py &lt;&lt; 'EOF'\nimport glob\nimport sys\n\npattern = sys.argv[1]\ntest_path = sys.argv[2]\n\nmatches = glob.glob(pattern, recursive=True)\nprint(f\"Pattern: {pattern}\")\nprint(f\"Test path: {test_path}\")\nprint(f\"Matches: {test_path in matches}\")\nprint(f\"All matches: {matches[:10]}\")  # Show first 10 matches\nEOF\n\npython3 test_pattern.py \"~/Documents/**/*.txt\" \"~/Documents/notes/todo.txt\"\n</code></pre></p> <p>Solutions:</p> <ol> <li> <p>Fix Common Glob Pattern Issues <pre><code># \u274c Missing recursive wildcard\nallowed_paths = [\"~/Documents/*.txt\"]  # Only matches direct children\n\n# \u2705 Use recursive wildcard\nallowed_paths = [\"~/Documents/**/*.txt\"]  # Matches all subdirectories\n\n# \u274c Forgetting directory access\nallowed_paths = [\"~/Documents/**/*\"]  # Matches contents but not directory\n\n# \u2705 Include directory and contents\nallowed_paths = [\n    \"~/Documents\",        # Directory itself\n    \"~/Documents/**/*\"    # Directory contents\n]\n</code></pre></p> </li> <li> <p>Test Different Pattern Approaches <pre><code># Specific file types\nallowed_paths = [\"~/Documents/**/*.{txt,md,doc,pdf}\"]\n\n# All files in specific directories\nallowed_paths = [\"~/Documents/projects/**/*\"]\n\n# Multiple directory patterns\nallowed_paths = [\n    \"~/Documents/**/*\",\n    \"~/projects/**/*\",\n    \"~/Desktop/**/*\"\n]\n</code></pre></p> </li> </ol>"},{"location":"servers/filesystem/configuration/troubleshooting/#file-size-and-binary-processing-issues","title":"File Size and Binary Processing Issues","text":""},{"location":"servers/filesystem/configuration/troubleshooting/#problem-file-too-large-errors","title":"Problem: \"File too large\" Errors","text":"<p>Symptoms: <pre><code>\u274c File too large: 150MB exceeds maximum size of 100MB\n</code></pre></p> <p>Solutions:</p> <ol> <li> <p>Increase File Size Limit <pre><code>[binary]\nmax_file_size = 209715200  # 200MB\n</code></pre></p> </li> <li> <p>Use Environment Variable Override <pre><code>{\n  \"mcpServers\": {\n    \"airsprotocols-mcpserver-filesystem\": {\n      \"env\": {\n        \"AIRS_MCP_FS_BINARY_MAX_FILE_SIZE\": \"209715200\"\n      }\n    }\n  }\n}\n</code></pre></p> </li> </ol>"},{"location":"servers/filesystem/configuration/troubleshooting/#problem-binary-processing-failures","title":"Problem: Binary Processing Failures","text":"<p>Symptoms: Images or PDFs not processing correctly</p> <p>Diagnostic Steps: <pre><code># Check if binary processing is enabled\ncat ~/.config/airsprotocols-mcpserver-filesystem/development.toml | grep -A 5 binary\n\n# Test file format\nfile ~/Documents/image.jpg\n</code></pre></p> <p>Solutions:</p> <ol> <li> <p>Enable Binary Processing <pre><code>[binary]\nenable_image_processing = true\nenable_pdf_processing = true\n</code></pre></p> </li> <li> <p>Check File Format Support <pre><code># Supported image formats: JPEG, PNG, GIF, WebP, TIFF, BMP\n# Supported document formats: PDF\n</code></pre></p> </li> </ol>"},{"location":"servers/filesystem/configuration/troubleshooting/#advanced-debugging","title":"Advanced Debugging","text":""},{"location":"servers/filesystem/configuration/troubleshooting/#enable-debug-logging","title":"Enable Debug Logging","text":"<pre><code>{\n  \"mcpServers\": {\n    \"airsprotocols-mcpserver-filesystem\": {\n      \"env\": {\n        \"RUST_LOG\": \"debug\",\n        \"AIRS_MCP_FS_ENV\": \"development\"\n      }\n    }\n  }\n}\n</code></pre> <p>This provides detailed logging of: - Configuration loading process - Environment detection logic - Security validation decisions - Path pattern matching - Policy evaluation results</p>"},{"location":"servers/filesystem/configuration/troubleshooting/#log-analysis","title":"Log Analysis","text":"<pre><code># Monitor logs in real-time\ntail -f ~/.local/share/airsprotocols-mcpserver-filesystem/logs/airsprotocols-mcpserver-filesystem.log\n\n# Search for specific errors\ngrep -i \"error\\|denied\\|failed\" ~/.local/share/airsprotocols-mcpserver-filesystem/logs/airsprotocols-mcpserver-filesystem.log\n\n# Filter security-related logs\ngrep -i \"security\\|validation\\|policy\" ~/.local/share/airsprotocols-mcpserver-filesystem/logs/airsprotocols-mcpserver-filesystem.log\n</code></pre>"},{"location":"servers/filesystem/configuration/troubleshooting/#configuration-validation-tool","title":"Configuration Validation Tool","text":"<pre><code># Create configuration validator script\ncat &gt; validate_config.sh &lt;&lt; 'EOF'\n#!/bin/bash\n\nCONFIG_FILE=\"$1\"\nif [ -z \"$CONFIG_FILE\" ]; then\n    echo \"Usage: $0 &lt;config_file&gt;\"\n    exit 1\nfi\n\necho \"Validating configuration: $CONFIG_FILE\"\n\n# Check file exists\nif [ ! -f \"$CONFIG_FILE\" ]; then\n    echo \"\u274c Configuration file not found\"\n    exit 1\nfi\n\n# Check TOML syntax\nif python3 -c \"import tomllib; tomllib.load(open('$CONFIG_FILE', 'rb'))\" 2&gt;/dev/null; then\n    echo \"\u2705 TOML syntax valid\"\nelse\n    echo \"\u274c TOML syntax error\"\n    python3 -c \"import tomllib; tomllib.load(open('$CONFIG_FILE', 'rb'))\"\n    exit 1\nfi\n\n# Test with AIRS MCP-FS\nTEMP_ENV=$(mktemp)\necho \"AIRS_MCP_FS_CONFIG_DIR=$(dirname \"$CONFIG_FILE\")\" &gt; \"$TEMP_ENV\"\necho \"AIRS_MCP_FS_ENV=$(basename \"$CONFIG_FILE\" .toml)\" &gt;&gt; \"$TEMP_ENV\"\n\nif env -i bash -c \"source $TEMP_ENV &amp;&amp; timeout 5s airsprotocols-mcpserver-filesystem\" 2&gt;/dev/null; then\n    echo \"\u2705 Configuration loads successfully\"\nelse\n    echo \"\u274c Configuration loading failed\"\n    echo \"Check logs for details:\"\n    echo \"  tail ~/.local/share/airsprotocols-mcpserver-filesystem/logs/airsprotocols-mcpserver-filesystem.log\"\nfi\n\nrm \"$TEMP_ENV\"\nEOF\n\nchmod +x validate_config.sh\n\n# Use the validator\n./validate_config.sh ~/.config/airsprotocols-mcpserver-filesystem/development.toml\n</code></pre>"},{"location":"servers/filesystem/configuration/troubleshooting/#getting-help","title":"Getting Help","text":""},{"location":"servers/filesystem/configuration/troubleshooting/#log-collection-for-support","title":"Log Collection for Support","text":"<pre><code># Collect diagnostic information\ncat &gt; collect_diagnostics.sh &lt;&lt; 'EOF'\n#!/bin/bash\n\necho \"AIRS MCP-FS Diagnostic Information\"\necho \"==================================\"\necho \"Date: $(date)\"\necho \"OS: $(uname -a)\"\necho \"\"\n\necho \"Environment Variables:\"\necho \"AIRS_MCP_FS_ENV: $AIRS_MCP_FS_ENV\"\necho \"AIRS_MCP_FS_CONFIG_DIR: $AIRS_MCP_FS_CONFIG_DIR\"\necho \"AIRS_MCP_FS_LOG_DIR: $AIRS_MCP_FS_LOG_DIR\"\necho \"\"\n\necho \"Binary Information:\"\nwhich airsprotocols-mcpserver-filesystem\nairsprotocols-mcpserver-filesystem --version 2&gt;/dev/null || echo \"Binary not found or not executable\"\necho \"\"\n\necho \"Configuration Files:\"\nfind ~/.config/airsprotocols-mcpserver-filesystem -name \"*.toml\" 2&gt;/dev/null | head -5\necho \"\"\n\necho \"Recent Log Entries:\"\ntail -20 ~/.local/share/airsprotocols-mcpserver-filesystem/logs/airsprotocols-mcpserver-filesystem.log 2&gt;/dev/null || echo \"No log file found\"\nEOF\n\nchmod +x collect_diagnostics.sh\n./collect_diagnostics.sh &gt; diagnostics.txt\n</code></pre>"},{"location":"servers/filesystem/configuration/troubleshooting/#common-support-requests","title":"Common Support Requests","text":"<ol> <li>Configuration Help: Share your configuration file (remove sensitive paths)</li> <li>Error Logs: Include recent log entries with error messages</li> <li>Environment Info: Share environment detection and variable settings</li> <li>Claude Desktop Config: Share MCP server configuration (remove sensitive paths)</li> </ol>"},{"location":"servers/filesystem/configuration/troubleshooting/#related-sections","title":"Related Sections","text":"<ul> <li>Configuration Overview: Understanding the configuration system</li> <li>Environment Setup: Environment-specific configuration</li> <li>Security Policies: Security policy troubleshooting</li> <li>Claude Desktop Integration: MCP integration issues</li> </ul>"},{"location":"servers/filesystem/security/","title":"Security &amp; Compliance","text":""},{"location":"servers/filesystem/security/#security-framework","title":"Security Framework","text":""},{"location":"servers/filesystem/security/#defense-in-depth","title":"Defense in Depth","text":"<ol> <li>Binary File Restriction: Complete blocking of binary file operations for maximum security</li> <li>Input Validation: Path sanitization and canonicalization</li> <li>Access Control: Configurable allowlists and denylists</li> <li>Human Approval: Interactive approval for sensitive operations</li> <li>Threat Detection: Enhanced security monitoring with binary file rejection</li> <li>Audit Logging: Comprehensive operation tracking</li> <li>Resource Limits: Prevention of DoS through resource exhaustion</li> </ol>"},{"location":"servers/filesystem/security/#configuration-driven-security","title":"Configuration-Driven Security","text":"<pre><code># ~/.config/airsprotocols-mcpserver-filesystem/security.toml\n[security]\n# Binary processing is completely disabled for security\nbinary_processing_disabled = true\ntext_only_mode = true\n\n# Paths where read operations are allowed\nallowed_read_paths = [\n    \"~/Documents/**\",\n    \"~/Desktop/**\", \n    \"~/Projects/**\",\n    \"./**\"\n]\n\n# Paths where write operations are allowed\nallowed_write_paths = [\n    \"~/Documents/**\",\n    \"~/Desktop/**\",\n    \"~/Projects/**\"\n]\n\n# Regex patterns for forbidden files\nforbidden_patterns = [\n    \"\\\\.env$\",\n    \"\\\\.ssh/.*\",\n    \".*\\\\.key$\",\n    \".*password.*\",\n    \"/etc/.*\"\n]\n\n# File size limits (for text files only)\nmax_file_size_mb = 100\n\n# Approval requirements\nrequire_approval_for_writes = true\nrequire_approval_for_deletes = true\n\n# Enhanced threat detection with binary restriction\nenable_threat_detection = true\nblock_binary_files = true\n</code></pre>"},{"location":"servers/filesystem/security/#binary-file-security","title":"Binary File Security","text":""},{"location":"servers/filesystem/security/#complete-binary-restriction","title":"Complete Binary Restriction","text":"<p>AIRS MCP-FS employs a security-first approach by completely disabling binary file processing:</p> <ul> <li>Attack Surface Reduction: Eliminates entire classes of binary-based security vulnerabilities</li> <li>Memory Safety: Prevents buffer overflows and memory corruption from binary parsing</li> <li>Malware Prevention: Blocks execution of potentially malicious binary content</li> <li>Resource Protection: Eliminates resource exhaustion from complex binary processing</li> <li>Compliance Enhancement: Provides clear security boundaries for enterprise deployments</li> </ul>"},{"location":"servers/filesystem/security/#text-only-operations","title":"Text-Only Operations","text":"<p>All file operations are restricted to text-based content: - Source code files (<code>.rs</code>, <code>.ts</code>, <code>.js</code>, <code>.py</code>, etc.) - Configuration files (<code>.toml</code>, <code>.json</code>, <code>.yaml</code>, etc.) - Documentation files (<code>.md</code>, <code>.txt</code>, <code>.rst</code>, etc.) - Data files with text content (<code>.csv</code>, <code>.log</code>, etc.)</p>"},{"location":"servers/filesystem/security/#binary-file-detection","title":"Binary File Detection","text":"<p>The system uses multiple detection methods to identify and block binary files: - File extension validation - Content-based binary detection - Magic number analysis - Comprehensive audit logging of rejection events</p>"},{"location":"servers/filesystem/security/#audit-compliance","title":"Audit &amp; Compliance","text":"<pre><code>#[derive(Serialize)]\npub struct AuditRecord {\n    timestamp: DateTime&lt;Utc&gt;,\n    operation: String,\n    path: String,\n    user_id: Option&lt;String&gt;,\n    client_info: ClientInfo,\n    result: OperationResult,\n    approval_status: Option&lt;ApprovalStatus&gt;,\n    security_context: SecurityContext,\n}\n\nimpl AuditLogger {\n    pub async fn log_operation(&amp;self, record: AuditRecord) -&gt; Result&lt;(), AuditError&gt; {\n        // Write to structured log file\n        let log_entry = serde_json::to_string(&amp;record)?;\n        self.log_writer.write_line(&amp;log_entry).await?;\n\n        // Send to monitoring system if configured\n        if let Some(monitor) = &amp;self.monitoring_client {\n            monitor.send_audit_event(&amp;record).await?;\n        }\n\n        Ok(())\n    }\n}\n</code></pre>"},{"location":"servers/filesystem/security/audit/","title":"Audit Logging","text":"<p>Comprehensive audit logging system for tracking filesystem operations and security events.</p>"},{"location":"servers/filesystem/security/audit/#overview","title":"Overview","text":"<p>The AIRS MCP Filesystem Server provides detailed audit logging for:</p> <ul> <li>All filesystem operations</li> <li>Security decisions and approvals</li> <li>Policy evaluations</li> <li>Access violations</li> <li>System events</li> </ul>"},{"location":"servers/filesystem/security/audit/#log-locations","title":"Log Locations","text":""},{"location":"servers/filesystem/security/audit/#default-locations","title":"Default Locations","text":"<ul> <li>macOS: <code>~/.local/share/airsprotocols-mcpserver-filesystem/logs/</code></li> <li>Linux: <code>~/.local/share/airsprotocols-mcpserver-filesystem/logs/</code></li> <li>Windows: <code>%LOCALAPPDATA%\\airsprotocols-mcpserver-filesystem\\logs\\</code></li> </ul>"},{"location":"servers/filesystem/security/audit/#custom-location","title":"Custom Location","text":"<p>Configure via environment variable:</p> <pre><code>export AIRSPROTOCOLS_MCPSERVER_FS_LOG_DIR=/custom/path/logs\n</code></pre>"},{"location":"servers/filesystem/security/audit/#log-format","title":"Log Format","text":"<p>Logs use JSON format for structured logging:</p> <pre><code>{\n  \"timestamp\": \"2025-12-15T18:30:45.123Z\",\n  \"level\": \"INFO\",\n  \"correlation_id\": \"req_abc123\",\n  \"event_type\": \"file_operation\",\n  \"operation\": \"read_file\",\n  \"path\": \"/home/user/document.txt\",\n  \"user\": \"claude\",\n  \"result\": \"success\",\n  \"duration_ms\": 12\n}\n</code></pre>"},{"location":"servers/filesystem/security/audit/#event-types","title":"Event Types","text":""},{"location":"servers/filesystem/security/audit/#filesystem-operations","title":"Filesystem Operations","text":"<pre><code>{\n  \"event_type\": \"file_operation\",\n  \"operation\": \"write_file\",\n  \"path\": \"/home/user/test.txt\",\n  \"size_bytes\": 1024,\n  \"result\": \"success\"\n}\n</code></pre>"},{"location":"servers/filesystem/security/audit/#security-events","title":"Security Events","text":"<pre><code>{\n  \"event_type\": \"security_validation\",\n  \"operation\": \"delete_file\",\n  \"path\": \"/etc/passwd\",\n  \"result\": \"denied\",\n  \"reason\": \"path_not_allowed\"\n}\n</code></pre>"},{"location":"servers/filesystem/security/audit/#approval-workflow","title":"Approval Workflow","text":"<pre><code>{\n  \"event_type\": \"approval_request\",\n  \"operation\": \"write_file\",\n  \"path\": \"/home/user/important.txt\",\n  \"decision\": \"approved\",\n  \"approval_time_ms\": 2500\n}\n</code></pre>"},{"location":"servers/filesystem/security/audit/#policy-evaluation","title":"Policy Evaluation","text":"<pre><code>{\n  \"event_type\": \"policy_evaluation\",\n  \"policy_name\": \"dev_files\",\n  \"path\": \"/home/user/code.rs\",\n  \"matched\": true,\n  \"risk_level\": \"low\"\n}\n</code></pre>"},{"location":"servers/filesystem/security/audit/#log-levels","title":"Log Levels","text":""},{"location":"servers/filesystem/security/audit/#error","title":"ERROR","text":"<p>Critical errors requiring attention: - System failures - Security violations - Configuration errors</p>"},{"location":"servers/filesystem/security/audit/#warn","title":"WARN","text":"<p>Warning conditions: - Deprecated usage - Performance issues - Configuration warnings</p>"},{"location":"servers/filesystem/security/audit/#info","title":"INFO","text":"<p>Normal operations: - Successful operations - Approvals granted - Policy matches</p>"},{"location":"servers/filesystem/security/audit/#debug","title":"DEBUG","text":"<p>Detailed diagnostic information: - Path resolution - Policy evaluation details - Internal state changes</p>"},{"location":"servers/filesystem/security/audit/#correlation-ids","title":"Correlation IDs","text":"<p>Each request is assigned a unique correlation ID to track related events:</p> <pre><code>{\n  \"correlation_id\": \"req_abc123\",\n  \"event_type\": \"file_operation\",\n  ...\n}\n</code></pre> <p>Search logs by correlation ID to trace complete request lifecycle.</p>"},{"location":"servers/filesystem/security/audit/#security-audit-trail","title":"Security Audit Trail","text":""},{"location":"servers/filesystem/security/audit/#access-tracking","title":"Access Tracking","text":"<p>All file access is logged:</p> <pre><code># Find all access to specific file\ngrep '/etc/config.toml' *.log\n\n# Find all write operations\ngrep '\"operation\":\"write_file\"' *.log\n</code></pre>"},{"location":"servers/filesystem/security/audit/#violation-detection","title":"Violation Detection","text":"<p>Track security violations:</p> <pre><code># Find denied operations\ngrep '\"result\":\"denied\"' *.log\n\n# Find path traversal attempts\ngrep 'path_traversal' *.log\n</code></pre>"},{"location":"servers/filesystem/security/audit/#log-analysis","title":"Log Analysis","text":""},{"location":"servers/filesystem/security/audit/#common-queries","title":"Common Queries","text":"<p>Failed operations: <pre><code>jq 'select(.result == \"failure\")' audit.log\n</code></pre></p> <p>High-risk operations: <pre><code>jq 'select(.risk_level == \"high\")' audit.log\n</code></pre></p> <p>Operations by user: <pre><code>jq 'select(.user == \"claude\")' audit.log\n</code></pre></p> <p>Operations in time range: <pre><code>jq 'select(.timestamp &gt;= \"2025-12-15T00:00:00Z\" and .timestamp &lt;= \"2025-12-15T23:59:59Z\")' audit.log\n</code></pre></p>"},{"location":"servers/filesystem/security/audit/#log-rotation","title":"Log Rotation","text":"<p>Logs are automatically rotated:</p> <ul> <li>Max size: 100MB per file</li> <li>Max files: 10 rotated files</li> <li>Retention: 30 days</li> </ul> <p>Configure rotation:</p> <pre><code>[logging]\nmax_file_size_mb = 100\nmax_backup_files = 10\nretention_days = 30\n</code></pre>"},{"location":"servers/filesystem/security/audit/#compliance","title":"Compliance","text":""},{"location":"servers/filesystem/security/audit/#gdpr-compliance","title":"GDPR Compliance","text":"<p>Logs may contain personal data: - File paths with usernames - Operation timestamps - User identifiers</p> <p>Implement data retention policies as required.</p>"},{"location":"servers/filesystem/security/audit/#soc-2-iso-27001","title":"SOC 2 / ISO 27001","text":"<p>Audit logs support compliance requirements: - Complete audit trail - Immutable logging - Access tracking - Incident investigation</p>"},{"location":"servers/filesystem/security/audit/#best-practices","title":"Best Practices","text":""},{"location":"servers/filesystem/security/audit/#1-regular-review","title":"1. Regular Review","text":"<p>Review logs regularly for: - Unusual access patterns - Repeated failures - Security violations</p>"},{"location":"servers/filesystem/security/audit/#2-monitoring-alerts","title":"2. Monitoring Alerts","text":"<p>Set up alerts for: - Multiple failed operations - Access to sensitive files - Security policy violations</p>"},{"location":"servers/filesystem/security/audit/#3-secure-storage","title":"3. Secure Storage","text":"<p>Protect log files: - Restricted file permissions - Separate log storage - Regular backups</p>"},{"location":"servers/filesystem/security/audit/#4-log-analysis-tools","title":"4. Log Analysis Tools","text":"<p>Use log analysis tools: - ELK Stack (Elasticsearch, Logstash, Kibana) - Splunk - Datadog - Custom scripts</p>"},{"location":"servers/filesystem/security/audit/#example-security-investigation","title":"Example: Security Investigation","text":"<pre><code># 1. Find suspicious activity\ngrep '\"result\":\"denied\"' audit.log | jq .\n\n# 2. Track correlation ID\ngrep '\"correlation_id\":\"req_abc123\"' audit.log | jq .\n\n# 3. Identify patterns\ngrep '/etc/' audit.log | jq -r '.path' | sort | uniq -c\n\n# 4. Generate report\njq -r '[.timestamp, .operation, .path, .result] | @csv' audit.log &gt; report.csv\n</code></pre>"},{"location":"servers/filesystem/security/audit/#see-also","title":"See Also","text":"<ul> <li>Security Model</li> <li>Security Policies</li> <li>Troubleshooting</li> </ul>"},{"location":"servers/filesystem/security/policies/","title":"Security Policies","text":"<p>Comprehensive guide to configuring security policies for the AIRS MCP Filesystem Server.</p>"},{"location":"servers/filesystem/security/policies/#overview","title":"Overview","text":"<p>Security policies define fine-grained access control rules for filesystem operations. They allow you to:</p> <ul> <li>Define operation-specific permissions (read, write, delete, etc.)</li> <li>Create path-based access rules using glob patterns</li> <li>Assign risk levels to different operations</li> <li>Require human approval for sensitive operations</li> </ul>"},{"location":"servers/filesystem/security/policies/#policy-structure","title":"Policy Structure","text":"<p>Each security policy consists of:</p> <pre><code>[security.policies.policy_name]\npatterns = [\"/path/to/files/**/*\"]\noperations = [\"read\", \"write\", \"list\"]\nrisk_level = \"low\"\ndescription = \"Description of what this policy covers\"\n</code></pre>"},{"location":"servers/filesystem/security/policies/#policy-fields","title":"Policy Fields","text":"<ul> <li>patterns: Glob patterns matching file paths</li> <li>operations: List of allowed operations</li> <li>risk_level: Risk assessment (low, medium, high, critical)</li> <li>description: Human-readable explanation</li> </ul>"},{"location":"servers/filesystem/security/policies/#available-operations","title":"Available Operations","text":"<ul> <li><code>read</code> - Read file contents</li> <li><code>write</code> - Create or modify files</li> <li><code>delete</code> - Remove files or directories</li> <li><code>list</code> - List directory contents</li> <li><code>create</code> - Create new directories</li> <li><code>move</code> - Move/rename files</li> <li><code>copy</code> - Copy files</li> </ul>"},{"location":"servers/filesystem/security/policies/#example-policies","title":"Example Policies","text":""},{"location":"servers/filesystem/security/policies/#development-files","title":"Development Files","text":"<pre><code>[security.policies.dev_files]\npatterns = [\n    \"~/projects/**/*.rs\",\n    \"~/projects/**/*.toml\",\n    \"~/projects/**/*.md\"\n]\noperations = [\"read\", \"write\", \"list\"]\nrisk_level = \"low\"\ndescription = \"Development source code and configuration\"\n</code></pre>"},{"location":"servers/filesystem/security/policies/#configuration-files","title":"Configuration Files","text":"<pre><code>[security.policies.config_files]\npatterns = [\n    \"~/.config/**/*\",\n    \"~/projects/**/config/**/*\"\n]\noperations = [\"read\", \"list\"]\nrisk_level = \"medium\"\ndescription = \"Configuration files - read-only\"\n</code></pre>"},{"location":"servers/filesystem/security/policies/#system-files-restricted","title":"System Files (Restricted)","text":"<pre><code>[security.policies.system_protected]\npatterns = [\n    \"/etc/**/*\",\n    \"/usr/**/*\",\n    \"/System/**/*\"\n]\noperations = []  # No operations allowed\nrisk_level = \"critical\"\ndescription = \"System files - completely restricted\"\n</code></pre>"},{"location":"servers/filesystem/security/policies/#policy-evaluation","title":"Policy Evaluation","text":"<p>Policies are evaluated in order:</p> <ol> <li>Path matching: Check if file path matches any policy pattern</li> <li>Operation check: Verify requested operation is in allowed list</li> <li>Risk assessment: Apply risk-based approval requirements</li> <li>Approval workflow: Trigger human approval if required</li> </ol>"},{"location":"servers/filesystem/security/policies/#risk-levels","title":"Risk Levels","text":""},{"location":"servers/filesystem/security/policies/#low-risk","title":"Low Risk","text":"<ul> <li>Standard development files</li> <li>Documentation</li> <li>Personal notes</li> <li>No approval required</li> </ul>"},{"location":"servers/filesystem/security/policies/#medium-risk","title":"Medium Risk","text":"<ul> <li>Configuration files</li> <li>Shared resources</li> <li>May require approval based on settings</li> </ul>"},{"location":"servers/filesystem/security/policies/#high-risk","title":"High Risk","text":"<ul> <li>System configuration</li> <li>Sensitive data</li> <li>Requires approval</li> </ul>"},{"location":"servers/filesystem/security/policies/#critical-risk","title":"Critical Risk","text":"<ul> <li>System files</li> <li>Protected resources</li> <li>Blocked by default</li> </ul>"},{"location":"servers/filesystem/security/policies/#best-practices","title":"Best Practices","text":""},{"location":"servers/filesystem/security/policies/#1-principle-of-least-privilege","title":"1. Principle of Least Privilege","text":"<p>Grant only necessary permissions:</p> <pre><code>[security.policies.project_readonly]\npatterns = [\"~/projects/important/**/*\"]\noperations = [\"read\", \"list\"]  # No write/delete\nrisk_level = \"medium\"\n</code></pre>"},{"location":"servers/filesystem/security/policies/#2-separate-policies-by-purpose","title":"2. Separate Policies by Purpose","text":"<p>Create distinct policies for different use cases:</p> <pre><code># Source code\n[security.policies.source_code]\npatterns = [\"**/*.rs\", \"**/*.py\", \"**/*.js\"]\noperations = [\"read\", \"write\"]\nrisk_level = \"low\"\n\n# Test files\n[security.policies.test_files]\npatterns = [\"**/tests/**/*\", \"**/*_test.*\"]\noperations = [\"read\", \"write\", \"delete\"]\nrisk_level = \"low\"\n</code></pre>"},{"location":"servers/filesystem/security/policies/#3-use-specific-patterns","title":"3. Use Specific Patterns","text":"<p>Prefer specific patterns over wildcards:</p> <pre><code># Good - specific\npatterns = [\"~/projects/myapp/**/*.rs\"]\n\n# Avoid - too broad\npatterns = [\"**/*\"]\n</code></pre>"},{"location":"servers/filesystem/security/policies/#4-document-policies","title":"4. Document Policies","text":"<p>Always include clear descriptions:</p> <pre><code>[security.policies.api_keys]\npatterns = [\"**/.env\", \"**/*.key\", \"**/secrets/**/*\"]\noperations = []\nrisk_level = \"critical\"\ndescription = \"API keys and secrets - no access allowed\"\n</code></pre>"},{"location":"servers/filesystem/security/policies/#environment-specific-policies","title":"Environment-Specific Policies","text":""},{"location":"servers/filesystem/security/policies/#development-environment","title":"Development Environment","text":"<pre><code>[security.operations]\nwrite_requires_policy = false\ndelete_requires_explicit_allow = true\n\n[security.policies.dev_workspace]\npatterns = [\"~/dev/**/*\"]\noperations = [\"read\", \"write\", \"list\", \"create\", \"move\", \"copy\"]\nrisk_level = \"low\"\n</code></pre>"},{"location":"servers/filesystem/security/policies/#production-environment","title":"Production Environment","text":"<pre><code>[security.operations]\nwrite_requires_policy = true\ndelete_requires_explicit_allow = true\n\n[security.policies.prod_readonly]\npatterns = [\"~/prod/**/*\"]\noperations = [\"read\", \"list\"]  # Read-only in production\nrisk_level = \"high\"\n</code></pre>"},{"location":"servers/filesystem/security/policies/#troubleshooting","title":"Troubleshooting","text":""},{"location":"servers/filesystem/security/policies/#operation-not-allowed-by-policy","title":"\"Operation not allowed by policy\"","text":"<p>Cause: Requested operation not in policy's allowed operations</p> <p>Solution: Add the operation to your policy: <pre><code>operations = [\"read\", \"write\", \"list\"]  # Add needed operations\n</code></pre></p>"},{"location":"servers/filesystem/security/policies/#no-matching-policy-found","title":"\"No matching policy found\"","text":"<p>Cause: File path doesn't match any policy pattern</p> <p>Solution: Add a policy covering the path: <pre><code>[security.policies.new_area]\npatterns = [\"/path/to/files/**/*\"]\noperations = [\"read\"]\nrisk_level = \"medium\"\n</code></pre></p>"},{"location":"servers/filesystem/security/policies/#see-also","title":"See Also","text":"<ul> <li>Configuration Guide</li> <li>Security Model</li> <li>Troubleshooting</li> </ul>"},{"location":"servers/filesystem/usage/","title":"Usage Guide","text":"<p>Common patterns and best practices for using the AIRS MCP Filesystem Server.</p>"},{"location":"servers/filesystem/usage/#basic-operations","title":"Basic Operations","text":""},{"location":"servers/filesystem/usage/#reading-files","title":"Reading Files","text":"<pre><code># In Claude Desktop\n\"Read the contents of my README.md file\"\n</code></pre> <p>Claude will use the <code>read_file</code> tool to access and display the file contents.</p>"},{"location":"servers/filesystem/usage/#writing-files","title":"Writing Files","text":"<pre><code>\"Create a new file called notes.txt with 'Hello World'\"\n</code></pre> <p>This triggers the <code>write_file</code> tool with approval workflow.</p>"},{"location":"servers/filesystem/usage/#listing-directories","title":"Listing Directories","text":"<pre><code>\"Show me all files in my Documents folder\"\n</code></pre> <p>Uses the <code>list_directory</code> tool to browse filesystem.</p>"},{"location":"servers/filesystem/usage/#common-workflows","title":"Common Workflows","text":""},{"location":"servers/filesystem/usage/#code-analysis","title":"Code Analysis","text":"<pre><code>\"Analyze all TypeScript files in my project for potential bugs\"\n</code></pre> <p>The server will: 1. List files matching <code>**/*.ts</code> 2. Read each TypeScript file 3. Analyze code patterns 4. Report findings</p>"},{"location":"servers/filesystem/usage/#documentation-generation","title":"Documentation Generation","text":"<pre><code>\"Create API documentation from my source code comments\"\n</code></pre> <p>Workflow: 1. Read source files 2. Extract documentation 3. Generate markdown files 4. Write to docs directory</p>"},{"location":"servers/filesystem/usage/#project-setup","title":"Project Setup","text":"<pre><code>\"Create a new Next.js project structure\"\n</code></pre> <p>The server will: 1. Create directory structure 2. Generate configuration files 3. Set up initial templates</p>"},{"location":"servers/filesystem/usage/#security-patterns","title":"Security Patterns","text":""},{"location":"servers/filesystem/usage/#safe-file-access","title":"Safe File Access","text":"<p>Always configure allowed paths:</p> <pre><code>[security.filesystem]\nallowed_paths = [\n    \"~/projects/**/*\",\n    \"~/Documents/**/*\"\n]\n</code></pre>"},{"location":"servers/filesystem/usage/#approval-workflows","title":"Approval Workflows","text":"<p>Enable approval for sensitive operations:</p> <pre><code>[security.operations]\nwrite_requires_policy = true\ndelete_requires_explicit_allow = true\n</code></pre>"},{"location":"servers/filesystem/usage/#advanced-patterns","title":"Advanced Patterns","text":"<p>See Examples &amp; Use Cases for detailed examples.</p> <p>See Integration Guide for ecosystem integration.</p>"},{"location":"servers/filesystem/usage/examples/","title":"Use Cases &amp; Application Scenarios","text":""},{"location":"servers/filesystem/usage/examples/#development-workflow-enhancement","title":"Development Workflow Enhancement","text":""},{"location":"servers/filesystem/usage/examples/#code-analysis-generation","title":"Code Analysis &amp; Generation","text":"<pre><code>User: \"Analyze all TypeScript files in my src/ directory and identify potential performance issues\"\nAI Process:\n1. list_directory(\"src/\", recursive=true, filter=\"*.ts\")\n2. read_file() for each TypeScript file\n3. Analyze code patterns and provide recommendations\n4. write_file() to create performance-report.md with findings\n</code></pre>"},{"location":"servers/filesystem/usage/examples/#project-documentation","title":"Project Documentation","text":"<pre><code>User: \"Create comprehensive API documentation by reading my OpenAPI spec\"\nAI Process:\n1. read_file(\"api/openapi.yaml\")\n2. Parse specification and generate documentation\n3. create_directory(\"docs/api/\")\n4. write_file() to create structured documentation files\n</code></pre>"},{"location":"servers/filesystem/usage/examples/#automated-refactoring","title":"Automated Refactoring","text":"<pre><code>User: \"Convert all my React class components to functional components with hooks\"\nAI Process:\n1. list_directory() to find React component files\n2. read_file() for each component\n3. Analyze and refactor code\n4. write_file() to save updated components\n</code></pre>"},{"location":"servers/filesystem/usage/examples/#content-asset-management","title":"Content &amp; Asset Management","text":""},{"location":"servers/filesystem/usage/examples/#image-processing-workflows","title":"Image Processing Workflows","text":"<pre><code>User: \"Optimize all product images for web deployment\"\nAI Process:\n1. list_directory(\"assets/products/\", filter=\"*.jpg,*.png\")\n2. read_binary() for each image with processing options\n3. Generate optimized versions and thumbnails\n4. write_binary() to save processed images\n</code></pre>"},{"location":"servers/filesystem/usage/examples/#document-processing","title":"Document Processing","text":"<pre><code>User: \"Extract all text from PDF reports and create searchable markdown versions\"\nAI Process:\n1. list_directory() to find PDF files\n2. read_pdf_advanced() with text extraction\n3. Convert to markdown format\n4. write_file() to create searchable text versions\n</code></pre>"},{"location":"servers/filesystem/usage/examples/#project-organization-management","title":"Project Organization &amp; Management","text":""},{"location":"servers/filesystem/usage/examples/#intelligent-file-organization","title":"Intelligent File Organization","text":"<pre><code>User: \"Organize my Downloads folder by file type and project relevance\"\nAI Process:\n1. list_directory(\"~/Downloads/\")\n2. Analyze file types and content patterns\n3. create_directory() for organized structure\n4. move_file() to relocate files appropriately\n</code></pre>"},{"location":"servers/filesystem/usage/examples/#backup-synchronization","title":"Backup &amp; Synchronization","text":"<pre><code>User: \"Create a backup of my current project with only essential files\"\nAI Process:\n1. Analyze project structure and identify essential files\n2. create_directory() for backup location\n3. copy_file() for selected files\n4. Generate backup manifest and exclusion report\n</code></pre>"},{"location":"servers/filesystem/usage/integration/","title":"Integration &amp; Ecosystem","text":""},{"location":"servers/filesystem/usage/integration/#airs-ecosystem-integration","title":"AIRS Ecosystem Integration","text":""},{"location":"servers/filesystem/usage/integration/#synergy-with-existing-tools","title":"Synergy with Existing Tools","text":"<ul> <li>airs-mcp: Leverages foundational MCP infrastructure and patterns</li> <li>airs-memspec: Could integrate for memory bank file management</li> <li>airs-mcp-kb: Natural pipeline for knowledge base document ingestion</li> </ul>"},{"location":"servers/filesystem/usage/integration/#shared-architecture-patterns","title":"Shared Architecture Patterns","text":"<pre><code>// Consistent with AIRS architectural patterns\npub struct AirsMcpFs {\n    // Reuse MCP infrastructure\n    mcp_foundation: Arc&lt;AirsMcpFoundation&gt;,\n\n    // Consistent security patterns\n    security_manager: Arc&lt;SecurityManager&gt;,\n\n    // Standard error handling\n    error_handler: Arc&lt;ErrorHandler&gt;,\n\n    // Configuration management\n    config: Arc&lt;FsConfig&gt;,\n}\n</code></pre>"},{"location":"servers/filesystem/usage/integration/#mcp-ecosystem-compatibility","title":"MCP Ecosystem Compatibility","text":"<ul> <li>Claude Desktop: Primary integration target</li> <li>VS Code MCP Extensions: Development environment integration</li> <li>Custom MCP Clients: API compatibility for third-party tools</li> <li>Future MCP Tools: Standard protocol ensures broad compatibility</li> </ul>"},{"location":"servers/filesystem/usage/integration/#extension-points","title":"Extension Points","text":"<pre><code>// Plugin architecture for custom file processors\n#[async_trait]\npub trait FileProcessor: Send + Sync {\n    fn supported_types(&amp;self) -&gt; Vec&lt;FileType&gt;;\n    async fn process(&amp;self, path: &amp;Path, options: ProcessingOptions) -&gt; Result&lt;ProcessedContent, ProcessorError&gt;;\n}\n\n// Registry for custom processors\npub struct ProcessorRegistry {\n    processors: HashMap&lt;FileType, Box&lt;dyn FileProcessor&gt;&gt;,\n}\n\nimpl ProcessorRegistry {\n    pub fn register_processor(&amp;mut self, processor: Box&lt;dyn FileProcessor&gt;) {\n        for file_type in processor.supported_types() {\n            self.processors.insert(file_type, processor);\n        }\n    }\n\n    pub async fn process_file(&amp;self, path: &amp;Path, file_type: &amp;FileType) -&gt; Result&lt;ProcessedContent, ProcessorError&gt; {\n        if let Some(processor) = self.processors.get(file_type) {\n            processor.process(path, ProcessingOptions::default()).await\n        } else {\n            Err(ProcessorError::UnsupportedFileType(file_type.clone()))\n        }\n    }\n}\n</code></pre>"}]}